/* generatedStub.h
   Generated by gSOAP 2.7.9l from generated_h.h
   Copyright(C) 2000-2007, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef generatedStub_H
#define generatedStub_H
#include <vector>
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE__genmesh__submesh_usesharedvertices
#define SOAP_TYPE__genmesh__submesh_usesharedvertices (98)
/* genmesh:submesh-usesharedvertices */
enum _genmesh__submesh_usesharedvertices {_genmesh__submesh_usesharedvertices__true_ = 0, _genmesh__submesh_usesharedvertices__false_ = 1};
#endif

#ifndef SOAP_TYPE__genmesh__submesh_use32bitindexes
#define SOAP_TYPE__genmesh__submesh_use32bitindexes (99)
/* genmesh:submesh-use32bitindexes */
enum _genmesh__submesh_use32bitindexes {_genmesh__submesh_use32bitindexes__true_ = 0, _genmesh__submesh_use32bitindexes__false_ = 1};
#endif

#ifndef SOAP_TYPE__genmesh__submesh_operationtype
#define SOAP_TYPE__genmesh__submesh_operationtype (100)
/* genmesh:submesh-operationtype */
enum _genmesh__submesh_operationtype {_genmesh__submesh_operationtype__triangle_USCORElist = 0, _genmesh__submesh_operationtype__triangle_USCOREstrip = 1, _genmesh__submesh_operationtype__triangle_USCOREfan = 2};
#endif

#ifndef SOAP_TYPE__genmesh__levelofdetail_manual
#define SOAP_TYPE__genmesh__levelofdetail_manual (113)
/* genmesh:levelofdetail-manual */
enum _genmesh__levelofdetail_manual {_genmesh__levelofdetail_manual__true_ = 0, _genmesh__levelofdetail_manual__false_ = 1};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer_positions
#define SOAP_TYPE__genmesh__vertexbuffer_positions (119)
/* genmesh:vertexbuffer-positions */
enum _genmesh__vertexbuffer_positions {_genmesh__vertexbuffer_positions__true_ = 0, _genmesh__vertexbuffer_positions__false_ = 1};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer_normals
#define SOAP_TYPE__genmesh__vertexbuffer_normals (120)
/* genmesh:vertexbuffer-normals */
enum _genmesh__vertexbuffer_normals {_genmesh__vertexbuffer_normals__true_ = 0, _genmesh__vertexbuffer_normals__false_ = 1};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREdiffuse
#define SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREdiffuse (121)
/* genmesh:vertexbuffer-colours_diffuse */
enum _genmesh__vertexbuffer_colours_USCOREdiffuse {_genmesh__vertexbuffer_colours_USCOREdiffuse__true_ = 0, _genmesh__vertexbuffer_colours_USCOREdiffuse__false_ = 1};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREspecular
#define SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREspecular (122)
/* genmesh:vertexbuffer-colours_specular */
enum _genmesh__vertexbuffer_colours_USCOREspecular {_genmesh__vertexbuffer_colours_USCOREspecular__true_ = 0, _genmesh__vertexbuffer_colours_USCOREspecular__false_ = 1};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoords
#define SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoords (123)
/* genmesh:vertexbuffer-texture_coords */
enum _genmesh__vertexbuffer_texture_USCOREcoords {_genmesh__vertexbuffer_texture_USCOREcoords__0 = 0, _genmesh__vertexbuffer_texture_USCOREcoords__1 = 1, _genmesh__vertexbuffer_texture_USCOREcoords__2 = 2, _genmesh__vertexbuffer_texture_USCOREcoords__3 = 3, _genmesh__vertexbuffer_texture_USCOREcoords__4 = 4, _genmesh__vertexbuffer_texture_USCOREcoords__5 = 5, _genmesh__vertexbuffer_texture_USCOREcoords__6 = 6, _genmesh__vertexbuffer_texture_USCOREcoords__7 = 7, _genmesh__vertexbuffer_texture_USCOREcoords__8 = 8};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0
#define SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0 (124)
/* genmesh:vertexbuffer-texture_coord_dimensions_0 */
enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0 {_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0__0 = 0, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0__1 = 1, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0__2 = 2, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0__3 = 3};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1
#define SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1 (125)
/* genmesh:vertexbuffer-texture_coord_dimensions_1 */
enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1 {_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1__0 = 0, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1__1 = 1, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1__2 = 2, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1__3 = 3};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2
#define SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2 (126)
/* genmesh:vertexbuffer-texture_coord_dimensions_2 */
enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2 {_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2__0 = 0, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2__1 = 1, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2__2 = 2, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2__3 = 3};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3
#define SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3 (127)
/* genmesh:vertexbuffer-texture_coord_dimensions_3 */
enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3 {_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3__0 = 0, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3__1 = 1, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3__2 = 2, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3__3 = 3};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4
#define SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4 (128)
/* genmesh:vertexbuffer-texture_coord_dimensions_4 */
enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4 {_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4__0 = 0, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4__1 = 1, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4__2 = 2, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4__3 = 3};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5
#define SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5 (129)
/* genmesh:vertexbuffer-texture_coord_dimensions_5 */
enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5 {_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5__0 = 0, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5__1 = 1, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5__2 = 2, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5__3 = 3};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6
#define SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6 (130)
/* genmesh:vertexbuffer-texture_coord_dimensions_6 */
enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6 {_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6__0 = 0, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6__1 = 1, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6__2 = 2, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6__3 = 3};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7
#define SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7 (131)
/* genmesh:vertexbuffer-texture_coord_dimensions_7 */
enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7 {_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7__0 = 0, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7__1 = 1, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7__2 = 2, _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7__3 = 3};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer_tangents
#define SOAP_TYPE__genmesh__vertexbuffer_tangents (132)
/* genmesh:vertexbuffer-tangents */
enum _genmesh__vertexbuffer_tangents {_genmesh__vertexbuffer_tangents__true_ = 0, _genmesh__vertexbuffer_tangents__false_ = 1};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer_tangent_USCOREdimensions
#define SOAP_TYPE__genmesh__vertexbuffer_tangent_USCOREdimensions (133)
/* genmesh:vertexbuffer-tangent_dimensions */
enum _genmesh__vertexbuffer_tangent_USCOREdimensions {_genmesh__vertexbuffer_tangent_USCOREdimensions__3 = 3, _genmesh__vertexbuffer_tangent_USCOREdimensions__4 = 4};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer_binormals
#define SOAP_TYPE__genmesh__vertexbuffer_binormals (134)
/* genmesh:vertexbuffer-binormals */
enum _genmesh__vertexbuffer_binormals {_genmesh__vertexbuffer_binormals__true_ = 0, _genmesh__vertexbuffer_binormals__false_ = 1};
#endif

#ifndef SOAP_TYPE__genmesh__pose_target
#define SOAP_TYPE__genmesh__pose_target (149)
/* genmesh:pose-target */
enum _genmesh__pose_target {_genmesh__pose_target__mesh = 0, _genmesh__pose_target__submesh = 1};
#endif

#ifndef SOAP_TYPE__genmesh__track_target
#define SOAP_TYPE__genmesh__track_target (156)
/* genmesh:track-target */
enum _genmesh__track_target {_genmesh__track_target__mesh = 0, _genmesh__track_target__submesh = 1};
#endif

#ifndef SOAP_TYPE__genmesh__track_type
#define SOAP_TYPE__genmesh__track_type (157)
/* genmesh:track-type */
enum _genmesh__track_type {_genmesh__track_type__morph = 0, _genmesh__track_type__pose = 1};
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/




#ifndef SOAP_TYPE_genmech__stats
#define SOAP_TYPE_genmech__stats (7)
/* genmech:stats */
class SOAP_CMAC genmech__stats
{
public:
	int maxTurnRate;	/* required element of type xsd:int */
	int maxForwardAcceleration;	/* required element of type xsd:int */
	int maxBackwardAcceleration;	/* required element of type xsd:int */
	int maxSpeed;	/* required element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 7; } /* = unique id SOAP_TYPE_genmech__stats */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         genmech__stats() : maxTurnRate(0), maxForwardAcceleration(0), maxBackwardAcceleration(0), maxSpeed(0), soap(NULL) { }
	virtual ~genmech__stats() { }
};
#endif

#if 0 /* volatile type: do not redeclare */

#endif

#ifndef SOAP_TYPE_genmech__design
#define SOAP_TYPE_genmech__design (8)
/* genmech:design */
class SOAP_CMAC genmech__design
{
public:
	class genmech__torso *torso;	/* required element of type genmech:torso */
	class genmech__equSlots *equipmentSlots;	/* required element of type genmech:equSlots */
	std::string torsoBone;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique id SOAP_TYPE_genmech__design */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         genmech__design() : torso(NULL), equipmentSlots(NULL), soap(NULL) { }
	virtual ~genmech__design() { }
};
#endif

#ifndef SOAP_TYPE_genmech__equSlots
#define SOAP_TYPE_genmech__equSlots (9)
/* genmech:equSlots */
class SOAP_CMAC genmech__equSlots
{
public:
	std::vector<class genmech__equSlot * >slot;	/* optional element of type genmech:equSlot */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 9; } /* = unique id SOAP_TYPE_genmech__equSlots */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         genmech__equSlots() : soap(NULL) { }
	virtual ~genmech__equSlots() { }
};
#endif

#ifndef SOAP_TYPE_genmech__equSlot
#define SOAP_TYPE_genmech__equSlot (10)
/* genmech:equSlot */
class SOAP_CMAC genmech__equSlot
{
public:
	std::string boneName;	/* required element of type xsd:string */
	std::string defaultEqu;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_genmech__equSlot */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         genmech__equSlot() : defaultEqu("UNUSED"), soap(NULL) { }
	virtual ~genmech__equSlot() { }
};
#endif

#ifndef SOAP_TYPE_genmech__torso
#define SOAP_TYPE_genmech__torso (11)
/* genmech:torso */
class SOAP_CMAC genmech__torso
{
public:
	int turningRadius;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_genmech__torso */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         genmech__torso() : turningRadius(90), soap(NULL) { }
	virtual ~genmech__torso() { }
};
#endif

#ifndef SOAP_TYPE_genmech__mesh
#define SOAP_TYPE_genmech__mesh (12)
/* genmech:mesh */
class SOAP_CMAC genmech__mesh
{
public:
	std::string translation;	/* optional attribute */
	std::string file;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_genmech__mesh */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         genmech__mesh() : translation("000.00;000.00;000.00"), soap(NULL) { }
	virtual ~genmech__mesh() { }
};
#endif

#ifndef SOAP_TYPE__genmech__mech
#define SOAP_TYPE__genmech__mech (13)
/* genmech:mech */
class SOAP_CMAC _genmech__mech
{
public:
	int schemaVersion;	/* required element of type xsd:int */
	std::string name;	/* required element of type xsd:string */
	genmech__stats *stats;	/* required element of type genmech:stats */
	genmech__design *design;	/* required element of type genmech:design */
	genmech__mesh *mesh;	/* required element of type genmech:mesh */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE__genmech__mech */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmech__mech() : schemaVersion(0), stats(NULL), design(NULL), mesh(NULL), soap(NULL) { }
	virtual ~_genmech__mech() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__mesh
#define SOAP_TYPE__genmesh__mesh (14)
/* genmesh:mesh */
class SOAP_CMAC _genmesh__mesh
{
public:
	class _genmesh__sharedgeometry *genmesh__sharedgeometry;	/* optional element of type genmesh:sharedgeometry */
	class _genmesh__submeshes *genmesh__submeshes;	/* required element of type genmesh:submeshes */
	class _genmesh__skeletonlink *genmesh__skeletonlink;	/* optional element of type genmesh:skeletonlink */
	class _genmesh__boneassignments *genmesh__boneassignments;	/* optional element of type genmesh:boneassignments */
	class _genmesh__levelofdetail *genmesh__levelofdetail;	/* optional element of type genmesh:levelofdetail */
	class _genmesh__submeshnames *genmesh__submeshnames;	/* optional element of type genmesh:submeshnames */
	class _genmesh__poses *genmesh__poses;	/* optional element of type genmesh:poses */
	class _genmesh__animations *genmesh__animations;	/* optional element of type genmesh:animations */
	class _genmesh__extremes *genmesh__extremes;	/* optional element of type genmesh:extremes */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE__genmesh__mesh */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__mesh() : genmesh__sharedgeometry(NULL), genmesh__submeshes(NULL), genmesh__skeletonlink(NULL), genmesh__boneassignments(NULL), genmesh__levelofdetail(NULL), genmesh__submeshnames(NULL), genmesh__poses(NULL), genmesh__animations(NULL), genmesh__extremes(NULL), soap(NULL) { }
	virtual ~_genmesh__mesh() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__sharedgeometry
#define SOAP_TYPE__genmesh__sharedgeometry (15)
/* genmesh:sharedgeometry */
class SOAP_CMAC _genmesh__sharedgeometry
{
public:
	std::vector<class _genmesh__vertexbuffer * >genmesh__vertexbuffer;	/* required element of type genmesh:vertexbuffer */
	std::string vertexcount;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE__genmesh__sharedgeometry */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__sharedgeometry() : soap(NULL) { }
	virtual ~_genmesh__sharedgeometry() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__submeshes
#define SOAP_TYPE__genmesh__submeshes (16)
/* genmesh:submeshes */
class SOAP_CMAC _genmesh__submeshes
{
public:
	std::vector<class _genmesh__submesh * >genmesh__submesh;	/* required element of type genmesh:submesh */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE__genmesh__submeshes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__submeshes() : soap(NULL) { }
	virtual ~_genmesh__submeshes() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__submesh
#define SOAP_TYPE__genmesh__submesh (17)
/* genmesh:submesh */
class SOAP_CMAC _genmesh__submesh
{
public:
	class _genmesh__textures *genmesh__textures;	/* optional element of type genmesh:textures */
	class _genmesh__faces *genmesh__faces;	/* required element of type genmesh:faces */
	class _genmesh__geometry *genmesh__geometry;	/* optional element of type genmesh:geometry */
	_genmesh__boneassignments *genmesh__boneassignments;	/* optional element of type genmesh:boneassignments */
	std::string material;	/* required attribute */
	enum _genmesh__submesh_usesharedvertices usesharedvertices;	/* optional attribute */
	enum _genmesh__submesh_use32bitindexes use32bitindexes;	/* optional attribute */
	enum _genmesh__submesh_operationtype operationtype;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE__genmesh__submesh */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__submesh() : genmesh__textures(NULL), genmesh__faces(NULL), genmesh__geometry(NULL), genmesh__boneassignments(NULL), usesharedvertices((enum _genmesh__submesh_usesharedvertices)0), use32bitindexes((enum _genmesh__submesh_use32bitindexes)0), operationtype((enum _genmesh__submesh_operationtype)0), soap(NULL) { }
	virtual ~_genmesh__submesh() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__textures
#define SOAP_TYPE__genmesh__textures (18)
/* genmesh:textures */
class SOAP_CMAC _genmesh__textures
{
public:
	std::vector<class _genmesh__texture * >genmesh__texture;	/* required element of type genmesh:texture */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE__genmesh__textures */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__textures() : soap(NULL) { }
	virtual ~_genmesh__textures() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__texture
#define SOAP_TYPE__genmesh__texture (19)
/* genmesh:texture */
class SOAP_CMAC _genmesh__texture
{
public:
	std::string alias;	/* required attribute */
	std::string name;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE__genmesh__texture */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__texture() : soap(NULL) { }
	virtual ~_genmesh__texture() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__faces
#define SOAP_TYPE__genmesh__faces (20)
/* genmesh:faces */
class SOAP_CMAC _genmesh__faces
{
public:
	std::vector<class _genmesh__face * >genmesh__face;	/* required element of type genmesh:face */
	std::string *count;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE__genmesh__faces */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__faces() : count(NULL), soap(NULL) { }
	virtual ~_genmesh__faces() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__face
#define SOAP_TYPE__genmesh__face (21)
/* genmesh:face */
class SOAP_CMAC _genmesh__face
{
public:
	std::string v1;	/* required attribute */
	std::string *v2;	/* optional attribute */
	std::string *v3;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE__genmesh__face */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__face() : v2(NULL), v3(NULL), soap(NULL) { }
	virtual ~_genmesh__face() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__geometry
#define SOAP_TYPE__genmesh__geometry (22)
/* genmesh:geometry */
class SOAP_CMAC _genmesh__geometry
{
public:
	std::vector<_genmesh__vertexbuffer * >genmesh__vertexbuffer;	/* required element of type genmesh:vertexbuffer */
	std::string *vertexcount;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE__genmesh__geometry */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__geometry() : vertexcount(NULL), soap(NULL) { }
	virtual ~_genmesh__geometry() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__skeletonlink
#define SOAP_TYPE__genmesh__skeletonlink (23)
/* genmesh:skeletonlink */
class SOAP_CMAC _genmesh__skeletonlink
{
public:
	std::string name;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE__genmesh__skeletonlink */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__skeletonlink() : soap(NULL) { }
	virtual ~_genmesh__skeletonlink() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__boneassignments
#define SOAP_TYPE__genmesh__boneassignments (24)
/* genmesh:boneassignments */
class SOAP_CMAC _genmesh__boneassignments
{
public:
	std::vector<class _genmesh__vertexboneassignment * >genmesh__vertexboneassignment;	/* required element of type genmesh:vertexboneassignment */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE__genmesh__boneassignments */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__boneassignments() : soap(NULL) { }
	virtual ~_genmesh__boneassignments() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__vertexboneassignment
#define SOAP_TYPE__genmesh__vertexboneassignment (25)
/* genmesh:vertexboneassignment */
class SOAP_CMAC _genmesh__vertexboneassignment
{
public:
	std::string vertexindex;	/* required attribute */
	std::string boneindex;	/* required attribute */
	std::string weight;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE__genmesh__vertexboneassignment */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__vertexboneassignment() : weight("1.0"), soap(NULL) { }
	virtual ~_genmesh__vertexboneassignment() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__union_levelofdetail
#define SOAP_TYPE__genmesh__union_levelofdetail (111)
/* xsd:choice */
union _genmesh__union_levelofdetail
{
#define SOAP_UNION__genmesh__union_levelofdetail_genmesh__lodmanual	(1)
	class _genmesh__lodmanual *genmesh__lodmanual;
#define SOAP_UNION__genmesh__union_levelofdetail_genmesh__lodgenerated	(2)
	class _genmesh__lodgenerated *genmesh__lodgenerated;
};
#endif

#ifndef SOAP_TYPE___genmesh__union_levelofdetail
#define SOAP_TYPE___genmesh__union_levelofdetail (108)
/* Operation wrapper: */
class SOAP_CMAC __genmesh__union_levelofdetail
{
public:
	int __union_levelofdetail;	/* union discriminant (of union defined below) */
	union _genmesh__union_levelofdetail union_levelofdetail;	/* required element of type xsd:choice */
public:
	virtual int soap_type() const { return 108; } /* = unique id SOAP_TYPE___genmesh__union_levelofdetail */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __genmesh__union_levelofdetail() : __union_levelofdetail(0) { }
	virtual ~__genmesh__union_levelofdetail() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__levelofdetail
#define SOAP_TYPE__genmesh__levelofdetail (26)
/* genmesh:levelofdetail */
class SOAP_CMAC _genmesh__levelofdetail
{
public:
	int __size_levelofdetail;	/* sequence of elements <-union-levelofdetail> */
	__genmesh__union_levelofdetail *__union_levelofdetail;
	std::string numlevels;	/* required attribute */
	enum _genmesh__levelofdetail_manual manual;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE__genmesh__levelofdetail */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__levelofdetail() : __size_levelofdetail(0), __union_levelofdetail(NULL), manual((enum _genmesh__levelofdetail_manual)0), soap(NULL) { }
	virtual ~_genmesh__levelofdetail() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__lodmanual
#define SOAP_TYPE__genmesh__lodmanual (27)
/* genmesh:lodmanual */
class SOAP_CMAC _genmesh__lodmanual
{
public:
	std::string fromdepthsquared;	/* required attribute */
	std::string meshname;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE__genmesh__lodmanual */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__lodmanual() : soap(NULL) { }
	virtual ~_genmesh__lodmanual() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__lodgenerated
#define SOAP_TYPE__genmesh__lodgenerated (28)
/* genmesh:lodgenerated */
class SOAP_CMAC _genmesh__lodgenerated
{
public:
	class _genmesh__lodfacelist *genmesh__lodfacelist;	/* required element of type genmesh:lodfacelist */
	std::string fromdepthsquared;	/* required attribute */
	std::string meshname;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE__genmesh__lodgenerated */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__lodgenerated() : genmesh__lodfacelist(NULL), soap(NULL) { }
	virtual ~_genmesh__lodgenerated() { }
};
#endif

#ifndef SOAP_TYPE___genmesh__lodfacelist_sequence
#define SOAP_TYPE___genmesh__lodfacelist_sequence (115)
/* Operation wrapper: */
class SOAP_CMAC __genmesh__lodfacelist_sequence
{
public:
	_genmesh__face *genmesh__face;	/* required element of type genmesh:face */
public:
	virtual int soap_type() const { return 115; } /* = unique id SOAP_TYPE___genmesh__lodfacelist_sequence */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __genmesh__lodfacelist_sequence() : genmesh__face(NULL) { }
	virtual ~__genmesh__lodfacelist_sequence() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__lodfacelist
#define SOAP_TYPE__genmesh__lodfacelist (29)
/* genmesh:lodfacelist */
class SOAP_CMAC _genmesh__lodfacelist
{
public:
	int __size_lodfacelist_sequence;	/* sequence of elements <-lodfacelist-sequence> */
	__genmesh__lodfacelist_sequence *__lodfacelist_sequence;
	std::string submeshindex;	/* required attribute */
	std::string numfaces;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE__genmesh__lodfacelist */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__lodfacelist() : __size_lodfacelist_sequence(0), __lodfacelist_sequence(NULL), soap(NULL) { }
	virtual ~_genmesh__lodfacelist() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__vertexbuffer
#define SOAP_TYPE__genmesh__vertexbuffer (30)
/* genmesh:vertexbuffer */
class SOAP_CMAC _genmesh__vertexbuffer
{
public:
	std::vector<class _genmesh__vertex * >genmesh__vertex;	/* required element of type genmesh:vertex */
	enum _genmesh__vertexbuffer_positions positions;	/* optional attribute */
	enum _genmesh__vertexbuffer_normals normals;	/* optional attribute */
	enum _genmesh__vertexbuffer_colours_USCOREdiffuse colours_USCOREdiffuse;	/* optional attribute */
	enum _genmesh__vertexbuffer_colours_USCOREspecular colours_USCOREspecular;	/* optional attribute */
	enum _genmesh__vertexbuffer_texture_USCOREcoords texture_USCOREcoords;	/* optional attribute */
	enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0 texture_USCOREcoord_USCOREdimensions_USCORE0;	/* optional attribute */
	enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1 texture_USCOREcoord_USCOREdimensions_USCORE1;	/* optional attribute */
	enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2 texture_USCOREcoord_USCOREdimensions_USCORE2;	/* optional attribute */
	enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3 texture_USCOREcoord_USCOREdimensions_USCORE3;	/* optional attribute */
	enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4 texture_USCOREcoord_USCOREdimensions_USCORE4;	/* optional attribute */
	enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5 texture_USCOREcoord_USCOREdimensions_USCORE5;	/* optional attribute */
	enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6 texture_USCOREcoord_USCOREdimensions_USCORE6;	/* optional attribute */
	enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7 texture_USCOREcoord_USCOREdimensions_USCORE7;	/* optional attribute */
	enum _genmesh__vertexbuffer_tangents tangents;	/* optional attribute */
	enum _genmesh__vertexbuffer_tangent_USCOREdimensions tangent_USCOREdimensions;	/* optional attribute */
	enum _genmesh__vertexbuffer_binormals binormals;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE__genmesh__vertexbuffer */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__vertexbuffer() : positions((enum _genmesh__vertexbuffer_positions)0), normals((enum _genmesh__vertexbuffer_normals)0), colours_USCOREdiffuse((enum _genmesh__vertexbuffer_colours_USCOREdiffuse)0), colours_USCOREspecular((enum _genmesh__vertexbuffer_colours_USCOREspecular)0), texture_USCOREcoords((enum _genmesh__vertexbuffer_texture_USCOREcoords)0), texture_USCOREcoord_USCOREdimensions_USCORE0((enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0)0), texture_USCOREcoord_USCOREdimensions_USCORE1((enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1)0), texture_USCOREcoord_USCOREdimensions_USCORE2((enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2)0), texture_USCOREcoord_USCOREdimensions_USCORE3((enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3)0), texture_USCOREcoord_USCOREdimensions_USCORE4((enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4)0), texture_USCOREcoord_USCOREdimensions_USCORE5((enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5)0), texture_USCOREcoord_USCOREdimensions_USCORE6((enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6)0), texture_USCOREcoord_USCOREdimensions_USCORE7((enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7)0), tangents((enum _genmesh__vertexbuffer_tangents)0), tangent_USCOREdimensions((enum _genmesh__vertexbuffer_tangent_USCOREdimensions)0), binormals((enum _genmesh__vertexbuffer_binormals)0), soap(NULL) { }
	virtual ~_genmesh__vertexbuffer() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__vertex
#define SOAP_TYPE__genmesh__vertex (31)
/* genmesh:vertex */
class SOAP_CMAC _genmesh__vertex
{
public:
	class _genmesh__position *genmesh__position;	/* required element of type genmesh:position */
	class _genmesh__normal *genmesh__normal;	/* optional element of type genmesh:normal */
	class _genmesh__tangent *genmesh__tangent;	/* optional element of type genmesh:tangent */
	class _genmesh__binormal *genmesh__binormal;	/* optional element of type genmesh:binormal */
	class _genmesh__colour_USCOREdiffuse *genmesh__colour_USCOREdiffuse;	/* optional element of type genmesh:colour_diffuse */
	class _genmesh__colour_USCOREspecular *genmesh__colour_USCOREspecular;	/* optional element of type genmesh:colour_specular */
	std::vector<class _genmesh__texcoord * >genmesh__texcoord;	/* optional element of type genmesh:texcoord */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE__genmesh__vertex */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__vertex() : genmesh__position(NULL), genmesh__normal(NULL), genmesh__tangent(NULL), genmesh__binormal(NULL), genmesh__colour_USCOREdiffuse(NULL), genmesh__colour_USCOREspecular(NULL), soap(NULL) { }
	virtual ~_genmesh__vertex() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__position
#define SOAP_TYPE__genmesh__position (32)
/* genmesh:position */
class SOAP_CMAC _genmesh__position
{
public:
	std::string x;	/* required attribute */
	std::string y;	/* required attribute */
	std::string z;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE__genmesh__position */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__position() : soap(NULL) { }
	virtual ~_genmesh__position() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__normal
#define SOAP_TYPE__genmesh__normal (33)
/* genmesh:normal */
class SOAP_CMAC _genmesh__normal
{
public:
	std::string x;	/* required attribute */
	std::string y;	/* required attribute */
	std::string z;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE__genmesh__normal */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__normal() : soap(NULL) { }
	virtual ~_genmesh__normal() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__tangent
#define SOAP_TYPE__genmesh__tangent (34)
/* genmesh:tangent */
class SOAP_CMAC _genmesh__tangent
{
public:
	std::string x;	/* required attribute */
	std::string y;	/* required attribute */
	std::string z;	/* required attribute */
	std::string w;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE__genmesh__tangent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__tangent() : w("1"), soap(NULL) { }
	virtual ~_genmesh__tangent() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__binormal
#define SOAP_TYPE__genmesh__binormal (35)
/* genmesh:binormal */
class SOAP_CMAC _genmesh__binormal
{
public:
	std::string x;	/* required attribute */
	std::string y;	/* required attribute */
	std::string z;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE__genmesh__binormal */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__binormal() : soap(NULL) { }
	virtual ~_genmesh__binormal() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__colour_USCOREdiffuse
#define SOAP_TYPE__genmesh__colour_USCOREdiffuse (36)
/* genmesh:colour_diffuse */
class SOAP_CMAC _genmesh__colour_USCOREdiffuse
{
public:
	std::string value;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE__genmesh__colour_USCOREdiffuse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__colour_USCOREdiffuse() : soap(NULL) { }
	virtual ~_genmesh__colour_USCOREdiffuse() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__colour_USCOREspecular
#define SOAP_TYPE__genmesh__colour_USCOREspecular (37)
/* genmesh:colour_specular */
class SOAP_CMAC _genmesh__colour_USCOREspecular
{
public:
	std::string value;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE__genmesh__colour_USCOREspecular */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__colour_USCOREspecular() : soap(NULL) { }
	virtual ~_genmesh__colour_USCOREspecular() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__texcoord
#define SOAP_TYPE__genmesh__texcoord (38)
/* genmesh:texcoord */
class SOAP_CMAC _genmesh__texcoord
{
public:
	std::string u;	/* required attribute */
	std::string v;	/* optional attribute */
	std::string w;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE__genmesh__texcoord */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__texcoord() : v("0"), w("0"), soap(NULL) { }
	virtual ~_genmesh__texcoord() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__submeshnames
#define SOAP_TYPE__genmesh__submeshnames (39)
/* genmesh:submeshnames */
class SOAP_CMAC _genmesh__submeshnames
{
public:
	std::vector<class _genmesh__submeshname * >genmesh__submeshname;	/* required element of type genmesh:submeshname */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE__genmesh__submeshnames */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__submeshnames() : soap(NULL) { }
	virtual ~_genmesh__submeshnames() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__submeshname
#define SOAP_TYPE__genmesh__submeshname (40)
/* genmesh:submeshname */
class SOAP_CMAC _genmesh__submeshname
{
public:
	std::string name;	/* required attribute */
	std::string index;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE__genmesh__submeshname */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__submeshname() : soap(NULL) { }
	virtual ~_genmesh__submeshname() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__poses
#define SOAP_TYPE__genmesh__poses (41)
/* genmesh:poses */
class SOAP_CMAC _genmesh__poses
{
public:
	std::vector<class _genmesh__pose * >genmesh__pose;	/* required element of type genmesh:pose */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE__genmesh__poses */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__poses() : soap(NULL) { }
	virtual ~_genmesh__poses() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__pose
#define SOAP_TYPE__genmesh__pose (42)
/* genmesh:pose */
class SOAP_CMAC _genmesh__pose
{
public:
	std::vector<class _genmesh__poseoffset * >genmesh__poseoffset;	/* required element of type genmesh:poseoffset */
	enum _genmesh__pose_target target;	/* required attribute */
	std::string index;	/* optional attribute */
	std::string name;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE__genmesh__pose */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__pose() : target((enum _genmesh__pose_target)0), index("0"), name(""), soap(NULL) { }
	virtual ~_genmesh__pose() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__poseoffset
#define SOAP_TYPE__genmesh__poseoffset (43)
/* genmesh:poseoffset */
class SOAP_CMAC _genmesh__poseoffset
{
public:
	std::string index;	/* required attribute */
	std::string x;	/* required attribute */
	std::string y;	/* required attribute */
	std::string z;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE__genmesh__poseoffset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__poseoffset() : soap(NULL) { }
	virtual ~_genmesh__poseoffset() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__animations
#define SOAP_TYPE__genmesh__animations (44)
/* genmesh:animations */
class SOAP_CMAC _genmesh__animations
{
public:
	std::vector<class _genmesh__animation * >genmesh__animation;	/* required element of type genmesh:animation */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE__genmesh__animations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__animations() : soap(NULL) { }
	virtual ~_genmesh__animations() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__animation
#define SOAP_TYPE__genmesh__animation (45)
/* genmesh:animation */
class SOAP_CMAC _genmesh__animation
{
public:
	class _genmesh__tracks *genmesh__tracks;	/* required element of type genmesh:tracks */
	std::string name;	/* required attribute */
	std::string length;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE__genmesh__animation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__animation() : genmesh__tracks(NULL), soap(NULL) { }
	virtual ~_genmesh__animation() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__tracks
#define SOAP_TYPE__genmesh__tracks (46)
/* genmesh:tracks */
class SOAP_CMAC _genmesh__tracks
{
public:
	std::vector<class _genmesh__track * >genmesh__track;	/* required element of type genmesh:track */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE__genmesh__tracks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__tracks() : soap(NULL) { }
	virtual ~_genmesh__tracks() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__track
#define SOAP_TYPE__genmesh__track (47)
/* genmesh:track */
class SOAP_CMAC _genmesh__track
{
public:
	class _genmesh__keyframes *genmesh__keyframes;	/* required element of type genmesh:keyframes */
	enum _genmesh__track_target target;	/* required attribute */
	std::string index;	/* optional attribute */
	enum _genmesh__track_type type;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE__genmesh__track */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__track() : genmesh__keyframes(NULL), target((enum _genmesh__track_target)0), index("0"), type((enum _genmesh__track_type)0), soap(NULL) { }
	virtual ~_genmesh__track() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__keyframes
#define SOAP_TYPE__genmesh__keyframes (48)
/* genmesh:keyframes */
class SOAP_CMAC _genmesh__keyframes
{
public:
	std::vector<class _genmesh__keyframe * >genmesh__keyframe;	/* optional element of type genmesh:keyframe */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE__genmesh__keyframes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__keyframes() : soap(NULL) { }
	virtual ~_genmesh__keyframes() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__keyframe
#define SOAP_TYPE__genmesh__keyframe (49)
/* genmesh:keyframe */
class SOAP_CMAC _genmesh__keyframe
{
public:
	std::vector<_genmesh__position * >genmesh__position;	/* optional element of type genmesh:position */
	std::vector<class _genmesh__poseref * >genmesh__poseref;	/* optional element of type genmesh:poseref */
	std::string time;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE__genmesh__keyframe */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__keyframe() : soap(NULL) { }
	virtual ~_genmesh__keyframe() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__poseref
#define SOAP_TYPE__genmesh__poseref (50)
/* genmesh:poseref */
class SOAP_CMAC _genmesh__poseref
{
public:
	std::string poseindex;	/* required attribute */
	std::string influence;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE__genmesh__poseref */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__poseref() : influence("1.0"), soap(NULL) { }
	virtual ~_genmesh__poseref() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__extremes
#define SOAP_TYPE__genmesh__extremes (51)
/* genmesh:extremes */
class SOAP_CMAC _genmesh__extremes
{
public:
	std::vector<_genmesh__submesh * >genmesh__submesh;	/* required element of type genmesh:submesh */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE__genmesh__extremes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__extremes() : soap(NULL) { }
	virtual ~_genmesh__extremes() { }
};
#endif

#ifndef SOAP_TYPE__genmesh__submesh_USCOREextremes
#define SOAP_TYPE__genmesh__submesh_USCOREextremes (52)
/* genmesh:submesh_extremes */
class SOAP_CMAC _genmesh__submesh_USCOREextremes
{
public:
	std::vector<_genmesh__position * >genmesh__position;	/* required element of type genmesh:position */
	std::string index;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE__genmesh__submesh_USCOREextremes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genmesh__submesh_USCOREextremes() : soap(NULL) { }
	virtual ~_genmesh__submesh_USCOREextremes() { }
};
#endif

#ifndef SOAP_TYPE_genskel__bones
#define SOAP_TYPE_genskel__bones (53)
/* genskel:bones */
class SOAP_CMAC genskel__bones
{
public:
	std::vector<class genskel__bone * >bone;	/* required element of type genskel:bone */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_genskel__bones */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         genskel__bones() : soap(NULL) { }
	virtual ~genskel__bones() { }
};
#endif

#ifndef SOAP_TYPE_genskel__bone
#define SOAP_TYPE_genskel__bone (54)
/* genskel:bone */
class SOAP_CMAC genskel__bone
{
public:
	class genskel__position *position;	/* required element of type genskel:position */
	class genskel__rotation *rotation;	/* required element of type genskel:rotation */
	class genskel__scale *scale;	/* optional element of type genskel:scale */
	std::string id;	/* required attribute */
	std::string name;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_genskel__bone */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         genskel__bone() : position(NULL), rotation(NULL), scale(NULL), soap(NULL) { }
	virtual ~genskel__bone() { }
};
#endif

#ifndef SOAP_TYPE_genskel__position
#define SOAP_TYPE_genskel__position (55)
/* genskel:position */
class SOAP_CMAC genskel__position
{
public:
	std::string x;	/* required attribute */
	std::string y;	/* required attribute */
	std::string z;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_genskel__position */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         genskel__position() : soap(NULL) { }
	virtual ~genskel__position() { }
};
#endif

#ifndef SOAP_TYPE_genskel__rotation
#define SOAP_TYPE_genskel__rotation (56)
/* genskel:rotation */
class SOAP_CMAC genskel__rotation
{
public:
	class genskel__axis *axis;	/* required element of type genskel:axis */
	std::string angle;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_genskel__rotation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         genskel__rotation() : axis(NULL), soap(NULL) { }
	virtual ~genskel__rotation() { }
};
#endif

#ifndef SOAP_TYPE_genskel__axis
#define SOAP_TYPE_genskel__axis (57)
/* genskel:axis */
class SOAP_CMAC genskel__axis
{
public:
	std::string x;	/* required attribute */
	std::string y;	/* required attribute */
	std::string z;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_genskel__axis */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         genskel__axis() : soap(NULL) { }
	virtual ~genskel__axis() { }
};
#endif

#ifndef SOAP_TYPE_genskel__scale
#define SOAP_TYPE_genskel__scale (58)
/* genskel:scale */
class SOAP_CMAC genskel__scale
{
public:
	std::string *factor;	/* optional attribute */
	std::string *x;	/* optional attribute */
	std::string *y;	/* optional attribute */
	std::string *z;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_genskel__scale */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         genskel__scale() : factor(NULL), x(NULL), y(NULL), z(NULL), soap(NULL) { }
	virtual ~genskel__scale() { }
};
#endif

#ifndef SOAP_TYPE__genskel__skeleton
#define SOAP_TYPE__genskel__skeleton (59)
/* genskel:skeleton */
class SOAP_CMAC _genskel__skeleton
{
public:
	genskel__bones *bones;	/* required element of type genskel:bones */
	class _genskel__bonehierarchy *genskel__bonehierarchy;	/* required element of type genskel:bonehierarchy */
	class _genskel__animations *genskel__animations;	/* optional element of type genskel:animations */
	class _genskel__animationlinks *genskel__animationlinks;	/* optional element of type genskel:animationlinks */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE__genskel__skeleton */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genskel__skeleton() : bones(NULL), genskel__bonehierarchy(NULL), genskel__animations(NULL), genskel__animationlinks(NULL), soap(NULL) { }
	virtual ~_genskel__skeleton() { }
};
#endif

#ifndef SOAP_TYPE__genskel__bonehierarchy
#define SOAP_TYPE__genskel__bonehierarchy (60)
/* genskel:bonehierarchy */
class SOAP_CMAC _genskel__bonehierarchy
{
public:
	std::vector<class _genskel__boneparent * >genskel__boneparent;	/* optional element of type genskel:boneparent */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE__genskel__bonehierarchy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genskel__bonehierarchy() : soap(NULL) { }
	virtual ~_genskel__bonehierarchy() { }
};
#endif

#ifndef SOAP_TYPE__genskel__boneparent
#define SOAP_TYPE__genskel__boneparent (61)
/* genskel:boneparent */
class SOAP_CMAC _genskel__boneparent
{
public:
	std::string bone;	/* required attribute */
	std::string parent;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE__genskel__boneparent */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genskel__boneparent() : soap(NULL) { }
	virtual ~_genskel__boneparent() { }
};
#endif

#ifndef SOAP_TYPE__genskel__animations
#define SOAP_TYPE__genskel__animations (62)
/* genskel:animations */
class SOAP_CMAC _genskel__animations
{
public:
	std::vector<class _genskel__animation * >genskel__animation;	/* required element of type genskel:animation */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE__genskel__animations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genskel__animations() : soap(NULL) { }
	virtual ~_genskel__animations() { }
};
#endif

#ifndef SOAP_TYPE__genskel__animation
#define SOAP_TYPE__genskel__animation (63)
/* genskel:animation */
class SOAP_CMAC _genskel__animation
{
public:
	class _genskel__tracks *genskel__tracks;	/* required element of type genskel:tracks */
	std::string name;	/* required attribute */
	std::string length;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE__genskel__animation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genskel__animation() : genskel__tracks(NULL), soap(NULL) { }
	virtual ~_genskel__animation() { }
};
#endif

#ifndef SOAP_TYPE__genskel__tracks
#define SOAP_TYPE__genskel__tracks (64)
/* genskel:tracks */
class SOAP_CMAC _genskel__tracks
{
public:
	std::vector<class _genskel__track * >genskel__track;	/* required element of type genskel:track */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE__genskel__tracks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genskel__tracks() : soap(NULL) { }
	virtual ~_genskel__tracks() { }
};
#endif

#ifndef SOAP_TYPE__genskel__track
#define SOAP_TYPE__genskel__track (65)
/* genskel:track */
class SOAP_CMAC _genskel__track
{
public:
	class _genskel__keyframes *genskel__keyframes;	/* required element of type genskel:keyframes */
	std::string bone;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE__genskel__track */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genskel__track() : genskel__keyframes(NULL), soap(NULL) { }
	virtual ~_genskel__track() { }
};
#endif

#ifndef SOAP_TYPE__genskel__keyframes
#define SOAP_TYPE__genskel__keyframes (66)
/* genskel:keyframes */
class SOAP_CMAC _genskel__keyframes
{
public:
	std::vector<class _genskel__keyframe * >genskel__keyframe;	/* required element of type genskel:keyframe */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE__genskel__keyframes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genskel__keyframes() : soap(NULL) { }
	virtual ~_genskel__keyframes() { }
};
#endif

#ifndef SOAP_TYPE__genskel__keyframe
#define SOAP_TYPE__genskel__keyframe (67)
/* genskel:keyframe */
class SOAP_CMAC _genskel__keyframe
{
public:
	class _genskel__translate *genskel__translate;	/* optional element of type genskel:translate */
	class _genskel__rotate *genskel__rotate;	/* optional element of type genskel:rotate */
	genskel__scale *scale;	/* optional element of type genskel:scale */
	std::string time;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE__genskel__keyframe */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genskel__keyframe() : genskel__translate(NULL), genskel__rotate(NULL), scale(NULL), soap(NULL) { }
	virtual ~_genskel__keyframe() { }
};
#endif

#ifndef SOAP_TYPE__genskel__translate
#define SOAP_TYPE__genskel__translate (68)
/* genskel:translate */
class SOAP_CMAC _genskel__translate
{
public:
	std::string x;	/* required attribute */
	std::string y;	/* required attribute */
	std::string z;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE__genskel__translate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genskel__translate() : soap(NULL) { }
	virtual ~_genskel__translate() { }
};
#endif

#ifndef SOAP_TYPE__genskel__rotate
#define SOAP_TYPE__genskel__rotate (69)
/* genskel:rotate */
class SOAP_CMAC _genskel__rotate
{
public:
	genskel__axis *axis;	/* required element of type genskel:axis */
	std::string angle;	/* required attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE__genskel__rotate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genskel__rotate() : axis(NULL), soap(NULL) { }
	virtual ~_genskel__rotate() { }
};
#endif

#ifndef SOAP_TYPE__genskel__animationlinks
#define SOAP_TYPE__genskel__animationlinks (70)
/* genskel:animationlinks */
class SOAP_CMAC _genskel__animationlinks
{
public:
	std::vector<class _genskel__animationlink * >genskel__animationlink;	/* required element of type genskel:animationlink */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE__genskel__animationlinks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genskel__animationlinks() : soap(NULL) { }
	virtual ~_genskel__animationlinks() { }
};
#endif

#ifndef SOAP_TYPE__genskel__animationlink
#define SOAP_TYPE__genskel__animationlink (71)
/* genskel:animationlink */
class SOAP_CMAC _genskel__animationlink
{
public:
	std::string skeletonName;	/* required attribute */
	std::string scale;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE__genskel__animationlink */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _genskel__animationlink() : scale("1.0"), soap(NULL) { }
	virtual ~_genskel__animationlink() { }
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (187)
/* SOAP Header: */
struct SOAP_ENV__Header
{
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (188)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (190)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (193)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (194)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (4)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Typedef Synonyms                                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Stubs                                                                      *
 *                                                                            *
\******************************************************************************/


#endif

/* End of generatedStub.h */
