/* generatedC.cpp
   Generated by gSOAP 2.7.9l from generated_h.h
   Copyright(C) 2000-2007, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "generatedH.h"

SOAP_SOURCE_STAMP("@(#) generatedC.cpp ver 2.7.9l 2012-02-09 20:18:26 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (!soap->header)
	{	soap->header = soap_new_SOAP_ENV__Header(soap, -1);
		soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE__genmesh__track_type:
		return soap_in__genmesh__track_type(soap, NULL, NULL, "genmesh:track-type");
	case SOAP_TYPE__genmesh__track_target:
		return soap_in__genmesh__track_target(soap, NULL, NULL, "genmesh:track-target");
	case SOAP_TYPE__genmesh__pose_target:
		return soap_in__genmesh__pose_target(soap, NULL, NULL, "genmesh:pose-target");
	case SOAP_TYPE__genmesh__vertexbuffer_binormals:
		return soap_in__genmesh__vertexbuffer_binormals(soap, NULL, NULL, "genmesh:vertexbuffer-binormals");
	case SOAP_TYPE__genmesh__vertexbuffer_tangent_USCOREdimensions:
		return soap_in__genmesh__vertexbuffer_tangent_USCOREdimensions(soap, NULL, NULL, "genmesh:vertexbuffer-tangent_dimensions");
	case SOAP_TYPE__genmesh__vertexbuffer_tangents:
		return soap_in__genmesh__vertexbuffer_tangents(soap, NULL, NULL, "genmesh:vertexbuffer-tangents");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7:
		return soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7(soap, NULL, NULL, "genmesh:vertexbuffer-texture_coord_dimensions_7");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6:
		return soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6(soap, NULL, NULL, "genmesh:vertexbuffer-texture_coord_dimensions_6");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5:
		return soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5(soap, NULL, NULL, "genmesh:vertexbuffer-texture_coord_dimensions_5");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4:
		return soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4(soap, NULL, NULL, "genmesh:vertexbuffer-texture_coord_dimensions_4");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3:
		return soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3(soap, NULL, NULL, "genmesh:vertexbuffer-texture_coord_dimensions_3");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2:
		return soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2(soap, NULL, NULL, "genmesh:vertexbuffer-texture_coord_dimensions_2");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1:
		return soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1(soap, NULL, NULL, "genmesh:vertexbuffer-texture_coord_dimensions_1");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0:
		return soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0(soap, NULL, NULL, "genmesh:vertexbuffer-texture_coord_dimensions_0");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoords:
		return soap_in__genmesh__vertexbuffer_texture_USCOREcoords(soap, NULL, NULL, "genmesh:vertexbuffer-texture_coords");
	case SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREspecular:
		return soap_in__genmesh__vertexbuffer_colours_USCOREspecular(soap, NULL, NULL, "genmesh:vertexbuffer-colours_specular");
	case SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREdiffuse:
		return soap_in__genmesh__vertexbuffer_colours_USCOREdiffuse(soap, NULL, NULL, "genmesh:vertexbuffer-colours_diffuse");
	case SOAP_TYPE__genmesh__vertexbuffer_normals:
		return soap_in__genmesh__vertexbuffer_normals(soap, NULL, NULL, "genmesh:vertexbuffer-normals");
	case SOAP_TYPE__genmesh__vertexbuffer_positions:
		return soap_in__genmesh__vertexbuffer_positions(soap, NULL, NULL, "genmesh:vertexbuffer-positions");
	case SOAP_TYPE__genmesh__levelofdetail_manual:
		return soap_in__genmesh__levelofdetail_manual(soap, NULL, NULL, "genmesh:levelofdetail-manual");
	case SOAP_TYPE__genmesh__submesh_operationtype:
		return soap_in__genmesh__submesh_operationtype(soap, NULL, NULL, "genmesh:submesh-operationtype");
	case SOAP_TYPE__genmesh__submesh_use32bitindexes:
		return soap_in__genmesh__submesh_use32bitindexes(soap, NULL, NULL, "genmesh:submesh-use32bitindexes");
	case SOAP_TYPE__genmesh__submesh_usesharedvertices:
		return soap_in__genmesh__submesh_usesharedvertices(soap, NULL, NULL, "genmesh:submesh-usesharedvertices");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_genskel__scale:
		return soap_in_genskel__scale(soap, NULL, NULL, "genskel:scale");
	case SOAP_TYPE_genskel__axis:
		return soap_in_genskel__axis(soap, NULL, NULL, "genskel:axis");
	case SOAP_TYPE_genskel__rotation:
		return soap_in_genskel__rotation(soap, NULL, NULL, "genskel:rotation");
	case SOAP_TYPE_genskel__position:
		return soap_in_genskel__position(soap, NULL, NULL, "genskel:position");
	case SOAP_TYPE_genskel__bone:
		return soap_in_genskel__bone(soap, NULL, NULL, "genskel:bone");
	case SOAP_TYPE_genskel__bones:
		return soap_in_genskel__bones(soap, NULL, NULL, "genskel:bones");
	case SOAP_TYPE_genmech__mesh:
		return soap_in_genmech__mesh(soap, NULL, NULL, "genmech:mesh");
	case SOAP_TYPE_genmech__torso:
		return soap_in_genmech__torso(soap, NULL, NULL, "genmech:torso");
	case SOAP_TYPE_genmech__equSlot:
		return soap_in_genmech__equSlot(soap, NULL, NULL, "genmech:equSlot");
	case SOAP_TYPE_genmech__equSlots:
		return soap_in_genmech__equSlots(soap, NULL, NULL, "genmech:equSlots");
	case SOAP_TYPE_genmech__design:
		return soap_in_genmech__design(soap, NULL, NULL, "genmech:design");
	case SOAP_TYPE_genmech__stats:
		return soap_in_genmech__stats(soap, NULL, NULL, "genmech:stats");
	case SOAP_TYPE_PointerTo_genskel__animationlink:
		return soap_in_PointerTo_genskel__animationlink(soap, NULL, NULL, "genskel:animationlink");
	case SOAP_TYPE_PointerTo_genskel__rotate:
		return soap_in_PointerTo_genskel__rotate(soap, NULL, NULL, "genskel:rotate");
	case SOAP_TYPE_PointerTo_genskel__translate:
		return soap_in_PointerTo_genskel__translate(soap, NULL, NULL, "genskel:translate");
	case SOAP_TYPE_PointerTo_genskel__keyframe:
		return soap_in_PointerTo_genskel__keyframe(soap, NULL, NULL, "genskel:keyframe");
	case SOAP_TYPE_PointerTo_genskel__keyframes:
		return soap_in_PointerTo_genskel__keyframes(soap, NULL, NULL, "genskel:keyframes");
	case SOAP_TYPE_PointerTo_genskel__track:
		return soap_in_PointerTo_genskel__track(soap, NULL, NULL, "genskel:track");
	case SOAP_TYPE_PointerTo_genskel__tracks:
		return soap_in_PointerTo_genskel__tracks(soap, NULL, NULL, "genskel:tracks");
	case SOAP_TYPE_PointerTo_genskel__animation:
		return soap_in_PointerTo_genskel__animation(soap, NULL, NULL, "genskel:animation");
	case SOAP_TYPE_PointerTo_genskel__boneparent:
		return soap_in_PointerTo_genskel__boneparent(soap, NULL, NULL, "genskel:boneparent");
	case SOAP_TYPE_PointerTo_genskel__animationlinks:
		return soap_in_PointerTo_genskel__animationlinks(soap, NULL, NULL, "genskel:animationlinks");
	case SOAP_TYPE_PointerTo_genskel__animations:
		return soap_in_PointerTo_genskel__animations(soap, NULL, NULL, "genskel:animations");
	case SOAP_TYPE_PointerTo_genskel__bonehierarchy:
		return soap_in_PointerTo_genskel__bonehierarchy(soap, NULL, NULL, "genskel:bonehierarchy");
	case SOAP_TYPE_PointerTogenskel__bones:
		return soap_in_PointerTogenskel__bones(soap, NULL, NULL, "genskel:bones");
	case SOAP_TYPE_PointerTogenskel__axis:
		return soap_in_PointerTogenskel__axis(soap, NULL, NULL, "genskel:axis");
	case SOAP_TYPE_PointerTogenskel__scale:
		return soap_in_PointerTogenskel__scale(soap, NULL, NULL, "genskel:scale");
	case SOAP_TYPE_PointerTogenskel__rotation:
		return soap_in_PointerTogenskel__rotation(soap, NULL, NULL, "genskel:rotation");
	case SOAP_TYPE_PointerTogenskel__position:
		return soap_in_PointerTogenskel__position(soap, NULL, NULL, "genskel:position");
	case SOAP_TYPE_PointerTogenskel__bone:
		return soap_in_PointerTogenskel__bone(soap, NULL, NULL, "genskel:bone");
	case SOAP_TYPE_PointerTo_genmesh__poseref:
		return soap_in_PointerTo_genmesh__poseref(soap, NULL, NULL, "genmesh:poseref");
	case SOAP_TYPE_PointerTo_genmesh__keyframe:
		return soap_in_PointerTo_genmesh__keyframe(soap, NULL, NULL, "genmesh:keyframe");
	case SOAP_TYPE_PointerTo_genmesh__keyframes:
		return soap_in_PointerTo_genmesh__keyframes(soap, NULL, NULL, "genmesh:keyframes");
	case SOAP_TYPE_PointerTo_genmesh__track:
		return soap_in_PointerTo_genmesh__track(soap, NULL, NULL, "genmesh:track");
	case SOAP_TYPE_PointerTo_genmesh__tracks:
		return soap_in_PointerTo_genmesh__tracks(soap, NULL, NULL, "genmesh:tracks");
	case SOAP_TYPE_PointerTo_genmesh__animation:
		return soap_in_PointerTo_genmesh__animation(soap, NULL, NULL, "genmesh:animation");
	case SOAP_TYPE_PointerTo_genmesh__poseoffset:
		return soap_in_PointerTo_genmesh__poseoffset(soap, NULL, NULL, "genmesh:poseoffset");
	case SOAP_TYPE_PointerTo_genmesh__pose:
		return soap_in_PointerTo_genmesh__pose(soap, NULL, NULL, "genmesh:pose");
	case SOAP_TYPE_PointerTo_genmesh__submeshname:
		return soap_in_PointerTo_genmesh__submeshname(soap, NULL, NULL, "genmesh:submeshname");
	case SOAP_TYPE_PointerTo_genmesh__texcoord:
		return soap_in_PointerTo_genmesh__texcoord(soap, NULL, NULL, "genmesh:texcoord");
	case SOAP_TYPE_PointerTo_genmesh__colour_USCOREspecular:
		return soap_in_PointerTo_genmesh__colour_USCOREspecular(soap, NULL, NULL, "genmesh:colour_specular");
	case SOAP_TYPE_PointerTo_genmesh__colour_USCOREdiffuse:
		return soap_in_PointerTo_genmesh__colour_USCOREdiffuse(soap, NULL, NULL, "genmesh:colour_diffuse");
	case SOAP_TYPE_PointerTo_genmesh__binormal:
		return soap_in_PointerTo_genmesh__binormal(soap, NULL, NULL, "genmesh:binormal");
	case SOAP_TYPE_PointerTo_genmesh__tangent:
		return soap_in_PointerTo_genmesh__tangent(soap, NULL, NULL, "genmesh:tangent");
	case SOAP_TYPE_PointerTo_genmesh__normal:
		return soap_in_PointerTo_genmesh__normal(soap, NULL, NULL, "genmesh:normal");
	case SOAP_TYPE_PointerTo_genmesh__position:
		return soap_in_PointerTo_genmesh__position(soap, NULL, NULL, "genmesh:position");
	case SOAP_TYPE_PointerTo_genmesh__vertex:
		return soap_in_PointerTo_genmesh__vertex(soap, NULL, NULL, "genmesh:vertex");
	case SOAP_TYPE_PointerTo_genmesh__lodfacelist:
		return soap_in_PointerTo_genmesh__lodfacelist(soap, NULL, NULL, "genmesh:lodfacelist");
	case SOAP_TYPE_PointerTo_genmesh__lodgenerated:
		return soap_in_PointerTo_genmesh__lodgenerated(soap, NULL, NULL, "genmesh:lodgenerated");
	case SOAP_TYPE_PointerTo_genmesh__lodmanual:
		return soap_in_PointerTo_genmesh__lodmanual(soap, NULL, NULL, "genmesh:lodmanual");
	case SOAP_TYPE_PointerTo_genmesh__vertexboneassignment:
		return soap_in_PointerTo_genmesh__vertexboneassignment(soap, NULL, NULL, "genmesh:vertexboneassignment");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_PointerTo_genmesh__face:
		return soap_in_PointerTo_genmesh__face(soap, NULL, NULL, "genmesh:face");
	case SOAP_TYPE_PointerTo_genmesh__texture:
		return soap_in_PointerTo_genmesh__texture(soap, NULL, NULL, "genmesh:texture");
	case SOAP_TYPE_PointerTo_genmesh__geometry:
		return soap_in_PointerTo_genmesh__geometry(soap, NULL, NULL, "genmesh:geometry");
	case SOAP_TYPE_PointerTo_genmesh__faces:
		return soap_in_PointerTo_genmesh__faces(soap, NULL, NULL, "genmesh:faces");
	case SOAP_TYPE_PointerTo_genmesh__textures:
		return soap_in_PointerTo_genmesh__textures(soap, NULL, NULL, "genmesh:textures");
	case SOAP_TYPE_PointerTo_genmesh__submesh:
		return soap_in_PointerTo_genmesh__submesh(soap, NULL, NULL, "genmesh:submesh");
	case SOAP_TYPE_PointerTo_genmesh__vertexbuffer:
		return soap_in_PointerTo_genmesh__vertexbuffer(soap, NULL, NULL, "genmesh:vertexbuffer");
	case SOAP_TYPE_PointerTo_genmesh__extremes:
		return soap_in_PointerTo_genmesh__extremes(soap, NULL, NULL, "genmesh:extremes");
	case SOAP_TYPE_PointerTo_genmesh__animations:
		return soap_in_PointerTo_genmesh__animations(soap, NULL, NULL, "genmesh:animations");
	case SOAP_TYPE_PointerTo_genmesh__poses:
		return soap_in_PointerTo_genmesh__poses(soap, NULL, NULL, "genmesh:poses");
	case SOAP_TYPE_PointerTo_genmesh__submeshnames:
		return soap_in_PointerTo_genmesh__submeshnames(soap, NULL, NULL, "genmesh:submeshnames");
	case SOAP_TYPE_PointerTo_genmesh__levelofdetail:
		return soap_in_PointerTo_genmesh__levelofdetail(soap, NULL, NULL, "genmesh:levelofdetail");
	case SOAP_TYPE_PointerTo_genmesh__boneassignments:
		return soap_in_PointerTo_genmesh__boneassignments(soap, NULL, NULL, "genmesh:boneassignments");
	case SOAP_TYPE_PointerTo_genmesh__skeletonlink:
		return soap_in_PointerTo_genmesh__skeletonlink(soap, NULL, NULL, "genmesh:skeletonlink");
	case SOAP_TYPE_PointerTo_genmesh__submeshes:
		return soap_in_PointerTo_genmesh__submeshes(soap, NULL, NULL, "genmesh:submeshes");
	case SOAP_TYPE_PointerTo_genmesh__sharedgeometry:
		return soap_in_PointerTo_genmesh__sharedgeometry(soap, NULL, NULL, "genmesh:sharedgeometry");
	case SOAP_TYPE_PointerTogenmech__mesh:
		return soap_in_PointerTogenmech__mesh(soap, NULL, NULL, "genmech:mesh");
	case SOAP_TYPE_PointerTogenmech__design:
		return soap_in_PointerTogenmech__design(soap, NULL, NULL, "genmech:design");
	case SOAP_TYPE_PointerTogenmech__stats:
		return soap_in_PointerTogenmech__stats(soap, NULL, NULL, "genmech:stats");
	case SOAP_TYPE_PointerTogenmech__equSlot:
		return soap_in_PointerTogenmech__equSlot(soap, NULL, NULL, "genmech:equSlot");
	case SOAP_TYPE_PointerTogenmech__equSlots:
		return soap_in_PointerTogenmech__equSlots(soap, NULL, NULL, "genmech:equSlots");
	case SOAP_TYPE_PointerTogenmech__torso:
		return soap_in_PointerTogenmech__torso(soap, NULL, NULL, "genmech:torso");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:scale"))
		{	*type = SOAP_TYPE_genskel__scale;
			return soap_in_genskel__scale(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:axis"))
		{	*type = SOAP_TYPE_genskel__axis;
			return soap_in_genskel__axis(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:rotation"))
		{	*type = SOAP_TYPE_genskel__rotation;
			return soap_in_genskel__rotation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:position"))
		{	*type = SOAP_TYPE_genskel__position;
			return soap_in_genskel__position(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:bone"))
		{	*type = SOAP_TYPE_genskel__bone;
			return soap_in_genskel__bone(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:bones"))
		{	*type = SOAP_TYPE_genskel__bones;
			return soap_in_genskel__bones(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmech:mesh"))
		{	*type = SOAP_TYPE_genmech__mesh;
			return soap_in_genmech__mesh(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmech:torso"))
		{	*type = SOAP_TYPE_genmech__torso;
			return soap_in_genmech__torso(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmech:equSlot"))
		{	*type = SOAP_TYPE_genmech__equSlot;
			return soap_in_genmech__equSlot(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmech:equSlots"))
		{	*type = SOAP_TYPE_genmech__equSlots;
			return soap_in_genmech__equSlots(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmech:design"))
		{	*type = SOAP_TYPE_genmech__design;
			return soap_in_genmech__design(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmech:stats"))
		{	*type = SOAP_TYPE_genmech__stats;
			return soap_in_genmech__stats(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:track-type"))
		{	*type = SOAP_TYPE__genmesh__track_type;
			return soap_in__genmesh__track_type(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:track-target"))
		{	*type = SOAP_TYPE__genmesh__track_target;
			return soap_in__genmesh__track_target(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:pose-target"))
		{	*type = SOAP_TYPE__genmesh__pose_target;
			return soap_in__genmesh__pose_target(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer-binormals"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer_binormals;
			return soap_in__genmesh__vertexbuffer_binormals(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer-tangent_dimensions"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer_tangent_USCOREdimensions;
			return soap_in__genmesh__vertexbuffer_tangent_USCOREdimensions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer-tangents"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer_tangents;
			return soap_in__genmesh__vertexbuffer_tangents(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer-texture_coord_dimensions_7"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7;
			return soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer-texture_coord_dimensions_6"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6;
			return soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer-texture_coord_dimensions_5"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5;
			return soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer-texture_coord_dimensions_4"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4;
			return soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer-texture_coord_dimensions_3"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3;
			return soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer-texture_coord_dimensions_2"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2;
			return soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer-texture_coord_dimensions_1"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1;
			return soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer-texture_coord_dimensions_0"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0;
			return soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer-texture_coords"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoords;
			return soap_in__genmesh__vertexbuffer_texture_USCOREcoords(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer-colours_specular"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREspecular;
			return soap_in__genmesh__vertexbuffer_colours_USCOREspecular(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer-colours_diffuse"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREdiffuse;
			return soap_in__genmesh__vertexbuffer_colours_USCOREdiffuse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer-normals"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer_normals;
			return soap_in__genmesh__vertexbuffer_normals(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer-positions"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer_positions;
			return soap_in__genmesh__vertexbuffer_positions(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:levelofdetail-manual"))
		{	*type = SOAP_TYPE__genmesh__levelofdetail_manual;
			return soap_in__genmesh__levelofdetail_manual(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:submesh-operationtype"))
		{	*type = SOAP_TYPE__genmesh__submesh_operationtype;
			return soap_in__genmesh__submesh_operationtype(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:submesh-use32bitindexes"))
		{	*type = SOAP_TYPE__genmesh__submesh_use32bitindexes;
			return soap_in__genmesh__submesh_use32bitindexes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:submesh-usesharedvertices"))
		{	*type = SOAP_TYPE__genmesh__submesh_usesharedvertices;
			return soap_in__genmesh__submesh_usesharedvertices(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "genskel:animationlink"))
		{	*type = SOAP_TYPE__genskel__animationlink;
			return soap_in__genskel__animationlink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:animationlinks"))
		{	*type = SOAP_TYPE__genskel__animationlinks;
			return soap_in__genskel__animationlinks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:rotate"))
		{	*type = SOAP_TYPE__genskel__rotate;
			return soap_in__genskel__rotate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:translate"))
		{	*type = SOAP_TYPE__genskel__translate;
			return soap_in__genskel__translate(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:keyframe"))
		{	*type = SOAP_TYPE__genskel__keyframe;
			return soap_in__genskel__keyframe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:keyframes"))
		{	*type = SOAP_TYPE__genskel__keyframes;
			return soap_in__genskel__keyframes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:track"))
		{	*type = SOAP_TYPE__genskel__track;
			return soap_in__genskel__track(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:tracks"))
		{	*type = SOAP_TYPE__genskel__tracks;
			return soap_in__genskel__tracks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:animation"))
		{	*type = SOAP_TYPE__genskel__animation;
			return soap_in__genskel__animation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:animations"))
		{	*type = SOAP_TYPE__genskel__animations;
			return soap_in__genskel__animations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:boneparent"))
		{	*type = SOAP_TYPE__genskel__boneparent;
			return soap_in__genskel__boneparent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:bonehierarchy"))
		{	*type = SOAP_TYPE__genskel__bonehierarchy;
			return soap_in__genskel__bonehierarchy(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genskel:skeleton"))
		{	*type = SOAP_TYPE__genskel__skeleton;
			return soap_in__genskel__skeleton(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:submesh_extremes"))
		{	*type = SOAP_TYPE__genmesh__submesh_USCOREextremes;
			return soap_in__genmesh__submesh_USCOREextremes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:extremes"))
		{	*type = SOAP_TYPE__genmesh__extremes;
			return soap_in__genmesh__extremes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:poseref"))
		{	*type = SOAP_TYPE__genmesh__poseref;
			return soap_in__genmesh__poseref(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:keyframe"))
		{	*type = SOAP_TYPE__genmesh__keyframe;
			return soap_in__genmesh__keyframe(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:keyframes"))
		{	*type = SOAP_TYPE__genmesh__keyframes;
			return soap_in__genmesh__keyframes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:track"))
		{	*type = SOAP_TYPE__genmesh__track;
			return soap_in__genmesh__track(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:tracks"))
		{	*type = SOAP_TYPE__genmesh__tracks;
			return soap_in__genmesh__tracks(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:animation"))
		{	*type = SOAP_TYPE__genmesh__animation;
			return soap_in__genmesh__animation(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:animations"))
		{	*type = SOAP_TYPE__genmesh__animations;
			return soap_in__genmesh__animations(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:poseoffset"))
		{	*type = SOAP_TYPE__genmesh__poseoffset;
			return soap_in__genmesh__poseoffset(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:pose"))
		{	*type = SOAP_TYPE__genmesh__pose;
			return soap_in__genmesh__pose(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:poses"))
		{	*type = SOAP_TYPE__genmesh__poses;
			return soap_in__genmesh__poses(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:submeshname"))
		{	*type = SOAP_TYPE__genmesh__submeshname;
			return soap_in__genmesh__submeshname(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:submeshnames"))
		{	*type = SOAP_TYPE__genmesh__submeshnames;
			return soap_in__genmesh__submeshnames(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:texcoord"))
		{	*type = SOAP_TYPE__genmesh__texcoord;
			return soap_in__genmesh__texcoord(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:colour_specular"))
		{	*type = SOAP_TYPE__genmesh__colour_USCOREspecular;
			return soap_in__genmesh__colour_USCOREspecular(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:colour_diffuse"))
		{	*type = SOAP_TYPE__genmesh__colour_USCOREdiffuse;
			return soap_in__genmesh__colour_USCOREdiffuse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:binormal"))
		{	*type = SOAP_TYPE__genmesh__binormal;
			return soap_in__genmesh__binormal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:tangent"))
		{	*type = SOAP_TYPE__genmesh__tangent;
			return soap_in__genmesh__tangent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:normal"))
		{	*type = SOAP_TYPE__genmesh__normal;
			return soap_in__genmesh__normal(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:position"))
		{	*type = SOAP_TYPE__genmesh__position;
			return soap_in__genmesh__position(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertex"))
		{	*type = SOAP_TYPE__genmesh__vertex;
			return soap_in__genmesh__vertex(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexbuffer"))
		{	*type = SOAP_TYPE__genmesh__vertexbuffer;
			return soap_in__genmesh__vertexbuffer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:lodfacelist"))
		{	*type = SOAP_TYPE__genmesh__lodfacelist;
			return soap_in__genmesh__lodfacelist(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:lodgenerated"))
		{	*type = SOAP_TYPE__genmesh__lodgenerated;
			return soap_in__genmesh__lodgenerated(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:lodmanual"))
		{	*type = SOAP_TYPE__genmesh__lodmanual;
			return soap_in__genmesh__lodmanual(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:levelofdetail"))
		{	*type = SOAP_TYPE__genmesh__levelofdetail;
			return soap_in__genmesh__levelofdetail(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:vertexboneassignment"))
		{	*type = SOAP_TYPE__genmesh__vertexboneassignment;
			return soap_in__genmesh__vertexboneassignment(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:boneassignments"))
		{	*type = SOAP_TYPE__genmesh__boneassignments;
			return soap_in__genmesh__boneassignments(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:skeletonlink"))
		{	*type = SOAP_TYPE__genmesh__skeletonlink;
			return soap_in__genmesh__skeletonlink(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:geometry"))
		{	*type = SOAP_TYPE__genmesh__geometry;
			return soap_in__genmesh__geometry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:face"))
		{	*type = SOAP_TYPE__genmesh__face;
			return soap_in__genmesh__face(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:faces"))
		{	*type = SOAP_TYPE__genmesh__faces;
			return soap_in__genmesh__faces(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:texture"))
		{	*type = SOAP_TYPE__genmesh__texture;
			return soap_in__genmesh__texture(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:textures"))
		{	*type = SOAP_TYPE__genmesh__textures;
			return soap_in__genmesh__textures(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:submesh"))
		{	*type = SOAP_TYPE__genmesh__submesh;
			return soap_in__genmesh__submesh(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:submeshes"))
		{	*type = SOAP_TYPE__genmesh__submeshes;
			return soap_in__genmesh__submeshes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:sharedgeometry"))
		{	*type = SOAP_TYPE__genmesh__sharedgeometry;
			return soap_in__genmesh__sharedgeometry(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmesh:mesh"))
		{	*type = SOAP_TYPE__genmesh__mesh;
			return soap_in__genmesh__mesh(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "genmech:mech"))
		{	*type = SOAP_TYPE__genmech__mech;
			return soap_in__genmech__mech(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE__genmesh__track_type:
		return soap_out__genmesh__track_type(soap, tag, id, (const enum _genmesh__track_type *)ptr, "genmesh:track-type");
	case SOAP_TYPE__genmesh__track_target:
		return soap_out__genmesh__track_target(soap, tag, id, (const enum _genmesh__track_target *)ptr, "genmesh:track-target");
	case SOAP_TYPE__genmesh__pose_target:
		return soap_out__genmesh__pose_target(soap, tag, id, (const enum _genmesh__pose_target *)ptr, "genmesh:pose-target");
	case SOAP_TYPE__genmesh__vertexbuffer_binormals:
		return soap_out__genmesh__vertexbuffer_binormals(soap, tag, id, (const enum _genmesh__vertexbuffer_binormals *)ptr, "genmesh:vertexbuffer-binormals");
	case SOAP_TYPE__genmesh__vertexbuffer_tangent_USCOREdimensions:
		return soap_out__genmesh__vertexbuffer_tangent_USCOREdimensions(soap, tag, id, (const enum _genmesh__vertexbuffer_tangent_USCOREdimensions *)ptr, "genmesh:vertexbuffer-tangent_dimensions");
	case SOAP_TYPE__genmesh__vertexbuffer_tangents:
		return soap_out__genmesh__vertexbuffer_tangents(soap, tag, id, (const enum _genmesh__vertexbuffer_tangents *)ptr, "genmesh:vertexbuffer-tangents");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7:
		return soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7(soap, tag, id, (const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7 *)ptr, "genmesh:vertexbuffer-texture_coord_dimensions_7");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6:
		return soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6(soap, tag, id, (const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6 *)ptr, "genmesh:vertexbuffer-texture_coord_dimensions_6");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5:
		return soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5(soap, tag, id, (const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5 *)ptr, "genmesh:vertexbuffer-texture_coord_dimensions_5");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4:
		return soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4(soap, tag, id, (const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4 *)ptr, "genmesh:vertexbuffer-texture_coord_dimensions_4");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3:
		return soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3(soap, tag, id, (const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3 *)ptr, "genmesh:vertexbuffer-texture_coord_dimensions_3");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2:
		return soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2(soap, tag, id, (const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2 *)ptr, "genmesh:vertexbuffer-texture_coord_dimensions_2");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1:
		return soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1(soap, tag, id, (const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1 *)ptr, "genmesh:vertexbuffer-texture_coord_dimensions_1");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0:
		return soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0(soap, tag, id, (const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0 *)ptr, "genmesh:vertexbuffer-texture_coord_dimensions_0");
	case SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoords:
		return soap_out__genmesh__vertexbuffer_texture_USCOREcoords(soap, tag, id, (const enum _genmesh__vertexbuffer_texture_USCOREcoords *)ptr, "genmesh:vertexbuffer-texture_coords");
	case SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREspecular:
		return soap_out__genmesh__vertexbuffer_colours_USCOREspecular(soap, tag, id, (const enum _genmesh__vertexbuffer_colours_USCOREspecular *)ptr, "genmesh:vertexbuffer-colours_specular");
	case SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREdiffuse:
		return soap_out__genmesh__vertexbuffer_colours_USCOREdiffuse(soap, tag, id, (const enum _genmesh__vertexbuffer_colours_USCOREdiffuse *)ptr, "genmesh:vertexbuffer-colours_diffuse");
	case SOAP_TYPE__genmesh__vertexbuffer_normals:
		return soap_out__genmesh__vertexbuffer_normals(soap, tag, id, (const enum _genmesh__vertexbuffer_normals *)ptr, "genmesh:vertexbuffer-normals");
	case SOAP_TYPE__genmesh__vertexbuffer_positions:
		return soap_out__genmesh__vertexbuffer_positions(soap, tag, id, (const enum _genmesh__vertexbuffer_positions *)ptr, "genmesh:vertexbuffer-positions");
	case SOAP_TYPE__genmesh__levelofdetail_manual:
		return soap_out__genmesh__levelofdetail_manual(soap, tag, id, (const enum _genmesh__levelofdetail_manual *)ptr, "genmesh:levelofdetail-manual");
	case SOAP_TYPE__genmesh__submesh_operationtype:
		return soap_out__genmesh__submesh_operationtype(soap, tag, id, (const enum _genmesh__submesh_operationtype *)ptr, "genmesh:submesh-operationtype");
	case SOAP_TYPE__genmesh__submesh_use32bitindexes:
		return soap_out__genmesh__submesh_use32bitindexes(soap, tag, id, (const enum _genmesh__submesh_use32bitindexes *)ptr, "genmesh:submesh-use32bitindexes");
	case SOAP_TYPE__genmesh__submesh_usesharedvertices:
		return soap_out__genmesh__submesh_usesharedvertices(soap, tag, id, (const enum _genmesh__submesh_usesharedvertices *)ptr, "genmesh:submesh-usesharedvertices");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE__genskel__animationlink:
		return ((_genskel__animationlink *)ptr)->soap_out(soap, "genskel:animationlink", id, NULL);
	case SOAP_TYPE__genskel__animationlinks:
		return ((_genskel__animationlinks *)ptr)->soap_out(soap, "genskel:animationlinks", id, NULL);
	case SOAP_TYPE__genskel__rotate:
		return ((_genskel__rotate *)ptr)->soap_out(soap, "genskel:rotate", id, NULL);
	case SOAP_TYPE__genskel__translate:
		return ((_genskel__translate *)ptr)->soap_out(soap, "genskel:translate", id, NULL);
	case SOAP_TYPE__genskel__keyframe:
		return ((_genskel__keyframe *)ptr)->soap_out(soap, "genskel:keyframe", id, NULL);
	case SOAP_TYPE__genskel__keyframes:
		return ((_genskel__keyframes *)ptr)->soap_out(soap, "genskel:keyframes", id, NULL);
	case SOAP_TYPE__genskel__track:
		return ((_genskel__track *)ptr)->soap_out(soap, "genskel:track", id, NULL);
	case SOAP_TYPE__genskel__tracks:
		return ((_genskel__tracks *)ptr)->soap_out(soap, "genskel:tracks", id, NULL);
	case SOAP_TYPE__genskel__animation:
		return ((_genskel__animation *)ptr)->soap_out(soap, "genskel:animation", id, NULL);
	case SOAP_TYPE__genskel__animations:
		return ((_genskel__animations *)ptr)->soap_out(soap, "genskel:animations", id, NULL);
	case SOAP_TYPE__genskel__boneparent:
		return ((_genskel__boneparent *)ptr)->soap_out(soap, "genskel:boneparent", id, NULL);
	case SOAP_TYPE__genskel__bonehierarchy:
		return ((_genskel__bonehierarchy *)ptr)->soap_out(soap, "genskel:bonehierarchy", id, NULL);
	case SOAP_TYPE__genskel__skeleton:
		return ((_genskel__skeleton *)ptr)->soap_out(soap, "genskel:skeleton", id, NULL);
	case SOAP_TYPE_genskel__scale:
		return ((genskel__scale *)ptr)->soap_out(soap, tag, id, "genskel:scale");
	case SOAP_TYPE_genskel__axis:
		return ((genskel__axis *)ptr)->soap_out(soap, tag, id, "genskel:axis");
	case SOAP_TYPE_genskel__rotation:
		return ((genskel__rotation *)ptr)->soap_out(soap, tag, id, "genskel:rotation");
	case SOAP_TYPE_genskel__position:
		return ((genskel__position *)ptr)->soap_out(soap, tag, id, "genskel:position");
	case SOAP_TYPE_genskel__bone:
		return ((genskel__bone *)ptr)->soap_out(soap, tag, id, "genskel:bone");
	case SOAP_TYPE_genskel__bones:
		return ((genskel__bones *)ptr)->soap_out(soap, tag, id, "genskel:bones");
	case SOAP_TYPE__genmesh__submesh_USCOREextremes:
		return ((_genmesh__submesh_USCOREextremes *)ptr)->soap_out(soap, "genmesh:submesh_extremes", id, NULL);
	case SOAP_TYPE__genmesh__extremes:
		return ((_genmesh__extremes *)ptr)->soap_out(soap, "genmesh:extremes", id, NULL);
	case SOAP_TYPE__genmesh__poseref:
		return ((_genmesh__poseref *)ptr)->soap_out(soap, "genmesh:poseref", id, NULL);
	case SOAP_TYPE__genmesh__keyframe:
		return ((_genmesh__keyframe *)ptr)->soap_out(soap, "genmesh:keyframe", id, NULL);
	case SOAP_TYPE__genmesh__keyframes:
		return ((_genmesh__keyframes *)ptr)->soap_out(soap, "genmesh:keyframes", id, NULL);
	case SOAP_TYPE__genmesh__track:
		return ((_genmesh__track *)ptr)->soap_out(soap, "genmesh:track", id, NULL);
	case SOAP_TYPE__genmesh__tracks:
		return ((_genmesh__tracks *)ptr)->soap_out(soap, "genmesh:tracks", id, NULL);
	case SOAP_TYPE__genmesh__animation:
		return ((_genmesh__animation *)ptr)->soap_out(soap, "genmesh:animation", id, NULL);
	case SOAP_TYPE__genmesh__animations:
		return ((_genmesh__animations *)ptr)->soap_out(soap, "genmesh:animations", id, NULL);
	case SOAP_TYPE__genmesh__poseoffset:
		return ((_genmesh__poseoffset *)ptr)->soap_out(soap, "genmesh:poseoffset", id, NULL);
	case SOAP_TYPE__genmesh__pose:
		return ((_genmesh__pose *)ptr)->soap_out(soap, "genmesh:pose", id, NULL);
	case SOAP_TYPE__genmesh__poses:
		return ((_genmesh__poses *)ptr)->soap_out(soap, "genmesh:poses", id, NULL);
	case SOAP_TYPE__genmesh__submeshname:
		return ((_genmesh__submeshname *)ptr)->soap_out(soap, "genmesh:submeshname", id, NULL);
	case SOAP_TYPE__genmesh__submeshnames:
		return ((_genmesh__submeshnames *)ptr)->soap_out(soap, "genmesh:submeshnames", id, NULL);
	case SOAP_TYPE__genmesh__texcoord:
		return ((_genmesh__texcoord *)ptr)->soap_out(soap, "genmesh:texcoord", id, NULL);
	case SOAP_TYPE__genmesh__colour_USCOREspecular:
		return ((_genmesh__colour_USCOREspecular *)ptr)->soap_out(soap, "genmesh:colour_specular", id, NULL);
	case SOAP_TYPE__genmesh__colour_USCOREdiffuse:
		return ((_genmesh__colour_USCOREdiffuse *)ptr)->soap_out(soap, "genmesh:colour_diffuse", id, NULL);
	case SOAP_TYPE__genmesh__binormal:
		return ((_genmesh__binormal *)ptr)->soap_out(soap, "genmesh:binormal", id, NULL);
	case SOAP_TYPE__genmesh__tangent:
		return ((_genmesh__tangent *)ptr)->soap_out(soap, "genmesh:tangent", id, NULL);
	case SOAP_TYPE__genmesh__normal:
		return ((_genmesh__normal *)ptr)->soap_out(soap, "genmesh:normal", id, NULL);
	case SOAP_TYPE__genmesh__position:
		return ((_genmesh__position *)ptr)->soap_out(soap, "genmesh:position", id, NULL);
	case SOAP_TYPE__genmesh__vertex:
		return ((_genmesh__vertex *)ptr)->soap_out(soap, "genmesh:vertex", id, NULL);
	case SOAP_TYPE__genmesh__vertexbuffer:
		return ((_genmesh__vertexbuffer *)ptr)->soap_out(soap, "genmesh:vertexbuffer", id, NULL);
	case SOAP_TYPE__genmesh__lodfacelist:
		return ((_genmesh__lodfacelist *)ptr)->soap_out(soap, "genmesh:lodfacelist", id, NULL);
	case SOAP_TYPE__genmesh__lodgenerated:
		return ((_genmesh__lodgenerated *)ptr)->soap_out(soap, "genmesh:lodgenerated", id, NULL);
	case SOAP_TYPE__genmesh__lodmanual:
		return ((_genmesh__lodmanual *)ptr)->soap_out(soap, "genmesh:lodmanual", id, NULL);
	case SOAP_TYPE__genmesh__levelofdetail:
		return ((_genmesh__levelofdetail *)ptr)->soap_out(soap, "genmesh:levelofdetail", id, NULL);
	case SOAP_TYPE__genmesh__vertexboneassignment:
		return ((_genmesh__vertexboneassignment *)ptr)->soap_out(soap, "genmesh:vertexboneassignment", id, NULL);
	case SOAP_TYPE__genmesh__boneassignments:
		return ((_genmesh__boneassignments *)ptr)->soap_out(soap, "genmesh:boneassignments", id, NULL);
	case SOAP_TYPE__genmesh__skeletonlink:
		return ((_genmesh__skeletonlink *)ptr)->soap_out(soap, "genmesh:skeletonlink", id, NULL);
	case SOAP_TYPE__genmesh__geometry:
		return ((_genmesh__geometry *)ptr)->soap_out(soap, "genmesh:geometry", id, NULL);
	case SOAP_TYPE__genmesh__face:
		return ((_genmesh__face *)ptr)->soap_out(soap, "genmesh:face", id, NULL);
	case SOAP_TYPE__genmesh__faces:
		return ((_genmesh__faces *)ptr)->soap_out(soap, "genmesh:faces", id, NULL);
	case SOAP_TYPE__genmesh__texture:
		return ((_genmesh__texture *)ptr)->soap_out(soap, "genmesh:texture", id, NULL);
	case SOAP_TYPE__genmesh__textures:
		return ((_genmesh__textures *)ptr)->soap_out(soap, "genmesh:textures", id, NULL);
	case SOAP_TYPE__genmesh__submesh:
		return ((_genmesh__submesh *)ptr)->soap_out(soap, "genmesh:submesh", id, NULL);
	case SOAP_TYPE__genmesh__submeshes:
		return ((_genmesh__submeshes *)ptr)->soap_out(soap, "genmesh:submeshes", id, NULL);
	case SOAP_TYPE__genmesh__sharedgeometry:
		return ((_genmesh__sharedgeometry *)ptr)->soap_out(soap, "genmesh:sharedgeometry", id, NULL);
	case SOAP_TYPE__genmesh__mesh:
		return ((_genmesh__mesh *)ptr)->soap_out(soap, "genmesh:mesh", id, NULL);
	case SOAP_TYPE__genmech__mech:
		return ((_genmech__mech *)ptr)->soap_out(soap, "genmech:mech", id, NULL);
	case SOAP_TYPE_genmech__mesh:
		return ((genmech__mesh *)ptr)->soap_out(soap, tag, id, "genmech:mesh");
	case SOAP_TYPE_genmech__torso:
		return ((genmech__torso *)ptr)->soap_out(soap, tag, id, "genmech:torso");
	case SOAP_TYPE_genmech__equSlot:
		return ((genmech__equSlot *)ptr)->soap_out(soap, tag, id, "genmech:equSlot");
	case SOAP_TYPE_genmech__equSlots:
		return ((genmech__equSlots *)ptr)->soap_out(soap, tag, id, "genmech:equSlots");
	case SOAP_TYPE_genmech__design:
		return ((genmech__design *)ptr)->soap_out(soap, tag, id, "genmech:design");
	case SOAP_TYPE_genmech__stats:
		return ((genmech__stats *)ptr)->soap_out(soap, tag, id, "genmech:stats");
	case SOAP_TYPE_PointerTo_genskel__animationlink:
		return soap_out_PointerTo_genskel__animationlink(soap, tag, id, (_genskel__animationlink *const*)ptr, "genskel:animationlink");
	case SOAP_TYPE_PointerTo_genskel__rotate:
		return soap_out_PointerTo_genskel__rotate(soap, tag, id, (_genskel__rotate *const*)ptr, "genskel:rotate");
	case SOAP_TYPE_PointerTo_genskel__translate:
		return soap_out_PointerTo_genskel__translate(soap, tag, id, (_genskel__translate *const*)ptr, "genskel:translate");
	case SOAP_TYPE_PointerTo_genskel__keyframe:
		return soap_out_PointerTo_genskel__keyframe(soap, tag, id, (_genskel__keyframe *const*)ptr, "genskel:keyframe");
	case SOAP_TYPE_PointerTo_genskel__keyframes:
		return soap_out_PointerTo_genskel__keyframes(soap, tag, id, (_genskel__keyframes *const*)ptr, "genskel:keyframes");
	case SOAP_TYPE_PointerTo_genskel__track:
		return soap_out_PointerTo_genskel__track(soap, tag, id, (_genskel__track *const*)ptr, "genskel:track");
	case SOAP_TYPE_PointerTo_genskel__tracks:
		return soap_out_PointerTo_genskel__tracks(soap, tag, id, (_genskel__tracks *const*)ptr, "genskel:tracks");
	case SOAP_TYPE_PointerTo_genskel__animation:
		return soap_out_PointerTo_genskel__animation(soap, tag, id, (_genskel__animation *const*)ptr, "genskel:animation");
	case SOAP_TYPE_PointerTo_genskel__boneparent:
		return soap_out_PointerTo_genskel__boneparent(soap, tag, id, (_genskel__boneparent *const*)ptr, "genskel:boneparent");
	case SOAP_TYPE_PointerTo_genskel__animationlinks:
		return soap_out_PointerTo_genskel__animationlinks(soap, tag, id, (_genskel__animationlinks *const*)ptr, "genskel:animationlinks");
	case SOAP_TYPE_PointerTo_genskel__animations:
		return soap_out_PointerTo_genskel__animations(soap, tag, id, (_genskel__animations *const*)ptr, "genskel:animations");
	case SOAP_TYPE_PointerTo_genskel__bonehierarchy:
		return soap_out_PointerTo_genskel__bonehierarchy(soap, tag, id, (_genskel__bonehierarchy *const*)ptr, "genskel:bonehierarchy");
	case SOAP_TYPE_PointerTogenskel__bones:
		return soap_out_PointerTogenskel__bones(soap, tag, id, (genskel__bones *const*)ptr, "genskel:bones");
	case SOAP_TYPE_PointerTogenskel__axis:
		return soap_out_PointerTogenskel__axis(soap, tag, id, (genskel__axis *const*)ptr, "genskel:axis");
	case SOAP_TYPE_PointerTogenskel__scale:
		return soap_out_PointerTogenskel__scale(soap, tag, id, (genskel__scale *const*)ptr, "genskel:scale");
	case SOAP_TYPE_PointerTogenskel__rotation:
		return soap_out_PointerTogenskel__rotation(soap, tag, id, (genskel__rotation *const*)ptr, "genskel:rotation");
	case SOAP_TYPE_PointerTogenskel__position:
		return soap_out_PointerTogenskel__position(soap, tag, id, (genskel__position *const*)ptr, "genskel:position");
	case SOAP_TYPE_PointerTogenskel__bone:
		return soap_out_PointerTogenskel__bone(soap, tag, id, (genskel__bone *const*)ptr, "genskel:bone");
	case SOAP_TYPE_PointerTo_genmesh__poseref:
		return soap_out_PointerTo_genmesh__poseref(soap, tag, id, (_genmesh__poseref *const*)ptr, "genmesh:poseref");
	case SOAP_TYPE_PointerTo_genmesh__keyframe:
		return soap_out_PointerTo_genmesh__keyframe(soap, tag, id, (_genmesh__keyframe *const*)ptr, "genmesh:keyframe");
	case SOAP_TYPE_PointerTo_genmesh__keyframes:
		return soap_out_PointerTo_genmesh__keyframes(soap, tag, id, (_genmesh__keyframes *const*)ptr, "genmesh:keyframes");
	case SOAP_TYPE_PointerTo_genmesh__track:
		return soap_out_PointerTo_genmesh__track(soap, tag, id, (_genmesh__track *const*)ptr, "genmesh:track");
	case SOAP_TYPE_PointerTo_genmesh__tracks:
		return soap_out_PointerTo_genmesh__tracks(soap, tag, id, (_genmesh__tracks *const*)ptr, "genmesh:tracks");
	case SOAP_TYPE_PointerTo_genmesh__animation:
		return soap_out_PointerTo_genmesh__animation(soap, tag, id, (_genmesh__animation *const*)ptr, "genmesh:animation");
	case SOAP_TYPE_PointerTo_genmesh__poseoffset:
		return soap_out_PointerTo_genmesh__poseoffset(soap, tag, id, (_genmesh__poseoffset *const*)ptr, "genmesh:poseoffset");
	case SOAP_TYPE_PointerTo_genmesh__pose:
		return soap_out_PointerTo_genmesh__pose(soap, tag, id, (_genmesh__pose *const*)ptr, "genmesh:pose");
	case SOAP_TYPE_PointerTo_genmesh__submeshname:
		return soap_out_PointerTo_genmesh__submeshname(soap, tag, id, (_genmesh__submeshname *const*)ptr, "genmesh:submeshname");
	case SOAP_TYPE_PointerTo_genmesh__texcoord:
		return soap_out_PointerTo_genmesh__texcoord(soap, tag, id, (_genmesh__texcoord *const*)ptr, "genmesh:texcoord");
	case SOAP_TYPE_PointerTo_genmesh__colour_USCOREspecular:
		return soap_out_PointerTo_genmesh__colour_USCOREspecular(soap, tag, id, (_genmesh__colour_USCOREspecular *const*)ptr, "genmesh:colour_specular");
	case SOAP_TYPE_PointerTo_genmesh__colour_USCOREdiffuse:
		return soap_out_PointerTo_genmesh__colour_USCOREdiffuse(soap, tag, id, (_genmesh__colour_USCOREdiffuse *const*)ptr, "genmesh:colour_diffuse");
	case SOAP_TYPE_PointerTo_genmesh__binormal:
		return soap_out_PointerTo_genmesh__binormal(soap, tag, id, (_genmesh__binormal *const*)ptr, "genmesh:binormal");
	case SOAP_TYPE_PointerTo_genmesh__tangent:
		return soap_out_PointerTo_genmesh__tangent(soap, tag, id, (_genmesh__tangent *const*)ptr, "genmesh:tangent");
	case SOAP_TYPE_PointerTo_genmesh__normal:
		return soap_out_PointerTo_genmesh__normal(soap, tag, id, (_genmesh__normal *const*)ptr, "genmesh:normal");
	case SOAP_TYPE_PointerTo_genmesh__position:
		return soap_out_PointerTo_genmesh__position(soap, tag, id, (_genmesh__position *const*)ptr, "genmesh:position");
	case SOAP_TYPE_PointerTo_genmesh__vertex:
		return soap_out_PointerTo_genmesh__vertex(soap, tag, id, (_genmesh__vertex *const*)ptr, "genmesh:vertex");
	case SOAP_TYPE_PointerTo_genmesh__lodfacelist:
		return soap_out_PointerTo_genmesh__lodfacelist(soap, tag, id, (_genmesh__lodfacelist *const*)ptr, "genmesh:lodfacelist");
	case SOAP_TYPE_PointerTo_genmesh__lodgenerated:
		return soap_out_PointerTo_genmesh__lodgenerated(soap, tag, id, (_genmesh__lodgenerated *const*)ptr, "genmesh:lodgenerated");
	case SOAP_TYPE_PointerTo_genmesh__lodmanual:
		return soap_out_PointerTo_genmesh__lodmanual(soap, tag, id, (_genmesh__lodmanual *const*)ptr, "genmesh:lodmanual");
	case SOAP_TYPE_PointerTo_genmesh__vertexboneassignment:
		return soap_out_PointerTo_genmesh__vertexboneassignment(soap, tag, id, (_genmesh__vertexboneassignment *const*)ptr, "genmesh:vertexboneassignment");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE_PointerTo_genmesh__face:
		return soap_out_PointerTo_genmesh__face(soap, tag, id, (_genmesh__face *const*)ptr, "genmesh:face");
	case SOAP_TYPE_PointerTo_genmesh__texture:
		return soap_out_PointerTo_genmesh__texture(soap, tag, id, (_genmesh__texture *const*)ptr, "genmesh:texture");
	case SOAP_TYPE_PointerTo_genmesh__geometry:
		return soap_out_PointerTo_genmesh__geometry(soap, tag, id, (_genmesh__geometry *const*)ptr, "genmesh:geometry");
	case SOAP_TYPE_PointerTo_genmesh__faces:
		return soap_out_PointerTo_genmesh__faces(soap, tag, id, (_genmesh__faces *const*)ptr, "genmesh:faces");
	case SOAP_TYPE_PointerTo_genmesh__textures:
		return soap_out_PointerTo_genmesh__textures(soap, tag, id, (_genmesh__textures *const*)ptr, "genmesh:textures");
	case SOAP_TYPE_PointerTo_genmesh__submesh:
		return soap_out_PointerTo_genmesh__submesh(soap, tag, id, (_genmesh__submesh *const*)ptr, "genmesh:submesh");
	case SOAP_TYPE_PointerTo_genmesh__vertexbuffer:
		return soap_out_PointerTo_genmesh__vertexbuffer(soap, tag, id, (_genmesh__vertexbuffer *const*)ptr, "genmesh:vertexbuffer");
	case SOAP_TYPE_PointerTo_genmesh__extremes:
		return soap_out_PointerTo_genmesh__extremes(soap, tag, id, (_genmesh__extremes *const*)ptr, "genmesh:extremes");
	case SOAP_TYPE_PointerTo_genmesh__animations:
		return soap_out_PointerTo_genmesh__animations(soap, tag, id, (_genmesh__animations *const*)ptr, "genmesh:animations");
	case SOAP_TYPE_PointerTo_genmesh__poses:
		return soap_out_PointerTo_genmesh__poses(soap, tag, id, (_genmesh__poses *const*)ptr, "genmesh:poses");
	case SOAP_TYPE_PointerTo_genmesh__submeshnames:
		return soap_out_PointerTo_genmesh__submeshnames(soap, tag, id, (_genmesh__submeshnames *const*)ptr, "genmesh:submeshnames");
	case SOAP_TYPE_PointerTo_genmesh__levelofdetail:
		return soap_out_PointerTo_genmesh__levelofdetail(soap, tag, id, (_genmesh__levelofdetail *const*)ptr, "genmesh:levelofdetail");
	case SOAP_TYPE_PointerTo_genmesh__boneassignments:
		return soap_out_PointerTo_genmesh__boneassignments(soap, tag, id, (_genmesh__boneassignments *const*)ptr, "genmesh:boneassignments");
	case SOAP_TYPE_PointerTo_genmesh__skeletonlink:
		return soap_out_PointerTo_genmesh__skeletonlink(soap, tag, id, (_genmesh__skeletonlink *const*)ptr, "genmesh:skeletonlink");
	case SOAP_TYPE_PointerTo_genmesh__submeshes:
		return soap_out_PointerTo_genmesh__submeshes(soap, tag, id, (_genmesh__submeshes *const*)ptr, "genmesh:submeshes");
	case SOAP_TYPE_PointerTo_genmesh__sharedgeometry:
		return soap_out_PointerTo_genmesh__sharedgeometry(soap, tag, id, (_genmesh__sharedgeometry *const*)ptr, "genmesh:sharedgeometry");
	case SOAP_TYPE_PointerTogenmech__mesh:
		return soap_out_PointerTogenmech__mesh(soap, tag, id, (genmech__mesh *const*)ptr, "genmech:mesh");
	case SOAP_TYPE_PointerTogenmech__design:
		return soap_out_PointerTogenmech__design(soap, tag, id, (genmech__design *const*)ptr, "genmech:design");
	case SOAP_TYPE_PointerTogenmech__stats:
		return soap_out_PointerTogenmech__stats(soap, tag, id, (genmech__stats *const*)ptr, "genmech:stats");
	case SOAP_TYPE_PointerTogenmech__equSlot:
		return soap_out_PointerTogenmech__equSlot(soap, tag, id, (genmech__equSlot *const*)ptr, "genmech:equSlot");
	case SOAP_TYPE_PointerTogenmech__equSlots:
		return soap_out_PointerTogenmech__equSlots(soap, tag, id, (genmech__equSlots *const*)ptr, "genmech:equSlots");
	case SOAP_TYPE_PointerTogenmech__torso:
		return soap_out_PointerTogenmech__torso(soap, tag, id, (genmech__torso *const*)ptr, "genmech:torso");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char*const*)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE___genmesh__lodfacelist_sequence:
		((__genmesh__lodfacelist_sequence *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE___genmesh__union_levelofdetail:
		((__genmesh__union_levelofdetail *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE__genskel__animationlink:
		((_genskel__animationlink *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genskel__animationlinks:
		((_genskel__animationlinks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genskel__rotate:
		((_genskel__rotate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genskel__translate:
		((_genskel__translate *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genskel__keyframe:
		((_genskel__keyframe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genskel__keyframes:
		((_genskel__keyframes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genskel__track:
		((_genskel__track *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genskel__tracks:
		((_genskel__tracks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genskel__animation:
		((_genskel__animation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genskel__animations:
		((_genskel__animations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genskel__boneparent:
		((_genskel__boneparent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genskel__bonehierarchy:
		((_genskel__bonehierarchy *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genskel__skeleton:
		((_genskel__skeleton *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_genskel__scale:
		((genskel__scale *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_genskel__axis:
		((genskel__axis *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_genskel__rotation:
		((genskel__rotation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_genskel__position:
		((genskel__position *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_genskel__bone:
		((genskel__bone *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_genskel__bones:
		((genskel__bones *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__submesh_USCOREextremes:
		((_genmesh__submesh_USCOREextremes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__extremes:
		((_genmesh__extremes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__poseref:
		((_genmesh__poseref *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__keyframe:
		((_genmesh__keyframe *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__keyframes:
		((_genmesh__keyframes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__track:
		((_genmesh__track *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__tracks:
		((_genmesh__tracks *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__animation:
		((_genmesh__animation *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__animations:
		((_genmesh__animations *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__poseoffset:
		((_genmesh__poseoffset *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__pose:
		((_genmesh__pose *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__poses:
		((_genmesh__poses *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__submeshname:
		((_genmesh__submeshname *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__submeshnames:
		((_genmesh__submeshnames *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__texcoord:
		((_genmesh__texcoord *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__colour_USCOREspecular:
		((_genmesh__colour_USCOREspecular *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__colour_USCOREdiffuse:
		((_genmesh__colour_USCOREdiffuse *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__binormal:
		((_genmesh__binormal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__tangent:
		((_genmesh__tangent *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__normal:
		((_genmesh__normal *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__position:
		((_genmesh__position *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__vertex:
		((_genmesh__vertex *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__vertexbuffer:
		((_genmesh__vertexbuffer *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__lodfacelist:
		((_genmesh__lodfacelist *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__lodgenerated:
		((_genmesh__lodgenerated *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__lodmanual:
		((_genmesh__lodmanual *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__levelofdetail:
		((_genmesh__levelofdetail *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__vertexboneassignment:
		((_genmesh__vertexboneassignment *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__boneassignments:
		((_genmesh__boneassignments *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__skeletonlink:
		((_genmesh__skeletonlink *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__geometry:
		((_genmesh__geometry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__face:
		((_genmesh__face *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__faces:
		((_genmesh__faces *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__texture:
		((_genmesh__texture *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__textures:
		((_genmesh__textures *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__submesh:
		((_genmesh__submesh *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__submeshes:
		((_genmesh__submeshes *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__sharedgeometry:
		((_genmesh__sharedgeometry *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmesh__mesh:
		((_genmesh__mesh *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__genmech__mech:
		((_genmech__mech *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_genmech__mesh:
		((genmech__mesh *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_genmech__torso:
		((genmech__torso *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_genmech__equSlot:
		((genmech__equSlot *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_genmech__equSlots:
		((genmech__equSlots *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_genmech__design:
		((genmech__design *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_genmech__stats:
		((genmech__stats *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_PointerTo_genskel__animationlink:
		soap_serialize_PointerTo_genskel__animationlink(soap, (_genskel__animationlink *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genskel__rotate:
		soap_serialize_PointerTo_genskel__rotate(soap, (_genskel__rotate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genskel__translate:
		soap_serialize_PointerTo_genskel__translate(soap, (_genskel__translate *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genskel__keyframe:
		soap_serialize_PointerTo_genskel__keyframe(soap, (_genskel__keyframe *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genskel__keyframes:
		soap_serialize_PointerTo_genskel__keyframes(soap, (_genskel__keyframes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genskel__track:
		soap_serialize_PointerTo_genskel__track(soap, (_genskel__track *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genskel__tracks:
		soap_serialize_PointerTo_genskel__tracks(soap, (_genskel__tracks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genskel__animation:
		soap_serialize_PointerTo_genskel__animation(soap, (_genskel__animation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genskel__boneparent:
		soap_serialize_PointerTo_genskel__boneparent(soap, (_genskel__boneparent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genskel__animationlinks:
		soap_serialize_PointerTo_genskel__animationlinks(soap, (_genskel__animationlinks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genskel__animations:
		soap_serialize_PointerTo_genskel__animations(soap, (_genskel__animations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genskel__bonehierarchy:
		soap_serialize_PointerTo_genskel__bonehierarchy(soap, (_genskel__bonehierarchy *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogenskel__bones:
		soap_serialize_PointerTogenskel__bones(soap, (genskel__bones *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogenskel__axis:
		soap_serialize_PointerTogenskel__axis(soap, (genskel__axis *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogenskel__scale:
		soap_serialize_PointerTogenskel__scale(soap, (genskel__scale *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogenskel__rotation:
		soap_serialize_PointerTogenskel__rotation(soap, (genskel__rotation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogenskel__position:
		soap_serialize_PointerTogenskel__position(soap, (genskel__position *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogenskel__bone:
		soap_serialize_PointerTogenskel__bone(soap, (genskel__bone *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__poseref:
		soap_serialize_PointerTo_genmesh__poseref(soap, (_genmesh__poseref *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__keyframe:
		soap_serialize_PointerTo_genmesh__keyframe(soap, (_genmesh__keyframe *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__keyframes:
		soap_serialize_PointerTo_genmesh__keyframes(soap, (_genmesh__keyframes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__track:
		soap_serialize_PointerTo_genmesh__track(soap, (_genmesh__track *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__tracks:
		soap_serialize_PointerTo_genmesh__tracks(soap, (_genmesh__tracks *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__animation:
		soap_serialize_PointerTo_genmesh__animation(soap, (_genmesh__animation *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__poseoffset:
		soap_serialize_PointerTo_genmesh__poseoffset(soap, (_genmesh__poseoffset *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__pose:
		soap_serialize_PointerTo_genmesh__pose(soap, (_genmesh__pose *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__submeshname:
		soap_serialize_PointerTo_genmesh__submeshname(soap, (_genmesh__submeshname *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__texcoord:
		soap_serialize_PointerTo_genmesh__texcoord(soap, (_genmesh__texcoord *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__colour_USCOREspecular:
		soap_serialize_PointerTo_genmesh__colour_USCOREspecular(soap, (_genmesh__colour_USCOREspecular *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__colour_USCOREdiffuse:
		soap_serialize_PointerTo_genmesh__colour_USCOREdiffuse(soap, (_genmesh__colour_USCOREdiffuse *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__binormal:
		soap_serialize_PointerTo_genmesh__binormal(soap, (_genmesh__binormal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__tangent:
		soap_serialize_PointerTo_genmesh__tangent(soap, (_genmesh__tangent *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__normal:
		soap_serialize_PointerTo_genmesh__normal(soap, (_genmesh__normal *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__position:
		soap_serialize_PointerTo_genmesh__position(soap, (_genmesh__position *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__vertex:
		soap_serialize_PointerTo_genmesh__vertex(soap, (_genmesh__vertex *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__genmesh__lodfacelist_sequence:
		soap_serialize_PointerTo__genmesh__lodfacelist_sequence(soap, (__genmesh__lodfacelist_sequence *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__lodfacelist:
		soap_serialize_PointerTo_genmesh__lodfacelist(soap, (_genmesh__lodfacelist *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo__genmesh__union_levelofdetail:
		soap_serialize_PointerTo__genmesh__union_levelofdetail(soap, (__genmesh__union_levelofdetail *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__lodgenerated:
		soap_serialize_PointerTo_genmesh__lodgenerated(soap, (_genmesh__lodgenerated *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__lodmanual:
		soap_serialize_PointerTo_genmesh__lodmanual(soap, (_genmesh__lodmanual *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__vertexboneassignment:
		soap_serialize_PointerTo_genmesh__vertexboneassignment(soap, (_genmesh__vertexboneassignment *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__face:
		soap_serialize_PointerTo_genmesh__face(soap, (_genmesh__face *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__texture:
		soap_serialize_PointerTo_genmesh__texture(soap, (_genmesh__texture *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__geometry:
		soap_serialize_PointerTo_genmesh__geometry(soap, (_genmesh__geometry *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__faces:
		soap_serialize_PointerTo_genmesh__faces(soap, (_genmesh__faces *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__textures:
		soap_serialize_PointerTo_genmesh__textures(soap, (_genmesh__textures *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__submesh:
		soap_serialize_PointerTo_genmesh__submesh(soap, (_genmesh__submesh *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__vertexbuffer:
		soap_serialize_PointerTo_genmesh__vertexbuffer(soap, (_genmesh__vertexbuffer *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__extremes:
		soap_serialize_PointerTo_genmesh__extremes(soap, (_genmesh__extremes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__animations:
		soap_serialize_PointerTo_genmesh__animations(soap, (_genmesh__animations *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__poses:
		soap_serialize_PointerTo_genmesh__poses(soap, (_genmesh__poses *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__submeshnames:
		soap_serialize_PointerTo_genmesh__submeshnames(soap, (_genmesh__submeshnames *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__levelofdetail:
		soap_serialize_PointerTo_genmesh__levelofdetail(soap, (_genmesh__levelofdetail *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__boneassignments:
		soap_serialize_PointerTo_genmesh__boneassignments(soap, (_genmesh__boneassignments *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__skeletonlink:
		soap_serialize_PointerTo_genmesh__skeletonlink(soap, (_genmesh__skeletonlink *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__submeshes:
		soap_serialize_PointerTo_genmesh__submeshes(soap, (_genmesh__submeshes *const*)ptr);
		break;
	case SOAP_TYPE_PointerTo_genmesh__sharedgeometry:
		soap_serialize_PointerTo_genmesh__sharedgeometry(soap, (_genmesh__sharedgeometry *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogenmech__mesh:
		soap_serialize_PointerTogenmech__mesh(soap, (genmech__mesh *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogenmech__design:
		soap_serialize_PointerTogenmech__design(soap, (genmech__design *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogenmech__stats:
		soap_serialize_PointerTogenmech__stats(soap, (genmech__stats *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogenmech__equSlot:
		soap_serialize_PointerTogenmech__equSlot(soap, (genmech__equSlot *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogenmech__equSlots:
		soap_serialize_PointerTogenmech__equSlots(soap, (genmech__equSlots *const*)ptr);
		break;
	case SOAP_TYPE_PointerTogenmech__torso:
		soap_serialize_PointerTogenmech__torso(soap, (genmech__torso *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_genmech__stats:
		return (void*)soap_instantiate_genmech__stats(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_genmech__design:
		return (void*)soap_instantiate_genmech__design(soap, -1, type, arrayType, n);
	case SOAP_TYPE_genmech__equSlots:
		return (void*)soap_instantiate_genmech__equSlots(soap, -1, type, arrayType, n);
	case SOAP_TYPE_genmech__equSlot:
		return (void*)soap_instantiate_genmech__equSlot(soap, -1, type, arrayType, n);
	case SOAP_TYPE_genmech__torso:
		return (void*)soap_instantiate_genmech__torso(soap, -1, type, arrayType, n);
	case SOAP_TYPE_genmech__mesh:
		return (void*)soap_instantiate_genmech__mesh(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmech__mech:
		return (void*)soap_instantiate__genmech__mech(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__mesh:
		return (void*)soap_instantiate__genmesh__mesh(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__sharedgeometry:
		return (void*)soap_instantiate__genmesh__sharedgeometry(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__submeshes:
		return (void*)soap_instantiate__genmesh__submeshes(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__submesh:
		return (void*)soap_instantiate__genmesh__submesh(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__textures:
		return (void*)soap_instantiate__genmesh__textures(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__texture:
		return (void*)soap_instantiate__genmesh__texture(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__faces:
		return (void*)soap_instantiate__genmesh__faces(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__face:
		return (void*)soap_instantiate__genmesh__face(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__geometry:
		return (void*)soap_instantiate__genmesh__geometry(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__skeletonlink:
		return (void*)soap_instantiate__genmesh__skeletonlink(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__boneassignments:
		return (void*)soap_instantiate__genmesh__boneassignments(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__vertexboneassignment:
		return (void*)soap_instantiate__genmesh__vertexboneassignment(soap, -1, type, arrayType, n);
	case SOAP_TYPE___genmesh__union_levelofdetail:
		return (void*)soap_instantiate___genmesh__union_levelofdetail(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__levelofdetail:
		return (void*)soap_instantiate__genmesh__levelofdetail(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__lodmanual:
		return (void*)soap_instantiate__genmesh__lodmanual(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__lodgenerated:
		return (void*)soap_instantiate__genmesh__lodgenerated(soap, -1, type, arrayType, n);
	case SOAP_TYPE___genmesh__lodfacelist_sequence:
		return (void*)soap_instantiate___genmesh__lodfacelist_sequence(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__lodfacelist:
		return (void*)soap_instantiate__genmesh__lodfacelist(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__vertexbuffer:
		return (void*)soap_instantiate__genmesh__vertexbuffer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__vertex:
		return (void*)soap_instantiate__genmesh__vertex(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__position:
		return (void*)soap_instantiate__genmesh__position(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__normal:
		return (void*)soap_instantiate__genmesh__normal(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__tangent:
		return (void*)soap_instantiate__genmesh__tangent(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__binormal:
		return (void*)soap_instantiate__genmesh__binormal(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__colour_USCOREdiffuse:
		return (void*)soap_instantiate__genmesh__colour_USCOREdiffuse(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__colour_USCOREspecular:
		return (void*)soap_instantiate__genmesh__colour_USCOREspecular(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__texcoord:
		return (void*)soap_instantiate__genmesh__texcoord(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__submeshnames:
		return (void*)soap_instantiate__genmesh__submeshnames(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__submeshname:
		return (void*)soap_instantiate__genmesh__submeshname(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__poses:
		return (void*)soap_instantiate__genmesh__poses(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__pose:
		return (void*)soap_instantiate__genmesh__pose(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__poseoffset:
		return (void*)soap_instantiate__genmesh__poseoffset(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__animations:
		return (void*)soap_instantiate__genmesh__animations(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__animation:
		return (void*)soap_instantiate__genmesh__animation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__tracks:
		return (void*)soap_instantiate__genmesh__tracks(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__track:
		return (void*)soap_instantiate__genmesh__track(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__keyframes:
		return (void*)soap_instantiate__genmesh__keyframes(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__keyframe:
		return (void*)soap_instantiate__genmesh__keyframe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__poseref:
		return (void*)soap_instantiate__genmesh__poseref(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__extremes:
		return (void*)soap_instantiate__genmesh__extremes(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genmesh__submesh_USCOREextremes:
		return (void*)soap_instantiate__genmesh__submesh_USCOREextremes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_genskel__bones:
		return (void*)soap_instantiate_genskel__bones(soap, -1, type, arrayType, n);
	case SOAP_TYPE_genskel__bone:
		return (void*)soap_instantiate_genskel__bone(soap, -1, type, arrayType, n);
	case SOAP_TYPE_genskel__position:
		return (void*)soap_instantiate_genskel__position(soap, -1, type, arrayType, n);
	case SOAP_TYPE_genskel__rotation:
		return (void*)soap_instantiate_genskel__rotation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_genskel__axis:
		return (void*)soap_instantiate_genskel__axis(soap, -1, type, arrayType, n);
	case SOAP_TYPE_genskel__scale:
		return (void*)soap_instantiate_genskel__scale(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genskel__skeleton:
		return (void*)soap_instantiate__genskel__skeleton(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genskel__bonehierarchy:
		return (void*)soap_instantiate__genskel__bonehierarchy(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genskel__boneparent:
		return (void*)soap_instantiate__genskel__boneparent(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genskel__animations:
		return (void*)soap_instantiate__genskel__animations(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genskel__animation:
		return (void*)soap_instantiate__genskel__animation(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genskel__tracks:
		return (void*)soap_instantiate__genskel__tracks(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genskel__track:
		return (void*)soap_instantiate__genskel__track(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genskel__keyframes:
		return (void*)soap_instantiate__genskel__keyframes(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genskel__keyframe:
		return (void*)soap_instantiate__genskel__keyframe(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genskel__translate:
		return (void*)soap_instantiate__genskel__translate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genskel__rotate:
		return (void*)soap_instantiate__genskel__rotate(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genskel__animationlinks:
		return (void*)soap_instantiate__genskel__animationlinks(soap, -1, type, arrayType, n);
	case SOAP_TYPE__genskel__animationlink:
		return (void*)soap_instantiate__genskel__animationlink(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__animationlink:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genskel__animationlink(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__keyframe:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genskel__keyframe(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__track:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genskel__track(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__animation:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genskel__animation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__boneparent:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genskel__boneparent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTogenskel__bone:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTogenskel__bone(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__poseref:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__poseref(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__position:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__position(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__keyframe:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__keyframe(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__track:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__track(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__animation:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__animation(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__poseoffset:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__poseoffset(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__pose:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__pose(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__submeshname:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__submeshname(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__texcoord:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__texcoord(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__vertex:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__vertex(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__face:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__face(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__texture:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__texture(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__submesh:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__submesh(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(soap, -1, type, arrayType, n);
	case SOAP_TYPE_std__vectorTemplateOfPointerTogenmech__equSlot:
		return (void*)soap_instantiate_std__vectorTemplateOfPointerTogenmech__equSlot(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_genmech__stats:
		if (p->size < 0)
			delete (genmech__stats*)p->ptr;
		else
			delete[] (genmech__stats*)p->ptr;
		break;
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_genmech__design:
		if (p->size < 0)
			delete (genmech__design*)p->ptr;
		else
			delete[] (genmech__design*)p->ptr;
		break;
	case SOAP_TYPE_genmech__equSlots:
		if (p->size < 0)
			delete (genmech__equSlots*)p->ptr;
		else
			delete[] (genmech__equSlots*)p->ptr;
		break;
	case SOAP_TYPE_genmech__equSlot:
		if (p->size < 0)
			delete (genmech__equSlot*)p->ptr;
		else
			delete[] (genmech__equSlot*)p->ptr;
		break;
	case SOAP_TYPE_genmech__torso:
		if (p->size < 0)
			delete (genmech__torso*)p->ptr;
		else
			delete[] (genmech__torso*)p->ptr;
		break;
	case SOAP_TYPE_genmech__mesh:
		if (p->size < 0)
			delete (genmech__mesh*)p->ptr;
		else
			delete[] (genmech__mesh*)p->ptr;
		break;
	case SOAP_TYPE__genmech__mech:
		if (p->size < 0)
			delete (_genmech__mech*)p->ptr;
		else
			delete[] (_genmech__mech*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__mesh:
		if (p->size < 0)
			delete (_genmesh__mesh*)p->ptr;
		else
			delete[] (_genmesh__mesh*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__sharedgeometry:
		if (p->size < 0)
			delete (_genmesh__sharedgeometry*)p->ptr;
		else
			delete[] (_genmesh__sharedgeometry*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__submeshes:
		if (p->size < 0)
			delete (_genmesh__submeshes*)p->ptr;
		else
			delete[] (_genmesh__submeshes*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__submesh:
		if (p->size < 0)
			delete (_genmesh__submesh*)p->ptr;
		else
			delete[] (_genmesh__submesh*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__textures:
		if (p->size < 0)
			delete (_genmesh__textures*)p->ptr;
		else
			delete[] (_genmesh__textures*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__texture:
		if (p->size < 0)
			delete (_genmesh__texture*)p->ptr;
		else
			delete[] (_genmesh__texture*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__faces:
		if (p->size < 0)
			delete (_genmesh__faces*)p->ptr;
		else
			delete[] (_genmesh__faces*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__face:
		if (p->size < 0)
			delete (_genmesh__face*)p->ptr;
		else
			delete[] (_genmesh__face*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__geometry:
		if (p->size < 0)
			delete (_genmesh__geometry*)p->ptr;
		else
			delete[] (_genmesh__geometry*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__skeletonlink:
		if (p->size < 0)
			delete (_genmesh__skeletonlink*)p->ptr;
		else
			delete[] (_genmesh__skeletonlink*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__boneassignments:
		if (p->size < 0)
			delete (_genmesh__boneassignments*)p->ptr;
		else
			delete[] (_genmesh__boneassignments*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__vertexboneassignment:
		if (p->size < 0)
			delete (_genmesh__vertexboneassignment*)p->ptr;
		else
			delete[] (_genmesh__vertexboneassignment*)p->ptr;
		break;
	case SOAP_TYPE___genmesh__union_levelofdetail:
		if (p->size < 0)
			delete (__genmesh__union_levelofdetail*)p->ptr;
		else
			delete[] (__genmesh__union_levelofdetail*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__levelofdetail:
		if (p->size < 0)
			delete (_genmesh__levelofdetail*)p->ptr;
		else
			delete[] (_genmesh__levelofdetail*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__lodmanual:
		if (p->size < 0)
			delete (_genmesh__lodmanual*)p->ptr;
		else
			delete[] (_genmesh__lodmanual*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__lodgenerated:
		if (p->size < 0)
			delete (_genmesh__lodgenerated*)p->ptr;
		else
			delete[] (_genmesh__lodgenerated*)p->ptr;
		break;
	case SOAP_TYPE___genmesh__lodfacelist_sequence:
		if (p->size < 0)
			delete (__genmesh__lodfacelist_sequence*)p->ptr;
		else
			delete[] (__genmesh__lodfacelist_sequence*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__lodfacelist:
		if (p->size < 0)
			delete (_genmesh__lodfacelist*)p->ptr;
		else
			delete[] (_genmesh__lodfacelist*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__vertexbuffer:
		if (p->size < 0)
			delete (_genmesh__vertexbuffer*)p->ptr;
		else
			delete[] (_genmesh__vertexbuffer*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__vertex:
		if (p->size < 0)
			delete (_genmesh__vertex*)p->ptr;
		else
			delete[] (_genmesh__vertex*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__position:
		if (p->size < 0)
			delete (_genmesh__position*)p->ptr;
		else
			delete[] (_genmesh__position*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__normal:
		if (p->size < 0)
			delete (_genmesh__normal*)p->ptr;
		else
			delete[] (_genmesh__normal*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__tangent:
		if (p->size < 0)
			delete (_genmesh__tangent*)p->ptr;
		else
			delete[] (_genmesh__tangent*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__binormal:
		if (p->size < 0)
			delete (_genmesh__binormal*)p->ptr;
		else
			delete[] (_genmesh__binormal*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__colour_USCOREdiffuse:
		if (p->size < 0)
			delete (_genmesh__colour_USCOREdiffuse*)p->ptr;
		else
			delete[] (_genmesh__colour_USCOREdiffuse*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__colour_USCOREspecular:
		if (p->size < 0)
			delete (_genmesh__colour_USCOREspecular*)p->ptr;
		else
			delete[] (_genmesh__colour_USCOREspecular*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__texcoord:
		if (p->size < 0)
			delete (_genmesh__texcoord*)p->ptr;
		else
			delete[] (_genmesh__texcoord*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__submeshnames:
		if (p->size < 0)
			delete (_genmesh__submeshnames*)p->ptr;
		else
			delete[] (_genmesh__submeshnames*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__submeshname:
		if (p->size < 0)
			delete (_genmesh__submeshname*)p->ptr;
		else
			delete[] (_genmesh__submeshname*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__poses:
		if (p->size < 0)
			delete (_genmesh__poses*)p->ptr;
		else
			delete[] (_genmesh__poses*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__pose:
		if (p->size < 0)
			delete (_genmesh__pose*)p->ptr;
		else
			delete[] (_genmesh__pose*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__poseoffset:
		if (p->size < 0)
			delete (_genmesh__poseoffset*)p->ptr;
		else
			delete[] (_genmesh__poseoffset*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__animations:
		if (p->size < 0)
			delete (_genmesh__animations*)p->ptr;
		else
			delete[] (_genmesh__animations*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__animation:
		if (p->size < 0)
			delete (_genmesh__animation*)p->ptr;
		else
			delete[] (_genmesh__animation*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__tracks:
		if (p->size < 0)
			delete (_genmesh__tracks*)p->ptr;
		else
			delete[] (_genmesh__tracks*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__track:
		if (p->size < 0)
			delete (_genmesh__track*)p->ptr;
		else
			delete[] (_genmesh__track*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__keyframes:
		if (p->size < 0)
			delete (_genmesh__keyframes*)p->ptr;
		else
			delete[] (_genmesh__keyframes*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__keyframe:
		if (p->size < 0)
			delete (_genmesh__keyframe*)p->ptr;
		else
			delete[] (_genmesh__keyframe*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__poseref:
		if (p->size < 0)
			delete (_genmesh__poseref*)p->ptr;
		else
			delete[] (_genmesh__poseref*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__extremes:
		if (p->size < 0)
			delete (_genmesh__extremes*)p->ptr;
		else
			delete[] (_genmesh__extremes*)p->ptr;
		break;
	case SOAP_TYPE__genmesh__submesh_USCOREextremes:
		if (p->size < 0)
			delete (_genmesh__submesh_USCOREextremes*)p->ptr;
		else
			delete[] (_genmesh__submesh_USCOREextremes*)p->ptr;
		break;
	case SOAP_TYPE_genskel__bones:
		if (p->size < 0)
			delete (genskel__bones*)p->ptr;
		else
			delete[] (genskel__bones*)p->ptr;
		break;
	case SOAP_TYPE_genskel__bone:
		if (p->size < 0)
			delete (genskel__bone*)p->ptr;
		else
			delete[] (genskel__bone*)p->ptr;
		break;
	case SOAP_TYPE_genskel__position:
		if (p->size < 0)
			delete (genskel__position*)p->ptr;
		else
			delete[] (genskel__position*)p->ptr;
		break;
	case SOAP_TYPE_genskel__rotation:
		if (p->size < 0)
			delete (genskel__rotation*)p->ptr;
		else
			delete[] (genskel__rotation*)p->ptr;
		break;
	case SOAP_TYPE_genskel__axis:
		if (p->size < 0)
			delete (genskel__axis*)p->ptr;
		else
			delete[] (genskel__axis*)p->ptr;
		break;
	case SOAP_TYPE_genskel__scale:
		if (p->size < 0)
			delete (genskel__scale*)p->ptr;
		else
			delete[] (genskel__scale*)p->ptr;
		break;
	case SOAP_TYPE__genskel__skeleton:
		if (p->size < 0)
			delete (_genskel__skeleton*)p->ptr;
		else
			delete[] (_genskel__skeleton*)p->ptr;
		break;
	case SOAP_TYPE__genskel__bonehierarchy:
		if (p->size < 0)
			delete (_genskel__bonehierarchy*)p->ptr;
		else
			delete[] (_genskel__bonehierarchy*)p->ptr;
		break;
	case SOAP_TYPE__genskel__boneparent:
		if (p->size < 0)
			delete (_genskel__boneparent*)p->ptr;
		else
			delete[] (_genskel__boneparent*)p->ptr;
		break;
	case SOAP_TYPE__genskel__animations:
		if (p->size < 0)
			delete (_genskel__animations*)p->ptr;
		else
			delete[] (_genskel__animations*)p->ptr;
		break;
	case SOAP_TYPE__genskel__animation:
		if (p->size < 0)
			delete (_genskel__animation*)p->ptr;
		else
			delete[] (_genskel__animation*)p->ptr;
		break;
	case SOAP_TYPE__genskel__tracks:
		if (p->size < 0)
			delete (_genskel__tracks*)p->ptr;
		else
			delete[] (_genskel__tracks*)p->ptr;
		break;
	case SOAP_TYPE__genskel__track:
		if (p->size < 0)
			delete (_genskel__track*)p->ptr;
		else
			delete[] (_genskel__track*)p->ptr;
		break;
	case SOAP_TYPE__genskel__keyframes:
		if (p->size < 0)
			delete (_genskel__keyframes*)p->ptr;
		else
			delete[] (_genskel__keyframes*)p->ptr;
		break;
	case SOAP_TYPE__genskel__keyframe:
		if (p->size < 0)
			delete (_genskel__keyframe*)p->ptr;
		else
			delete[] (_genskel__keyframe*)p->ptr;
		break;
	case SOAP_TYPE__genskel__translate:
		if (p->size < 0)
			delete (_genskel__translate*)p->ptr;
		else
			delete[] (_genskel__translate*)p->ptr;
		break;
	case SOAP_TYPE__genskel__rotate:
		if (p->size < 0)
			delete (_genskel__rotate*)p->ptr;
		else
			delete[] (_genskel__rotate*)p->ptr;
		break;
	case SOAP_TYPE__genskel__animationlinks:
		if (p->size < 0)
			delete (_genskel__animationlinks*)p->ptr;
		else
			delete[] (_genskel__animationlinks*)p->ptr;
		break;
	case SOAP_TYPE__genskel__animationlink:
		if (p->size < 0)
			delete (_genskel__animationlink*)p->ptr;
		else
			delete[] (_genskel__animationlink*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__animationlink:
		if (p->size < 0)
			delete (std::vector<_genskel__animationlink * >*)p->ptr;
		else
			delete[] (std::vector<_genskel__animationlink * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__keyframe:
		if (p->size < 0)
			delete (std::vector<_genskel__keyframe * >*)p->ptr;
		else
			delete[] (std::vector<_genskel__keyframe * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__track:
		if (p->size < 0)
			delete (std::vector<_genskel__track * >*)p->ptr;
		else
			delete[] (std::vector<_genskel__track * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__animation:
		if (p->size < 0)
			delete (std::vector<_genskel__animation * >*)p->ptr;
		else
			delete[] (std::vector<_genskel__animation * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__boneparent:
		if (p->size < 0)
			delete (std::vector<_genskel__boneparent * >*)p->ptr;
		else
			delete[] (std::vector<_genskel__boneparent * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTogenskel__bone:
		if (p->size < 0)
			delete (std::vector<genskel__bone * >*)p->ptr;
		else
			delete[] (std::vector<genskel__bone * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__poseref:
		if (p->size < 0)
			delete (std::vector<_genmesh__poseref * >*)p->ptr;
		else
			delete[] (std::vector<_genmesh__poseref * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__position:
		if (p->size < 0)
			delete (std::vector<_genmesh__position * >*)p->ptr;
		else
			delete[] (std::vector<_genmesh__position * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__keyframe:
		if (p->size < 0)
			delete (std::vector<_genmesh__keyframe * >*)p->ptr;
		else
			delete[] (std::vector<_genmesh__keyframe * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__track:
		if (p->size < 0)
			delete (std::vector<_genmesh__track * >*)p->ptr;
		else
			delete[] (std::vector<_genmesh__track * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__animation:
		if (p->size < 0)
			delete (std::vector<_genmesh__animation * >*)p->ptr;
		else
			delete[] (std::vector<_genmesh__animation * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__poseoffset:
		if (p->size < 0)
			delete (std::vector<_genmesh__poseoffset * >*)p->ptr;
		else
			delete[] (std::vector<_genmesh__poseoffset * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__pose:
		if (p->size < 0)
			delete (std::vector<_genmesh__pose * >*)p->ptr;
		else
			delete[] (std::vector<_genmesh__pose * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__submeshname:
		if (p->size < 0)
			delete (std::vector<_genmesh__submeshname * >*)p->ptr;
		else
			delete[] (std::vector<_genmesh__submeshname * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__texcoord:
		if (p->size < 0)
			delete (std::vector<_genmesh__texcoord * >*)p->ptr;
		else
			delete[] (std::vector<_genmesh__texcoord * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__vertex:
		if (p->size < 0)
			delete (std::vector<_genmesh__vertex * >*)p->ptr;
		else
			delete[] (std::vector<_genmesh__vertex * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment:
		if (p->size < 0)
			delete (std::vector<_genmesh__vertexboneassignment * >*)p->ptr;
		else
			delete[] (std::vector<_genmesh__vertexboneassignment * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__face:
		if (p->size < 0)
			delete (std::vector<_genmesh__face * >*)p->ptr;
		else
			delete[] (std::vector<_genmesh__face * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__texture:
		if (p->size < 0)
			delete (std::vector<_genmesh__texture * >*)p->ptr;
		else
			delete[] (std::vector<_genmesh__texture * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__submesh:
		if (p->size < 0)
			delete (std::vector<_genmesh__submesh * >*)p->ptr;
		else
			delete[] (std::vector<_genmesh__submesh * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer:
		if (p->size < 0)
			delete (std::vector<_genmesh__vertexbuffer * >*)p->ptr;
		else
			delete[] (std::vector<_genmesh__vertexbuffer * >*)p->ptr;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTogenmech__equSlot:
		if (p->size < 0)
			delete (std::vector<genmech__equSlot * >*)p->ptr;
		else
			delete[] (std::vector<genmech__equSlot * >*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{	switch (tt)
	{
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__animationlink:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genskel__animationlink * >*)p)[len] = *(_genskel__animationlink **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__keyframe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genskel__keyframe * >*)p)[len] = *(_genskel__keyframe **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__track:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genskel__track * >*)p)[len] = *(_genskel__track **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__animation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genskel__animation * >*)p)[len] = *(_genskel__animation **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__boneparent:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genskel__boneparent * >*)p)[len] = *(_genskel__boneparent **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTogenskel__bone:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<genskel__bone * >*)p)[len] = *(genskel__bone **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__poseref:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genmesh__poseref * >*)p)[len] = *(_genmesh__poseref **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__position:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genmesh__position * >*)p)[len] = *(_genmesh__position **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__keyframe:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genmesh__keyframe * >*)p)[len] = *(_genmesh__keyframe **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__track:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genmesh__track * >*)p)[len] = *(_genmesh__track **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__animation:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genmesh__animation * >*)p)[len] = *(_genmesh__animation **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__poseoffset:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genmesh__poseoffset * >*)p)[len] = *(_genmesh__poseoffset **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__pose:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genmesh__pose * >*)p)[len] = *(_genmesh__pose **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__submeshname:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genmesh__submeshname * >*)p)[len] = *(_genmesh__submeshname **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__texcoord:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genmesh__texcoord * >*)p)[len] = *(_genmesh__texcoord **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__vertex:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genmesh__vertex * >*)p)[len] = *(_genmesh__vertex **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genmesh__vertexboneassignment * >*)p)[len] = *(_genmesh__vertexboneassignment **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__face:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genmesh__face * >*)p)[len] = *(_genmesh__face **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__texture:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genmesh__texture * >*)p)[len] = *(_genmesh__texture **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__submesh:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genmesh__submesh * >*)p)[len] = *(_genmesh__submesh **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<_genmesh__vertexbuffer * >*)p)[len] = *(_genmesh__vertexbuffer **)q;
		break;
	case SOAP_TYPE_std__vectorTemplateOfPointerTogenmech__equSlot:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Container insert type=%d in %d location=%p object=%p len=%lu\n", st, tt, p, q, (unsigned long)len));
		(*(std::vector<genmech__equSlot * >*)p)[len] = *(genmech__equSlot **)q;
		break;
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__track_type(struct soap *soap, enum _genmesh__track_type *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__track_type
	*a = SOAP_DEFAULT__genmesh__track_type;
#else
	*a = (enum _genmesh__track_type)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__track_type(struct soap *soap, const enum _genmesh__track_type *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__track_type);
	if (soap_out__genmesh__track_type(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__track_type[] =
{	{ (long)_genmesh__track_type__morph, "morph" },
	{ (long)_genmesh__track_type__pose, "pose" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__track_type2s(struct soap *soap, enum _genmesh__track_type n)
{	const char *s = soap_code_str(soap_codes__genmesh__track_type, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__track_type(struct soap *soap, const char *tag, int id, const enum _genmesh__track_type *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__track_type), type) || soap_send(soap, soap__genmesh__track_type2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__track_type * SOAP_FMAC4 soap_get__genmesh__track_type(struct soap *soap, enum _genmesh__track_type *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__track_type(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__track_type(struct soap *soap, const char *s, enum _genmesh__track_type *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__track_type, s);
	if (map)
		*a = (enum _genmesh__track_type)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__track_type)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__track_type * SOAP_FMAC4 soap_in__genmesh__track_type(struct soap *soap, const char *tag, enum _genmesh__track_type *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__track_type *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__track_type, sizeof(enum _genmesh__track_type), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__track_type(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__track_type *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__track_type, 0, sizeof(enum _genmesh__track_type), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__track_target(struct soap *soap, enum _genmesh__track_target *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__track_target
	*a = SOAP_DEFAULT__genmesh__track_target;
#else
	*a = (enum _genmesh__track_target)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__track_target(struct soap *soap, const enum _genmesh__track_target *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__track_target);
	if (soap_out__genmesh__track_target(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__track_target[] =
{	{ (long)_genmesh__track_target__mesh, "mesh" },
	{ (long)_genmesh__track_target__submesh, "submesh" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__track_target2s(struct soap *soap, enum _genmesh__track_target n)
{	const char *s = soap_code_str(soap_codes__genmesh__track_target, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__track_target(struct soap *soap, const char *tag, int id, const enum _genmesh__track_target *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__track_target), type) || soap_send(soap, soap__genmesh__track_target2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__track_target * SOAP_FMAC4 soap_get__genmesh__track_target(struct soap *soap, enum _genmesh__track_target *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__track_target(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__track_target(struct soap *soap, const char *s, enum _genmesh__track_target *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__track_target, s);
	if (map)
		*a = (enum _genmesh__track_target)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__track_target)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__track_target * SOAP_FMAC4 soap_in__genmesh__track_target(struct soap *soap, const char *tag, enum _genmesh__track_target *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__track_target *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__track_target, sizeof(enum _genmesh__track_target), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__track_target(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__track_target *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__track_target, 0, sizeof(enum _genmesh__track_target), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__pose_target(struct soap *soap, enum _genmesh__pose_target *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__pose_target
	*a = SOAP_DEFAULT__genmesh__pose_target;
#else
	*a = (enum _genmesh__pose_target)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__pose_target(struct soap *soap, const enum _genmesh__pose_target *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__pose_target);
	if (soap_out__genmesh__pose_target(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__pose_target[] =
{	{ (long)_genmesh__pose_target__mesh, "mesh" },
	{ (long)_genmesh__pose_target__submesh, "submesh" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__pose_target2s(struct soap *soap, enum _genmesh__pose_target n)
{	const char *s = soap_code_str(soap_codes__genmesh__pose_target, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__pose_target(struct soap *soap, const char *tag, int id, const enum _genmesh__pose_target *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__pose_target), type) || soap_send(soap, soap__genmesh__pose_target2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__pose_target * SOAP_FMAC4 soap_get__genmesh__pose_target(struct soap *soap, enum _genmesh__pose_target *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__pose_target(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__pose_target(struct soap *soap, const char *s, enum _genmesh__pose_target *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__pose_target, s);
	if (map)
		*a = (enum _genmesh__pose_target)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__pose_target)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__pose_target * SOAP_FMAC4 soap_in__genmesh__pose_target(struct soap *soap, const char *tag, enum _genmesh__pose_target *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__pose_target *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__pose_target, sizeof(enum _genmesh__pose_target), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__pose_target(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__pose_target *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__pose_target, 0, sizeof(enum _genmesh__pose_target), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__vertexbuffer_binormals(struct soap *soap, enum _genmesh__vertexbuffer_binormals *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__vertexbuffer_binormals
	*a = SOAP_DEFAULT__genmesh__vertexbuffer_binormals;
#else
	*a = (enum _genmesh__vertexbuffer_binormals)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__vertexbuffer_binormals(struct soap *soap, const enum _genmesh__vertexbuffer_binormals *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer_binormals);
	if (soap_out__genmesh__vertexbuffer_binormals(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__vertexbuffer_binormals[] =
{	{ (long)_genmesh__vertexbuffer_binormals__true_, "true" },
	{ (long)_genmesh__vertexbuffer_binormals__false_, "false" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__vertexbuffer_binormals2s(struct soap *soap, enum _genmesh__vertexbuffer_binormals n)
{	const char *s = soap_code_str(soap_codes__genmesh__vertexbuffer_binormals, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer_binormals(struct soap *soap, const char *tag, int id, const enum _genmesh__vertexbuffer_binormals *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer_binormals), type) || soap_send(soap, soap__genmesh__vertexbuffer_binormals2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_binormals * SOAP_FMAC4 soap_get__genmesh__vertexbuffer_binormals(struct soap *soap, enum _genmesh__vertexbuffer_binormals *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer_binormals(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__vertexbuffer_binormals(struct soap *soap, const char *s, enum _genmesh__vertexbuffer_binormals *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__vertexbuffer_binormals, s);
	if (map)
		*a = (enum _genmesh__vertexbuffer_binormals)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__vertexbuffer_binormals)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_binormals * SOAP_FMAC4 soap_in__genmesh__vertexbuffer_binormals(struct soap *soap, const char *tag, enum _genmesh__vertexbuffer_binormals *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__vertexbuffer_binormals *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer_binormals, sizeof(enum _genmesh__vertexbuffer_binormals), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__vertexbuffer_binormals(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__vertexbuffer_binormals *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer_binormals, 0, sizeof(enum _genmesh__vertexbuffer_binormals), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__vertexbuffer_tangent_USCOREdimensions(struct soap *soap, enum _genmesh__vertexbuffer_tangent_USCOREdimensions *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__vertexbuffer_tangent_USCOREdimensions
	*a = SOAP_DEFAULT__genmesh__vertexbuffer_tangent_USCOREdimensions;
#else
	*a = (enum _genmesh__vertexbuffer_tangent_USCOREdimensions)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__vertexbuffer_tangent_USCOREdimensions(struct soap *soap, const enum _genmesh__vertexbuffer_tangent_USCOREdimensions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer_tangent_USCOREdimensions);
	if (soap_out__genmesh__vertexbuffer_tangent_USCOREdimensions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__vertexbuffer_tangent_USCOREdimensions[] =
{	{ (long)_genmesh__vertexbuffer_tangent_USCOREdimensions__3, "3" },
	{ (long)_genmesh__vertexbuffer_tangent_USCOREdimensions__4, "4" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__vertexbuffer_tangent_USCOREdimensions2s(struct soap *soap, enum _genmesh__vertexbuffer_tangent_USCOREdimensions n)
{	const char *s = soap_code_str(soap_codes__genmesh__vertexbuffer_tangent_USCOREdimensions, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer_tangent_USCOREdimensions(struct soap *soap, const char *tag, int id, const enum _genmesh__vertexbuffer_tangent_USCOREdimensions *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer_tangent_USCOREdimensions), type) || soap_send(soap, soap__genmesh__vertexbuffer_tangent_USCOREdimensions2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_tangent_USCOREdimensions * SOAP_FMAC4 soap_get__genmesh__vertexbuffer_tangent_USCOREdimensions(struct soap *soap, enum _genmesh__vertexbuffer_tangent_USCOREdimensions *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer_tangent_USCOREdimensions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__vertexbuffer_tangent_USCOREdimensions(struct soap *soap, const char *s, enum _genmesh__vertexbuffer_tangent_USCOREdimensions *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__vertexbuffer_tangent_USCOREdimensions, s);
	if (map)
		*a = (enum _genmesh__vertexbuffer_tangent_USCOREdimensions)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__vertexbuffer_tangent_USCOREdimensions)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_tangent_USCOREdimensions * SOAP_FMAC4 soap_in__genmesh__vertexbuffer_tangent_USCOREdimensions(struct soap *soap, const char *tag, enum _genmesh__vertexbuffer_tangent_USCOREdimensions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__vertexbuffer_tangent_USCOREdimensions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer_tangent_USCOREdimensions, sizeof(enum _genmesh__vertexbuffer_tangent_USCOREdimensions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__vertexbuffer_tangent_USCOREdimensions(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__vertexbuffer_tangent_USCOREdimensions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer_tangent_USCOREdimensions, 0, sizeof(enum _genmesh__vertexbuffer_tangent_USCOREdimensions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__vertexbuffer_tangents(struct soap *soap, enum _genmesh__vertexbuffer_tangents *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__vertexbuffer_tangents
	*a = SOAP_DEFAULT__genmesh__vertexbuffer_tangents;
#else
	*a = (enum _genmesh__vertexbuffer_tangents)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__vertexbuffer_tangents(struct soap *soap, const enum _genmesh__vertexbuffer_tangents *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer_tangents);
	if (soap_out__genmesh__vertexbuffer_tangents(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__vertexbuffer_tangents[] =
{	{ (long)_genmesh__vertexbuffer_tangents__true_, "true" },
	{ (long)_genmesh__vertexbuffer_tangents__false_, "false" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__vertexbuffer_tangents2s(struct soap *soap, enum _genmesh__vertexbuffer_tangents n)
{	const char *s = soap_code_str(soap_codes__genmesh__vertexbuffer_tangents, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer_tangents(struct soap *soap, const char *tag, int id, const enum _genmesh__vertexbuffer_tangents *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer_tangents), type) || soap_send(soap, soap__genmesh__vertexbuffer_tangents2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_tangents * SOAP_FMAC4 soap_get__genmesh__vertexbuffer_tangents(struct soap *soap, enum _genmesh__vertexbuffer_tangents *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer_tangents(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__vertexbuffer_tangents(struct soap *soap, const char *s, enum _genmesh__vertexbuffer_tangents *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__vertexbuffer_tangents, s);
	if (map)
		*a = (enum _genmesh__vertexbuffer_tangents)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__vertexbuffer_tangents)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_tangents * SOAP_FMAC4 soap_in__genmesh__vertexbuffer_tangents(struct soap *soap, const char *tag, enum _genmesh__vertexbuffer_tangents *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__vertexbuffer_tangents *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer_tangents, sizeof(enum _genmesh__vertexbuffer_tangents), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__vertexbuffer_tangents(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__vertexbuffer_tangents *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer_tangents, 0, sizeof(enum _genmesh__vertexbuffer_tangents), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7
	*a = SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7;
#else
	*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7(struct soap *soap, const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7);
	if (soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7[] =
{	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7__0, "0" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7__1, "1" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7__2, "2" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7__3, "3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE72s(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7 n)
{	const char *s = soap_code_str(soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7(struct soap *soap, const char *tag, int id, const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7 *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7), type) || soap_send(soap, soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE72s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7 * SOAP_FMAC4 soap_get__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7 *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7(struct soap *soap, const char *s, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7 *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7, s);
	if (map)
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7 * SOAP_FMAC4 soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7(struct soap *soap, const char *tag, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7, 0, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6
	*a = SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6;
#else
	*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6(struct soap *soap, const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6);
	if (soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6[] =
{	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6__0, "0" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6__1, "1" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6__2, "2" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6__3, "3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE62s(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6 n)
{	const char *s = soap_code_str(soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6(struct soap *soap, const char *tag, int id, const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6 *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6), type) || soap_send(soap, soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE62s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6 * SOAP_FMAC4 soap_get__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6 *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6(struct soap *soap, const char *s, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6 *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6, s);
	if (map)
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6 * SOAP_FMAC4 soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6(struct soap *soap, const char *tag, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6, 0, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5
	*a = SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5;
#else
	*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5(struct soap *soap, const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5);
	if (soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5[] =
{	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5__0, "0" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5__1, "1" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5__2, "2" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5__3, "3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE52s(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5 n)
{	const char *s = soap_code_str(soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5(struct soap *soap, const char *tag, int id, const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5 *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5), type) || soap_send(soap, soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE52s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5 * SOAP_FMAC4 soap_get__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5 *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5(struct soap *soap, const char *s, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5 *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5, s);
	if (map)
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5 * SOAP_FMAC4 soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5(struct soap *soap, const char *tag, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5, 0, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4
	*a = SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4;
#else
	*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4(struct soap *soap, const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4);
	if (soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4[] =
{	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4__0, "0" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4__1, "1" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4__2, "2" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4__3, "3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE42s(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4 n)
{	const char *s = soap_code_str(soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4(struct soap *soap, const char *tag, int id, const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4 *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4), type) || soap_send(soap, soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE42s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4 * SOAP_FMAC4 soap_get__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4 *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4(struct soap *soap, const char *s, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4 *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4, s);
	if (map)
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4 * SOAP_FMAC4 soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4(struct soap *soap, const char *tag, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4, 0, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3
	*a = SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3;
#else
	*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3(struct soap *soap, const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3);
	if (soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3[] =
{	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3__0, "0" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3__1, "1" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3__2, "2" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3__3, "3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE32s(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3 n)
{	const char *s = soap_code_str(soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3(struct soap *soap, const char *tag, int id, const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3 *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3), type) || soap_send(soap, soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE32s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3 * SOAP_FMAC4 soap_get__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3 *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3(struct soap *soap, const char *s, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3 *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3, s);
	if (map)
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3 * SOAP_FMAC4 soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3(struct soap *soap, const char *tag, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3, 0, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2
	*a = SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2;
#else
	*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2(struct soap *soap, const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2);
	if (soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2[] =
{	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2__0, "0" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2__1, "1" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2__2, "2" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2__3, "3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE22s(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2 n)
{	const char *s = soap_code_str(soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2(struct soap *soap, const char *tag, int id, const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2 *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2), type) || soap_send(soap, soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE22s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2 * SOAP_FMAC4 soap_get__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2 *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2(struct soap *soap, const char *s, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2 *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2, s);
	if (map)
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2 * SOAP_FMAC4 soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2(struct soap *soap, const char *tag, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2, 0, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1
	*a = SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1;
#else
	*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1(struct soap *soap, const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1);
	if (soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1[] =
{	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1__0, "0" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1__1, "1" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1__2, "2" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1__3, "3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE12s(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1 n)
{	const char *s = soap_code_str(soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1(struct soap *soap, const char *tag, int id, const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1 *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1), type) || soap_send(soap, soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE12s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1 * SOAP_FMAC4 soap_get__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1 *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1(struct soap *soap, const char *s, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1 *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1, s);
	if (map)
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1 * SOAP_FMAC4 soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1(struct soap *soap, const char *tag, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1, 0, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0 *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0
	*a = SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0;
#else
	*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0(struct soap *soap, const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0 *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0);
	if (soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0[] =
{	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0__0, "0" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0__1, "1" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0__2, "2" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0__3, "3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE02s(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0 n)
{	const char *s = soap_code_str(soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0(struct soap *soap, const char *tag, int id, const enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0 *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0), type) || soap_send(soap, soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE02s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0 * SOAP_FMAC4 soap_get__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0 *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0(struct soap *soap, const char *s, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0 *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0, s);
	if (map)
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0 * SOAP_FMAC4 soap_in__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0(struct soap *soap, const char *tag, enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0 *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0 *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0 *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0, 0, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__vertexbuffer_texture_USCOREcoords(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoords *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoords
	*a = SOAP_DEFAULT__genmesh__vertexbuffer_texture_USCOREcoords;
#else
	*a = (enum _genmesh__vertexbuffer_texture_USCOREcoords)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__vertexbuffer_texture_USCOREcoords(struct soap *soap, const enum _genmesh__vertexbuffer_texture_USCOREcoords *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoords);
	if (soap_out__genmesh__vertexbuffer_texture_USCOREcoords(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__vertexbuffer_texture_USCOREcoords[] =
{	{ (long)_genmesh__vertexbuffer_texture_USCOREcoords__0, "0" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoords__1, "1" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoords__2, "2" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoords__3, "3" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoords__4, "4" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoords__5, "5" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoords__6, "6" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoords__7, "7" },
	{ (long)_genmesh__vertexbuffer_texture_USCOREcoords__8, "8" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__vertexbuffer_texture_USCOREcoords2s(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoords n)
{	const char *s = soap_code_str(soap_codes__genmesh__vertexbuffer_texture_USCOREcoords, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer_texture_USCOREcoords(struct soap *soap, const char *tag, int id, const enum _genmesh__vertexbuffer_texture_USCOREcoords *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoords), type) || soap_send(soap, soap__genmesh__vertexbuffer_texture_USCOREcoords2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoords * SOAP_FMAC4 soap_get__genmesh__vertexbuffer_texture_USCOREcoords(struct soap *soap, enum _genmesh__vertexbuffer_texture_USCOREcoords *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer_texture_USCOREcoords(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__vertexbuffer_texture_USCOREcoords(struct soap *soap, const char *s, enum _genmesh__vertexbuffer_texture_USCOREcoords *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__vertexbuffer_texture_USCOREcoords, s);
	if (map)
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoords)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 8)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__vertexbuffer_texture_USCOREcoords)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_texture_USCOREcoords * SOAP_FMAC4 soap_in__genmesh__vertexbuffer_texture_USCOREcoords(struct soap *soap, const char *tag, enum _genmesh__vertexbuffer_texture_USCOREcoords *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__vertexbuffer_texture_USCOREcoords *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoords, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoords), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__vertexbuffer_texture_USCOREcoords(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__vertexbuffer_texture_USCOREcoords *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer_texture_USCOREcoords, 0, sizeof(enum _genmesh__vertexbuffer_texture_USCOREcoords), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__vertexbuffer_colours_USCOREspecular(struct soap *soap, enum _genmesh__vertexbuffer_colours_USCOREspecular *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__vertexbuffer_colours_USCOREspecular
	*a = SOAP_DEFAULT__genmesh__vertexbuffer_colours_USCOREspecular;
#else
	*a = (enum _genmesh__vertexbuffer_colours_USCOREspecular)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__vertexbuffer_colours_USCOREspecular(struct soap *soap, const enum _genmesh__vertexbuffer_colours_USCOREspecular *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREspecular);
	if (soap_out__genmesh__vertexbuffer_colours_USCOREspecular(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__vertexbuffer_colours_USCOREspecular[] =
{	{ (long)_genmesh__vertexbuffer_colours_USCOREspecular__true_, "true" },
	{ (long)_genmesh__vertexbuffer_colours_USCOREspecular__false_, "false" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__vertexbuffer_colours_USCOREspecular2s(struct soap *soap, enum _genmesh__vertexbuffer_colours_USCOREspecular n)
{	const char *s = soap_code_str(soap_codes__genmesh__vertexbuffer_colours_USCOREspecular, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer_colours_USCOREspecular(struct soap *soap, const char *tag, int id, const enum _genmesh__vertexbuffer_colours_USCOREspecular *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREspecular), type) || soap_send(soap, soap__genmesh__vertexbuffer_colours_USCOREspecular2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_colours_USCOREspecular * SOAP_FMAC4 soap_get__genmesh__vertexbuffer_colours_USCOREspecular(struct soap *soap, enum _genmesh__vertexbuffer_colours_USCOREspecular *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer_colours_USCOREspecular(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__vertexbuffer_colours_USCOREspecular(struct soap *soap, const char *s, enum _genmesh__vertexbuffer_colours_USCOREspecular *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__vertexbuffer_colours_USCOREspecular, s);
	if (map)
		*a = (enum _genmesh__vertexbuffer_colours_USCOREspecular)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__vertexbuffer_colours_USCOREspecular)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_colours_USCOREspecular * SOAP_FMAC4 soap_in__genmesh__vertexbuffer_colours_USCOREspecular(struct soap *soap, const char *tag, enum _genmesh__vertexbuffer_colours_USCOREspecular *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__vertexbuffer_colours_USCOREspecular *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREspecular, sizeof(enum _genmesh__vertexbuffer_colours_USCOREspecular), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__vertexbuffer_colours_USCOREspecular(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__vertexbuffer_colours_USCOREspecular *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREspecular, 0, sizeof(enum _genmesh__vertexbuffer_colours_USCOREspecular), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__vertexbuffer_colours_USCOREdiffuse(struct soap *soap, enum _genmesh__vertexbuffer_colours_USCOREdiffuse *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__vertexbuffer_colours_USCOREdiffuse
	*a = SOAP_DEFAULT__genmesh__vertexbuffer_colours_USCOREdiffuse;
#else
	*a = (enum _genmesh__vertexbuffer_colours_USCOREdiffuse)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__vertexbuffer_colours_USCOREdiffuse(struct soap *soap, const enum _genmesh__vertexbuffer_colours_USCOREdiffuse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREdiffuse);
	if (soap_out__genmesh__vertexbuffer_colours_USCOREdiffuse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__vertexbuffer_colours_USCOREdiffuse[] =
{	{ (long)_genmesh__vertexbuffer_colours_USCOREdiffuse__true_, "true" },
	{ (long)_genmesh__vertexbuffer_colours_USCOREdiffuse__false_, "false" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__vertexbuffer_colours_USCOREdiffuse2s(struct soap *soap, enum _genmesh__vertexbuffer_colours_USCOREdiffuse n)
{	const char *s = soap_code_str(soap_codes__genmesh__vertexbuffer_colours_USCOREdiffuse, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer_colours_USCOREdiffuse(struct soap *soap, const char *tag, int id, const enum _genmesh__vertexbuffer_colours_USCOREdiffuse *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREdiffuse), type) || soap_send(soap, soap__genmesh__vertexbuffer_colours_USCOREdiffuse2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_colours_USCOREdiffuse * SOAP_FMAC4 soap_get__genmesh__vertexbuffer_colours_USCOREdiffuse(struct soap *soap, enum _genmesh__vertexbuffer_colours_USCOREdiffuse *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer_colours_USCOREdiffuse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__vertexbuffer_colours_USCOREdiffuse(struct soap *soap, const char *s, enum _genmesh__vertexbuffer_colours_USCOREdiffuse *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__vertexbuffer_colours_USCOREdiffuse, s);
	if (map)
		*a = (enum _genmesh__vertexbuffer_colours_USCOREdiffuse)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__vertexbuffer_colours_USCOREdiffuse)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_colours_USCOREdiffuse * SOAP_FMAC4 soap_in__genmesh__vertexbuffer_colours_USCOREdiffuse(struct soap *soap, const char *tag, enum _genmesh__vertexbuffer_colours_USCOREdiffuse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__vertexbuffer_colours_USCOREdiffuse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREdiffuse, sizeof(enum _genmesh__vertexbuffer_colours_USCOREdiffuse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__vertexbuffer_colours_USCOREdiffuse(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__vertexbuffer_colours_USCOREdiffuse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer_colours_USCOREdiffuse, 0, sizeof(enum _genmesh__vertexbuffer_colours_USCOREdiffuse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__vertexbuffer_normals(struct soap *soap, enum _genmesh__vertexbuffer_normals *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__vertexbuffer_normals
	*a = SOAP_DEFAULT__genmesh__vertexbuffer_normals;
#else
	*a = (enum _genmesh__vertexbuffer_normals)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__vertexbuffer_normals(struct soap *soap, const enum _genmesh__vertexbuffer_normals *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer_normals);
	if (soap_out__genmesh__vertexbuffer_normals(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__vertexbuffer_normals[] =
{	{ (long)_genmesh__vertexbuffer_normals__true_, "true" },
	{ (long)_genmesh__vertexbuffer_normals__false_, "false" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__vertexbuffer_normals2s(struct soap *soap, enum _genmesh__vertexbuffer_normals n)
{	const char *s = soap_code_str(soap_codes__genmesh__vertexbuffer_normals, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer_normals(struct soap *soap, const char *tag, int id, const enum _genmesh__vertexbuffer_normals *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer_normals), type) || soap_send(soap, soap__genmesh__vertexbuffer_normals2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_normals * SOAP_FMAC4 soap_get__genmesh__vertexbuffer_normals(struct soap *soap, enum _genmesh__vertexbuffer_normals *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer_normals(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__vertexbuffer_normals(struct soap *soap, const char *s, enum _genmesh__vertexbuffer_normals *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__vertexbuffer_normals, s);
	if (map)
		*a = (enum _genmesh__vertexbuffer_normals)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__vertexbuffer_normals)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_normals * SOAP_FMAC4 soap_in__genmesh__vertexbuffer_normals(struct soap *soap, const char *tag, enum _genmesh__vertexbuffer_normals *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__vertexbuffer_normals *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer_normals, sizeof(enum _genmesh__vertexbuffer_normals), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__vertexbuffer_normals(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__vertexbuffer_normals *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer_normals, 0, sizeof(enum _genmesh__vertexbuffer_normals), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__vertexbuffer_positions(struct soap *soap, enum _genmesh__vertexbuffer_positions *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__vertexbuffer_positions
	*a = SOAP_DEFAULT__genmesh__vertexbuffer_positions;
#else
	*a = (enum _genmesh__vertexbuffer_positions)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__vertexbuffer_positions(struct soap *soap, const enum _genmesh__vertexbuffer_positions *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer_positions);
	if (soap_out__genmesh__vertexbuffer_positions(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__vertexbuffer_positions[] =
{	{ (long)_genmesh__vertexbuffer_positions__true_, "true" },
	{ (long)_genmesh__vertexbuffer_positions__false_, "false" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__vertexbuffer_positions2s(struct soap *soap, enum _genmesh__vertexbuffer_positions n)
{	const char *s = soap_code_str(soap_codes__genmesh__vertexbuffer_positions, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer_positions(struct soap *soap, const char *tag, int id, const enum _genmesh__vertexbuffer_positions *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer_positions), type) || soap_send(soap, soap__genmesh__vertexbuffer_positions2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_positions * SOAP_FMAC4 soap_get__genmesh__vertexbuffer_positions(struct soap *soap, enum _genmesh__vertexbuffer_positions *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer_positions(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__vertexbuffer_positions(struct soap *soap, const char *s, enum _genmesh__vertexbuffer_positions *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__vertexbuffer_positions, s);
	if (map)
		*a = (enum _genmesh__vertexbuffer_positions)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__vertexbuffer_positions)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__vertexbuffer_positions * SOAP_FMAC4 soap_in__genmesh__vertexbuffer_positions(struct soap *soap, const char *tag, enum _genmesh__vertexbuffer_positions *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__vertexbuffer_positions *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer_positions, sizeof(enum _genmesh__vertexbuffer_positions), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__vertexbuffer_positions(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__vertexbuffer_positions *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer_positions, 0, sizeof(enum _genmesh__vertexbuffer_positions), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__levelofdetail_manual(struct soap *soap, enum _genmesh__levelofdetail_manual *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__levelofdetail_manual
	*a = SOAP_DEFAULT__genmesh__levelofdetail_manual;
#else
	*a = (enum _genmesh__levelofdetail_manual)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__levelofdetail_manual(struct soap *soap, const enum _genmesh__levelofdetail_manual *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__levelofdetail_manual);
	if (soap_out__genmesh__levelofdetail_manual(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__levelofdetail_manual[] =
{	{ (long)_genmesh__levelofdetail_manual__true_, "true" },
	{ (long)_genmesh__levelofdetail_manual__false_, "false" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__levelofdetail_manual2s(struct soap *soap, enum _genmesh__levelofdetail_manual n)
{	const char *s = soap_code_str(soap_codes__genmesh__levelofdetail_manual, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__levelofdetail_manual(struct soap *soap, const char *tag, int id, const enum _genmesh__levelofdetail_manual *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__levelofdetail_manual), type) || soap_send(soap, soap__genmesh__levelofdetail_manual2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__levelofdetail_manual * SOAP_FMAC4 soap_get__genmesh__levelofdetail_manual(struct soap *soap, enum _genmesh__levelofdetail_manual *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__levelofdetail_manual(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__levelofdetail_manual(struct soap *soap, const char *s, enum _genmesh__levelofdetail_manual *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__levelofdetail_manual, s);
	if (map)
		*a = (enum _genmesh__levelofdetail_manual)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__levelofdetail_manual)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__levelofdetail_manual * SOAP_FMAC4 soap_in__genmesh__levelofdetail_manual(struct soap *soap, const char *tag, enum _genmesh__levelofdetail_manual *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__levelofdetail_manual *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__levelofdetail_manual, sizeof(enum _genmesh__levelofdetail_manual), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__levelofdetail_manual(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__levelofdetail_manual *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__levelofdetail_manual, 0, sizeof(enum _genmesh__levelofdetail_manual), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__submesh_operationtype(struct soap *soap, enum _genmesh__submesh_operationtype *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__submesh_operationtype
	*a = SOAP_DEFAULT__genmesh__submesh_operationtype;
#else
	*a = (enum _genmesh__submesh_operationtype)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__submesh_operationtype(struct soap *soap, const enum _genmesh__submesh_operationtype *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__submesh_operationtype);
	if (soap_out__genmesh__submesh_operationtype(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__submesh_operationtype[] =
{	{ (long)_genmesh__submesh_operationtype__triangle_USCORElist, "triangle_list" },
	{ (long)_genmesh__submesh_operationtype__triangle_USCOREstrip, "triangle_strip" },
	{ (long)_genmesh__submesh_operationtype__triangle_USCOREfan, "triangle_fan" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__submesh_operationtype2s(struct soap *soap, enum _genmesh__submesh_operationtype n)
{	const char *s = soap_code_str(soap_codes__genmesh__submesh_operationtype, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__submesh_operationtype(struct soap *soap, const char *tag, int id, const enum _genmesh__submesh_operationtype *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__submesh_operationtype), type) || soap_send(soap, soap__genmesh__submesh_operationtype2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__submesh_operationtype * SOAP_FMAC4 soap_get__genmesh__submesh_operationtype(struct soap *soap, enum _genmesh__submesh_operationtype *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__submesh_operationtype(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__submesh_operationtype(struct soap *soap, const char *s, enum _genmesh__submesh_operationtype *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__submesh_operationtype, s);
	if (map)
		*a = (enum _genmesh__submesh_operationtype)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__submesh_operationtype)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__submesh_operationtype * SOAP_FMAC4 soap_in__genmesh__submesh_operationtype(struct soap *soap, const char *tag, enum _genmesh__submesh_operationtype *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__submesh_operationtype *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__submesh_operationtype, sizeof(enum _genmesh__submesh_operationtype), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__submesh_operationtype(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__submesh_operationtype *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__submesh_operationtype, 0, sizeof(enum _genmesh__submesh_operationtype), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__submesh_use32bitindexes(struct soap *soap, enum _genmesh__submesh_use32bitindexes *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__submesh_use32bitindexes
	*a = SOAP_DEFAULT__genmesh__submesh_use32bitindexes;
#else
	*a = (enum _genmesh__submesh_use32bitindexes)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__submesh_use32bitindexes(struct soap *soap, const enum _genmesh__submesh_use32bitindexes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__submesh_use32bitindexes);
	if (soap_out__genmesh__submesh_use32bitindexes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__submesh_use32bitindexes[] =
{	{ (long)_genmesh__submesh_use32bitindexes__true_, "true" },
	{ (long)_genmesh__submesh_use32bitindexes__false_, "false" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__submesh_use32bitindexes2s(struct soap *soap, enum _genmesh__submesh_use32bitindexes n)
{	const char *s = soap_code_str(soap_codes__genmesh__submesh_use32bitindexes, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__submesh_use32bitindexes(struct soap *soap, const char *tag, int id, const enum _genmesh__submesh_use32bitindexes *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__submesh_use32bitindexes), type) || soap_send(soap, soap__genmesh__submesh_use32bitindexes2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__submesh_use32bitindexes * SOAP_FMAC4 soap_get__genmesh__submesh_use32bitindexes(struct soap *soap, enum _genmesh__submesh_use32bitindexes *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__submesh_use32bitindexes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__submesh_use32bitindexes(struct soap *soap, const char *s, enum _genmesh__submesh_use32bitindexes *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__submesh_use32bitindexes, s);
	if (map)
		*a = (enum _genmesh__submesh_use32bitindexes)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__submesh_use32bitindexes)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__submesh_use32bitindexes * SOAP_FMAC4 soap_in__genmesh__submesh_use32bitindexes(struct soap *soap, const char *tag, enum _genmesh__submesh_use32bitindexes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__submesh_use32bitindexes *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__submesh_use32bitindexes, sizeof(enum _genmesh__submesh_use32bitindexes), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__submesh_use32bitindexes(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__submesh_use32bitindexes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__submesh_use32bitindexes, 0, sizeof(enum _genmesh__submesh_use32bitindexes), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__genmesh__submesh_usesharedvertices(struct soap *soap, enum _genmesh__submesh_usesharedvertices *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT__genmesh__submesh_usesharedvertices
	*a = SOAP_DEFAULT__genmesh__submesh_usesharedvertices;
#else
	*a = (enum _genmesh__submesh_usesharedvertices)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__genmesh__submesh_usesharedvertices(struct soap *soap, const enum _genmesh__submesh_usesharedvertices *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__genmesh__submesh_usesharedvertices);
	if (soap_out__genmesh__submesh_usesharedvertices(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes__genmesh__submesh_usesharedvertices[] =
{	{ (long)_genmesh__submesh_usesharedvertices__true_, "true" },
	{ (long)_genmesh__submesh_usesharedvertices__false_, "false" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap__genmesh__submesh_usesharedvertices2s(struct soap *soap, enum _genmesh__submesh_usesharedvertices n)
{	const char *s = soap_code_str(soap_codes__genmesh__submesh_usesharedvertices, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__submesh_usesharedvertices(struct soap *soap, const char *tag, int id, const enum _genmesh__submesh_usesharedvertices *a, const char *type)
{	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__submesh_usesharedvertices), type) || soap_send(soap, soap__genmesh__submesh_usesharedvertices2s(soap, *a)))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum _genmesh__submesh_usesharedvertices * SOAP_FMAC4 soap_get__genmesh__submesh_usesharedvertices(struct soap *soap, enum _genmesh__submesh_usesharedvertices *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__submesh_usesharedvertices(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2_genmesh__submesh_usesharedvertices(struct soap *soap, const char *s, enum _genmesh__submesh_usesharedvertices *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes__genmesh__submesh_usesharedvertices, s);
	if (map)
		*a = (enum _genmesh__submesh_usesharedvertices)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum _genmesh__submesh_usesharedvertices)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum _genmesh__submesh_usesharedvertices * SOAP_FMAC4 soap_in__genmesh__submesh_usesharedvertices(struct soap *soap, const char *tag, enum _genmesh__submesh_usesharedvertices *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum _genmesh__submesh_usesharedvertices *)soap_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__submesh_usesharedvertices, sizeof(enum _genmesh__submesh_usesharedvertices), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2_genmesh__submesh_usesharedvertices(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum _genmesh__submesh_usesharedvertices *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__submesh_usesharedvertices, 0, sizeof(enum _genmesh__submesh_usesharedvertices), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void __genmesh__lodfacelist_sequence::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__genmesh__lodfacelist_sequence::genmesh__face = NULL;
}

void __genmesh__lodfacelist_sequence::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_genmesh__face(soap, &this->__genmesh__lodfacelist_sequence::genmesh__face);
}

int __genmesh__lodfacelist_sequence::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return SOAP_OK;
}

int __genmesh__lodfacelist_sequence::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___genmesh__lodfacelist_sequence(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___genmesh__lodfacelist_sequence(struct soap *soap, const char *tag, int id, const __genmesh__lodfacelist_sequence *a, const char *type)
{
	if (soap_out_PointerTo_genmesh__face(soap, "genmesh:face", -1, &(a->__genmesh__lodfacelist_sequence::genmesh__face), ""))
		return soap->error;
	return SOAP_OK;
}

void *__genmesh__lodfacelist_sequence::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___genmesh__lodfacelist_sequence(soap, this, tag, type);
}

SOAP_FMAC3 __genmesh__lodfacelist_sequence * SOAP_FMAC4 soap_get___genmesh__lodfacelist_sequence(struct soap *soap, __genmesh__lodfacelist_sequence *p, const char *tag, const char *type)
{
	if ((p = soap_in___genmesh__lodfacelist_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *__genmesh__lodfacelist_sequence::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___genmesh__lodfacelist_sequence(soap, tag, this, type);
}

SOAP_FMAC3 __genmesh__lodfacelist_sequence * SOAP_FMAC4 soap_in___genmesh__lodfacelist_sequence(struct soap *soap, const char *tag, __genmesh__lodfacelist_sequence *a, const char *type)
{
	a = (__genmesh__lodfacelist_sequence *)soap_class_id_enter(soap, "", a, SOAP_TYPE___genmesh__lodfacelist_sequence, sizeof(__genmesh__lodfacelist_sequence), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE___genmesh__lodfacelist_sequence)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (__genmesh__lodfacelist_sequence *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_genmesh__face1 = 1;
		for (short soap_flag = 0;; soap_flag = 1)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genmesh__face1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__face(soap, "genmesh:face", &(a->__genmesh__lodfacelist_sequence::genmesh__face), ""))
				{	soap_flag_genmesh__face1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
			if (soap_flag)
				{
					soap->error = SOAP_OK;
					break;
				}
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genmesh__face1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 __genmesh__lodfacelist_sequence * SOAP_FMAC6 soap_new___genmesh__lodfacelist_sequence(struct soap *soap, int n)
{	return soap_instantiate___genmesh__lodfacelist_sequence(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___genmesh__lodfacelist_sequence(struct soap *soap, __genmesh__lodfacelist_sequence *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 __genmesh__lodfacelist_sequence * SOAP_FMAC4 soap_instantiate___genmesh__lodfacelist_sequence(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___genmesh__lodfacelist_sequence(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___genmesh__lodfacelist_sequence, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new __genmesh__lodfacelist_sequence;
		if (size)
			*size = sizeof(__genmesh__lodfacelist_sequence);
	}
	else
	{	cp->ptr = (void*)new __genmesh__lodfacelist_sequence[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__genmesh__lodfacelist_sequence);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__genmesh__lodfacelist_sequence*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___genmesh__lodfacelist_sequence(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __genmesh__lodfacelist_sequence %p -> %p\n", q, p));
	*(__genmesh__lodfacelist_sequence*)p = *(__genmesh__lodfacelist_sequence*)q;
}

void __genmesh__union_levelofdetail::soap_default(struct soap *soap)
{
	(void)soap; /* appease -Wall -Werror */
	this->__genmesh__union_levelofdetail::__union_levelofdetail = 0;
}

void __genmesh__union_levelofdetail::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize__genmesh__union_levelofdetail(soap, this->__genmesh__union_levelofdetail::__union_levelofdetail, &this->__genmesh__union_levelofdetail::union_levelofdetail);
}

int __genmesh__union_levelofdetail::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = 0;
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return SOAP_OK;
}

int __genmesh__union_levelofdetail::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out___genmesh__union_levelofdetail(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out___genmesh__union_levelofdetail(struct soap *soap, const char *tag, int id, const __genmesh__union_levelofdetail *a, const char *type)
{
	if (soap_out__genmesh__union_levelofdetail(soap, a->__genmesh__union_levelofdetail::__union_levelofdetail, &a->__genmesh__union_levelofdetail::union_levelofdetail))
		return soap->error;
	return SOAP_OK;
}

void *__genmesh__union_levelofdetail::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get___genmesh__union_levelofdetail(soap, this, tag, type);
}

SOAP_FMAC3 __genmesh__union_levelofdetail * SOAP_FMAC4 soap_get___genmesh__union_levelofdetail(struct soap *soap, __genmesh__union_levelofdetail *p, const char *tag, const char *type)
{
	if ((p = soap_in___genmesh__union_levelofdetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *__genmesh__union_levelofdetail::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in___genmesh__union_levelofdetail(soap, tag, this, type);
}

SOAP_FMAC3 __genmesh__union_levelofdetail * SOAP_FMAC4 soap_in___genmesh__union_levelofdetail(struct soap *soap, const char *tag, __genmesh__union_levelofdetail *a, const char *type)
{
	a = (__genmesh__union_levelofdetail *)soap_class_id_enter(soap, "", a, SOAP_TYPE___genmesh__union_levelofdetail, sizeof(__genmesh__union_levelofdetail), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE___genmesh__union_levelofdetail)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (__genmesh__union_levelofdetail *)a->soap_in(soap, tag, type);
		}
	}
		if (!soap_in__genmesh__union_levelofdetail(soap, &a->__union_levelofdetail, &a->union_levelofdetail))
			return NULL;
	return a;
}

SOAP_FMAC5 __genmesh__union_levelofdetail * SOAP_FMAC6 soap_new___genmesh__union_levelofdetail(struct soap *soap, int n)
{	return soap_instantiate___genmesh__union_levelofdetail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete___genmesh__union_levelofdetail(struct soap *soap, __genmesh__union_levelofdetail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 __genmesh__union_levelofdetail * SOAP_FMAC4 soap_instantiate___genmesh__union_levelofdetail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate___genmesh__union_levelofdetail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE___genmesh__union_levelofdetail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new __genmesh__union_levelofdetail;
		if (size)
			*size = sizeof(__genmesh__union_levelofdetail);
	}
	else
	{	cp->ptr = (void*)new __genmesh__union_levelofdetail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(__genmesh__union_levelofdetail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (__genmesh__union_levelofdetail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy___genmesh__union_levelofdetail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying __genmesh__union_levelofdetail %p -> %p\n", q, p));
	*(__genmesh__union_levelofdetail*)p = *(__genmesh__union_levelofdetail*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}

void _genskel__animationlink::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genskel__animationlink::skeletonName);
	this->_genskel__animationlink::scale = "1.0";
	/* transient soap skipped */
}

void _genskel__animationlink::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genskel__animationlink::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genskel__animationlink);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genskel__animationlink::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genskel__animationlink(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genskel__animationlink(struct soap *soap, const char *tag, int id, const _genskel__animationlink *a, const char *type)
{
	if (!((_genskel__animationlink *)a)->skeletonName.empty())
		soap_set_attr(soap, "skeletonName", ((_genskel__animationlink *)a)->skeletonName.c_str());
	if (!((_genskel__animationlink *)a)->scale.empty())
		soap_set_attr(soap, "scale", ((_genskel__animationlink *)a)->scale.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genskel__animationlink), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genskel__animationlink::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genskel__animationlink(soap, this, tag, type);
}

SOAP_FMAC3 _genskel__animationlink * SOAP_FMAC4 soap_get__genskel__animationlink(struct soap *soap, _genskel__animationlink *p, const char *tag, const char *type)
{
	if ((p = soap_in__genskel__animationlink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genskel__animationlink::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genskel__animationlink(soap, tag, this, type);
}

SOAP_FMAC3 _genskel__animationlink * SOAP_FMAC4 soap_in__genskel__animationlink(struct soap *soap, const char *tag, _genskel__animationlink *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genskel__animationlink *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genskel__animationlink, sizeof(_genskel__animationlink), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genskel__animationlink)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genskel__animationlink *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "skeletonName", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genskel__animationlink *)a)->skeletonName.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "scale", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genskel__animationlink *)a)->scale.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genskel__animationlink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genskel__animationlink, 0, sizeof(_genskel__animationlink), 0, soap_copy__genskel__animationlink);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genskel__animationlink * SOAP_FMAC6 soap_new__genskel__animationlink(struct soap *soap, int n)
{	return soap_instantiate__genskel__animationlink(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genskel__animationlink(struct soap *soap, _genskel__animationlink *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genskel__animationlink * SOAP_FMAC4 soap_instantiate__genskel__animationlink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genskel__animationlink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genskel__animationlink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genskel__animationlink;
		if (size)
			*size = sizeof(_genskel__animationlink);
		((_genskel__animationlink*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genskel__animationlink[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genskel__animationlink);
		for (int i = 0; i < n; i++)
			((_genskel__animationlink*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genskel__animationlink*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genskel__animationlink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genskel__animationlink %p -> %p\n", q, p));
	*(_genskel__animationlink*)p = *(_genskel__animationlink*)q;
}

void _genskel__animationlinks::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genskel__animationlink(soap, &this->_genskel__animationlinks::genskel__animationlink);
	/* transient soap skipped */
}

void _genskel__animationlinks::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genskel__animationlink(soap, &this->_genskel__animationlinks::genskel__animationlink);
	/* transient soap skipped */
}

int _genskel__animationlinks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genskel__animationlinks);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genskel__animationlinks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genskel__animationlinks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genskel__animationlinks(struct soap *soap, const char *tag, int id, const _genskel__animationlinks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genskel__animationlinks), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genskel__animationlink(soap, "genskel:animationlink", -1, &(a->_genskel__animationlinks::genskel__animationlink), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genskel__animationlinks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genskel__animationlinks(soap, this, tag, type);
}

SOAP_FMAC3 _genskel__animationlinks * SOAP_FMAC4 soap_get__genskel__animationlinks(struct soap *soap, _genskel__animationlinks *p, const char *tag, const char *type)
{
	if ((p = soap_in__genskel__animationlinks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genskel__animationlinks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genskel__animationlinks(soap, tag, this, type);
}

SOAP_FMAC3 _genskel__animationlinks * SOAP_FMAC4 soap_in__genskel__animationlinks(struct soap *soap, const char *tag, _genskel__animationlinks *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genskel__animationlinks *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genskel__animationlinks, sizeof(_genskel__animationlinks), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genskel__animationlinks)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genskel__animationlinks *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genskel__animationlink(soap, "genskel:animationlink", &(a->_genskel__animationlinks::genskel__animationlink), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genskel__animationlinks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genskel__animationlinks, 0, sizeof(_genskel__animationlinks), 0, soap_copy__genskel__animationlinks);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genskel__animationlinks * SOAP_FMAC6 soap_new__genskel__animationlinks(struct soap *soap, int n)
{	return soap_instantiate__genskel__animationlinks(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genskel__animationlinks(struct soap *soap, _genskel__animationlinks *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genskel__animationlinks * SOAP_FMAC4 soap_instantiate__genskel__animationlinks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genskel__animationlinks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genskel__animationlinks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genskel__animationlinks;
		if (size)
			*size = sizeof(_genskel__animationlinks);
		((_genskel__animationlinks*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genskel__animationlinks[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genskel__animationlinks);
		for (int i = 0; i < n; i++)
			((_genskel__animationlinks*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genskel__animationlinks*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genskel__animationlinks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genskel__animationlinks %p -> %p\n", q, p));
	*(_genskel__animationlinks*)p = *(_genskel__animationlinks*)q;
}

void _genskel__rotate::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_genskel__rotate::axis = NULL;
	soap_default_std__string(soap, &this->_genskel__rotate::angle);
	/* transient soap skipped */
}

void _genskel__rotate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTogenskel__axis(soap, &this->_genskel__rotate::axis);
	/* transient soap skipped */
}

int _genskel__rotate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genskel__rotate);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genskel__rotate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genskel__rotate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genskel__rotate(struct soap *soap, const char *tag, int id, const _genskel__rotate *a, const char *type)
{
	if (!((_genskel__rotate *)a)->angle.empty())
		soap_set_attr(soap, "angle", ((_genskel__rotate *)a)->angle.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genskel__rotate), type))
		return soap->error;
	if (soap_out_PointerTogenskel__axis(soap, "genskel:axis", -1, &(a->_genskel__rotate::axis), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genskel__rotate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genskel__rotate(soap, this, tag, type);
}

SOAP_FMAC3 _genskel__rotate * SOAP_FMAC4 soap_get__genskel__rotate(struct soap *soap, _genskel__rotate *p, const char *tag, const char *type)
{
	if ((p = soap_in__genskel__rotate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genskel__rotate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genskel__rotate(soap, tag, this, type);
}

SOAP_FMAC3 _genskel__rotate * SOAP_FMAC4 soap_in__genskel__rotate(struct soap *soap, const char *tag, _genskel__rotate *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genskel__rotate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genskel__rotate, sizeof(_genskel__rotate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genskel__rotate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genskel__rotate *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "angle", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genskel__rotate *)a)->angle.assign(s);
		}
	}
	short soap_flag_axis1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_axis1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogenskel__axis(soap, "genskel:axis", &(a->_genskel__rotate::axis), "genskel:axis"))
				{	soap_flag_axis1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genskel__rotate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genskel__rotate, 0, sizeof(_genskel__rotate), 0, soap_copy__genskel__rotate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_axis1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _genskel__rotate * SOAP_FMAC6 soap_new__genskel__rotate(struct soap *soap, int n)
{	return soap_instantiate__genskel__rotate(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genskel__rotate(struct soap *soap, _genskel__rotate *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genskel__rotate * SOAP_FMAC4 soap_instantiate__genskel__rotate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genskel__rotate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genskel__rotate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genskel__rotate;
		if (size)
			*size = sizeof(_genskel__rotate);
		((_genskel__rotate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genskel__rotate[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genskel__rotate);
		for (int i = 0; i < n; i++)
			((_genskel__rotate*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genskel__rotate*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genskel__rotate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genskel__rotate %p -> %p\n", q, p));
	*(_genskel__rotate*)p = *(_genskel__rotate*)q;
}

void _genskel__translate::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genskel__translate::x);
	soap_default_std__string(soap, &this->_genskel__translate::y);
	soap_default_std__string(soap, &this->_genskel__translate::z);
	/* transient soap skipped */
}

void _genskel__translate::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genskel__translate::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genskel__translate);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genskel__translate::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genskel__translate(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genskel__translate(struct soap *soap, const char *tag, int id, const _genskel__translate *a, const char *type)
{
	if (!((_genskel__translate *)a)->x.empty())
		soap_set_attr(soap, "x", ((_genskel__translate *)a)->x.c_str());
	if (!((_genskel__translate *)a)->y.empty())
		soap_set_attr(soap, "y", ((_genskel__translate *)a)->y.c_str());
	if (!((_genskel__translate *)a)->z.empty())
		soap_set_attr(soap, "z", ((_genskel__translate *)a)->z.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genskel__translate), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genskel__translate::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genskel__translate(soap, this, tag, type);
}

SOAP_FMAC3 _genskel__translate * SOAP_FMAC4 soap_get__genskel__translate(struct soap *soap, _genskel__translate *p, const char *tag, const char *type)
{
	if ((p = soap_in__genskel__translate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genskel__translate::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genskel__translate(soap, tag, this, type);
}

SOAP_FMAC3 _genskel__translate * SOAP_FMAC4 soap_in__genskel__translate(struct soap *soap, const char *tag, _genskel__translate *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genskel__translate *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genskel__translate, sizeof(_genskel__translate), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genskel__translate)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genskel__translate *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "x", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genskel__translate *)a)->x.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "y", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genskel__translate *)a)->y.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "z", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genskel__translate *)a)->z.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genskel__translate *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genskel__translate, 0, sizeof(_genskel__translate), 0, soap_copy__genskel__translate);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genskel__translate * SOAP_FMAC6 soap_new__genskel__translate(struct soap *soap, int n)
{	return soap_instantiate__genskel__translate(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genskel__translate(struct soap *soap, _genskel__translate *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genskel__translate * SOAP_FMAC4 soap_instantiate__genskel__translate(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genskel__translate(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genskel__translate, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genskel__translate;
		if (size)
			*size = sizeof(_genskel__translate);
		((_genskel__translate*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genskel__translate[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genskel__translate);
		for (int i = 0; i < n; i++)
			((_genskel__translate*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genskel__translate*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genskel__translate(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genskel__translate %p -> %p\n", q, p));
	*(_genskel__translate*)p = *(_genskel__translate*)q;
}

void _genskel__keyframe::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_genskel__keyframe::genskel__translate = NULL;
	this->_genskel__keyframe::genskel__rotate = NULL;
	this->_genskel__keyframe::scale = NULL;
	soap_default_std__string(soap, &this->_genskel__keyframe::time);
	/* transient soap skipped */
}

void _genskel__keyframe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_genskel__translate(soap, &this->_genskel__keyframe::genskel__translate);
	soap_serialize_PointerTo_genskel__rotate(soap, &this->_genskel__keyframe::genskel__rotate);
	soap_serialize_PointerTogenskel__scale(soap, &this->_genskel__keyframe::scale);
	/* transient soap skipped */
}

int _genskel__keyframe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genskel__keyframe);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genskel__keyframe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genskel__keyframe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genskel__keyframe(struct soap *soap, const char *tag, int id, const _genskel__keyframe *a, const char *type)
{
	if (!((_genskel__keyframe *)a)->time.empty())
		soap_set_attr(soap, "time", ((_genskel__keyframe *)a)->time.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genskel__keyframe), type))
		return soap->error;
	if (soap_out_PointerTo_genskel__translate(soap, "genskel:translate", -1, &(a->_genskel__keyframe::genskel__translate), ""))
		return soap->error;
	if (soap_out_PointerTo_genskel__rotate(soap, "genskel:rotate", -1, &(a->_genskel__keyframe::genskel__rotate), ""))
		return soap->error;
	if (soap_out_PointerTogenskel__scale(soap, "genskel:scale", -1, &(a->_genskel__keyframe::scale), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genskel__keyframe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genskel__keyframe(soap, this, tag, type);
}

SOAP_FMAC3 _genskel__keyframe * SOAP_FMAC4 soap_get__genskel__keyframe(struct soap *soap, _genskel__keyframe *p, const char *tag, const char *type)
{
	if ((p = soap_in__genskel__keyframe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genskel__keyframe::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genskel__keyframe(soap, tag, this, type);
}

SOAP_FMAC3 _genskel__keyframe * SOAP_FMAC4 soap_in__genskel__keyframe(struct soap *soap, const char *tag, _genskel__keyframe *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genskel__keyframe *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genskel__keyframe, sizeof(_genskel__keyframe), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genskel__keyframe)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genskel__keyframe *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "time", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genskel__keyframe *)a)->time.assign(s);
		}
	}
	short soap_flag_genskel__translate1 = 1, soap_flag_genskel__rotate1 = 1, soap_flag_scale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genskel__translate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genskel__translate(soap, "genskel:translate", &(a->_genskel__keyframe::genskel__translate), ""))
				{	soap_flag_genskel__translate1--;
					continue;
				}
			if (soap_flag_genskel__rotate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genskel__rotate(soap, "genskel:rotate", &(a->_genskel__keyframe::genskel__rotate), ""))
				{	soap_flag_genskel__rotate1--;
					continue;
				}
			if (soap_flag_scale1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogenskel__scale(soap, "genskel:scale", &(a->_genskel__keyframe::scale), "genskel:scale"))
				{	soap_flag_scale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genskel__keyframe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genskel__keyframe, 0, sizeof(_genskel__keyframe), 0, soap_copy__genskel__keyframe);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genskel__keyframe * SOAP_FMAC6 soap_new__genskel__keyframe(struct soap *soap, int n)
{	return soap_instantiate__genskel__keyframe(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genskel__keyframe(struct soap *soap, _genskel__keyframe *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genskel__keyframe * SOAP_FMAC4 soap_instantiate__genskel__keyframe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genskel__keyframe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genskel__keyframe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genskel__keyframe;
		if (size)
			*size = sizeof(_genskel__keyframe);
		((_genskel__keyframe*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genskel__keyframe[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genskel__keyframe);
		for (int i = 0; i < n; i++)
			((_genskel__keyframe*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genskel__keyframe*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genskel__keyframe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genskel__keyframe %p -> %p\n", q, p));
	*(_genskel__keyframe*)p = *(_genskel__keyframe*)q;
}

void _genskel__keyframes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genskel__keyframe(soap, &this->_genskel__keyframes::genskel__keyframe);
	/* transient soap skipped */
}

void _genskel__keyframes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genskel__keyframe(soap, &this->_genskel__keyframes::genskel__keyframe);
	/* transient soap skipped */
}

int _genskel__keyframes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genskel__keyframes);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genskel__keyframes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genskel__keyframes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genskel__keyframes(struct soap *soap, const char *tag, int id, const _genskel__keyframes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genskel__keyframes), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genskel__keyframe(soap, "genskel:keyframe", -1, &(a->_genskel__keyframes::genskel__keyframe), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genskel__keyframes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genskel__keyframes(soap, this, tag, type);
}

SOAP_FMAC3 _genskel__keyframes * SOAP_FMAC4 soap_get__genskel__keyframes(struct soap *soap, _genskel__keyframes *p, const char *tag, const char *type)
{
	if ((p = soap_in__genskel__keyframes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genskel__keyframes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genskel__keyframes(soap, tag, this, type);
}

SOAP_FMAC3 _genskel__keyframes * SOAP_FMAC4 soap_in__genskel__keyframes(struct soap *soap, const char *tag, _genskel__keyframes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genskel__keyframes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genskel__keyframes, sizeof(_genskel__keyframes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genskel__keyframes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genskel__keyframes *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genskel__keyframe(soap, "genskel:keyframe", &(a->_genskel__keyframes::genskel__keyframe), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genskel__keyframes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genskel__keyframes, 0, sizeof(_genskel__keyframes), 0, soap_copy__genskel__keyframes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genskel__keyframes * SOAP_FMAC6 soap_new__genskel__keyframes(struct soap *soap, int n)
{	return soap_instantiate__genskel__keyframes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genskel__keyframes(struct soap *soap, _genskel__keyframes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genskel__keyframes * SOAP_FMAC4 soap_instantiate__genskel__keyframes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genskel__keyframes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genskel__keyframes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genskel__keyframes;
		if (size)
			*size = sizeof(_genskel__keyframes);
		((_genskel__keyframes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genskel__keyframes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genskel__keyframes);
		for (int i = 0; i < n; i++)
			((_genskel__keyframes*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genskel__keyframes*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genskel__keyframes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genskel__keyframes %p -> %p\n", q, p));
	*(_genskel__keyframes*)p = *(_genskel__keyframes*)q;
}

void _genskel__track::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_genskel__track::genskel__keyframes = NULL;
	soap_default_std__string(soap, &this->_genskel__track::bone);
	/* transient soap skipped */
}

void _genskel__track::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_genskel__keyframes(soap, &this->_genskel__track::genskel__keyframes);
	/* transient soap skipped */
}

int _genskel__track::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genskel__track);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genskel__track::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genskel__track(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genskel__track(struct soap *soap, const char *tag, int id, const _genskel__track *a, const char *type)
{
	if (!((_genskel__track *)a)->bone.empty())
		soap_set_attr(soap, "bone", ((_genskel__track *)a)->bone.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genskel__track), type))
		return soap->error;
	if (soap_out_PointerTo_genskel__keyframes(soap, "genskel:keyframes", -1, &(a->_genskel__track::genskel__keyframes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genskel__track::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genskel__track(soap, this, tag, type);
}

SOAP_FMAC3 _genskel__track * SOAP_FMAC4 soap_get__genskel__track(struct soap *soap, _genskel__track *p, const char *tag, const char *type)
{
	if ((p = soap_in__genskel__track(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genskel__track::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genskel__track(soap, tag, this, type);
}

SOAP_FMAC3 _genskel__track * SOAP_FMAC4 soap_in__genskel__track(struct soap *soap, const char *tag, _genskel__track *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genskel__track *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genskel__track, sizeof(_genskel__track), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genskel__track)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genskel__track *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "bone", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genskel__track *)a)->bone.assign(s);
		}
	}
	short soap_flag_genskel__keyframes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genskel__keyframes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genskel__keyframes(soap, "genskel:keyframes", &(a->_genskel__track::genskel__keyframes), ""))
				{	soap_flag_genskel__keyframes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genskel__track *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genskel__track, 0, sizeof(_genskel__track), 0, soap_copy__genskel__track);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genskel__keyframes1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _genskel__track * SOAP_FMAC6 soap_new__genskel__track(struct soap *soap, int n)
{	return soap_instantiate__genskel__track(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genskel__track(struct soap *soap, _genskel__track *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genskel__track * SOAP_FMAC4 soap_instantiate__genskel__track(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genskel__track(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genskel__track, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genskel__track;
		if (size)
			*size = sizeof(_genskel__track);
		((_genskel__track*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genskel__track[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genskel__track);
		for (int i = 0; i < n; i++)
			((_genskel__track*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genskel__track*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genskel__track(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genskel__track %p -> %p\n", q, p));
	*(_genskel__track*)p = *(_genskel__track*)q;
}

void _genskel__tracks::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genskel__track(soap, &this->_genskel__tracks::genskel__track);
	/* transient soap skipped */
}

void _genskel__tracks::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genskel__track(soap, &this->_genskel__tracks::genskel__track);
	/* transient soap skipped */
}

int _genskel__tracks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genskel__tracks);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genskel__tracks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genskel__tracks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genskel__tracks(struct soap *soap, const char *tag, int id, const _genskel__tracks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genskel__tracks), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genskel__track(soap, "genskel:track", -1, &(a->_genskel__tracks::genskel__track), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genskel__tracks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genskel__tracks(soap, this, tag, type);
}

SOAP_FMAC3 _genskel__tracks * SOAP_FMAC4 soap_get__genskel__tracks(struct soap *soap, _genskel__tracks *p, const char *tag, const char *type)
{
	if ((p = soap_in__genskel__tracks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genskel__tracks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genskel__tracks(soap, tag, this, type);
}

SOAP_FMAC3 _genskel__tracks * SOAP_FMAC4 soap_in__genskel__tracks(struct soap *soap, const char *tag, _genskel__tracks *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genskel__tracks *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genskel__tracks, sizeof(_genskel__tracks), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genskel__tracks)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genskel__tracks *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genskel__track(soap, "genskel:track", &(a->_genskel__tracks::genskel__track), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genskel__tracks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genskel__tracks, 0, sizeof(_genskel__tracks), 0, soap_copy__genskel__tracks);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genskel__tracks * SOAP_FMAC6 soap_new__genskel__tracks(struct soap *soap, int n)
{	return soap_instantiate__genskel__tracks(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genskel__tracks(struct soap *soap, _genskel__tracks *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genskel__tracks * SOAP_FMAC4 soap_instantiate__genskel__tracks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genskel__tracks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genskel__tracks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genskel__tracks;
		if (size)
			*size = sizeof(_genskel__tracks);
		((_genskel__tracks*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genskel__tracks[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genskel__tracks);
		for (int i = 0; i < n; i++)
			((_genskel__tracks*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genskel__tracks*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genskel__tracks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genskel__tracks %p -> %p\n", q, p));
	*(_genskel__tracks*)p = *(_genskel__tracks*)q;
}

void _genskel__animation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_genskel__animation::genskel__tracks = NULL;
	soap_default_std__string(soap, &this->_genskel__animation::name);
	soap_default_std__string(soap, &this->_genskel__animation::length);
	/* transient soap skipped */
}

void _genskel__animation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_genskel__tracks(soap, &this->_genskel__animation::genskel__tracks);
	/* transient soap skipped */
}

int _genskel__animation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genskel__animation);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genskel__animation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genskel__animation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genskel__animation(struct soap *soap, const char *tag, int id, const _genskel__animation *a, const char *type)
{
	if (!((_genskel__animation *)a)->name.empty())
		soap_set_attr(soap, "name", ((_genskel__animation *)a)->name.c_str());
	if (!((_genskel__animation *)a)->length.empty())
		soap_set_attr(soap, "length", ((_genskel__animation *)a)->length.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genskel__animation), type))
		return soap->error;
	if (soap_out_PointerTo_genskel__tracks(soap, "genskel:tracks", -1, &(a->_genskel__animation::genskel__tracks), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genskel__animation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genskel__animation(soap, this, tag, type);
}

SOAP_FMAC3 _genskel__animation * SOAP_FMAC4 soap_get__genskel__animation(struct soap *soap, _genskel__animation *p, const char *tag, const char *type)
{
	if ((p = soap_in__genskel__animation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genskel__animation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genskel__animation(soap, tag, this, type);
}

SOAP_FMAC3 _genskel__animation * SOAP_FMAC4 soap_in__genskel__animation(struct soap *soap, const char *tag, _genskel__animation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genskel__animation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genskel__animation, sizeof(_genskel__animation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genskel__animation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genskel__animation *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genskel__animation *)a)->name.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "length", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genskel__animation *)a)->length.assign(s);
		}
	}
	short soap_flag_genskel__tracks1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genskel__tracks1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genskel__tracks(soap, "genskel:tracks", &(a->_genskel__animation::genskel__tracks), ""))
				{	soap_flag_genskel__tracks1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genskel__animation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genskel__animation, 0, sizeof(_genskel__animation), 0, soap_copy__genskel__animation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genskel__tracks1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _genskel__animation * SOAP_FMAC6 soap_new__genskel__animation(struct soap *soap, int n)
{	return soap_instantiate__genskel__animation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genskel__animation(struct soap *soap, _genskel__animation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genskel__animation * SOAP_FMAC4 soap_instantiate__genskel__animation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genskel__animation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genskel__animation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genskel__animation;
		if (size)
			*size = sizeof(_genskel__animation);
		((_genskel__animation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genskel__animation[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genskel__animation);
		for (int i = 0; i < n; i++)
			((_genskel__animation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genskel__animation*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genskel__animation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genskel__animation %p -> %p\n", q, p));
	*(_genskel__animation*)p = *(_genskel__animation*)q;
}

void _genskel__animations::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genskel__animation(soap, &this->_genskel__animations::genskel__animation);
	/* transient soap skipped */
}

void _genskel__animations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genskel__animation(soap, &this->_genskel__animations::genskel__animation);
	/* transient soap skipped */
}

int _genskel__animations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genskel__animations);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genskel__animations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genskel__animations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genskel__animations(struct soap *soap, const char *tag, int id, const _genskel__animations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genskel__animations), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genskel__animation(soap, "genskel:animation", -1, &(a->_genskel__animations::genskel__animation), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genskel__animations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genskel__animations(soap, this, tag, type);
}

SOAP_FMAC3 _genskel__animations * SOAP_FMAC4 soap_get__genskel__animations(struct soap *soap, _genskel__animations *p, const char *tag, const char *type)
{
	if ((p = soap_in__genskel__animations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genskel__animations::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genskel__animations(soap, tag, this, type);
}

SOAP_FMAC3 _genskel__animations * SOAP_FMAC4 soap_in__genskel__animations(struct soap *soap, const char *tag, _genskel__animations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genskel__animations *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genskel__animations, sizeof(_genskel__animations), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genskel__animations)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genskel__animations *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genskel__animation(soap, "genskel:animation", &(a->_genskel__animations::genskel__animation), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genskel__animations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genskel__animations, 0, sizeof(_genskel__animations), 0, soap_copy__genskel__animations);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genskel__animations * SOAP_FMAC6 soap_new__genskel__animations(struct soap *soap, int n)
{	return soap_instantiate__genskel__animations(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genskel__animations(struct soap *soap, _genskel__animations *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genskel__animations * SOAP_FMAC4 soap_instantiate__genskel__animations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genskel__animations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genskel__animations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genskel__animations;
		if (size)
			*size = sizeof(_genskel__animations);
		((_genskel__animations*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genskel__animations[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genskel__animations);
		for (int i = 0; i < n; i++)
			((_genskel__animations*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genskel__animations*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genskel__animations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genskel__animations %p -> %p\n", q, p));
	*(_genskel__animations*)p = *(_genskel__animations*)q;
}

void _genskel__boneparent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genskel__boneparent::bone);
	soap_default_std__string(soap, &this->_genskel__boneparent::parent);
	/* transient soap skipped */
}

void _genskel__boneparent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genskel__boneparent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genskel__boneparent);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genskel__boneparent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genskel__boneparent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genskel__boneparent(struct soap *soap, const char *tag, int id, const _genskel__boneparent *a, const char *type)
{
	if (!((_genskel__boneparent *)a)->bone.empty())
		soap_set_attr(soap, "bone", ((_genskel__boneparent *)a)->bone.c_str());
	if (!((_genskel__boneparent *)a)->parent.empty())
		soap_set_attr(soap, "parent", ((_genskel__boneparent *)a)->parent.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genskel__boneparent), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genskel__boneparent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genskel__boneparent(soap, this, tag, type);
}

SOAP_FMAC3 _genskel__boneparent * SOAP_FMAC4 soap_get__genskel__boneparent(struct soap *soap, _genskel__boneparent *p, const char *tag, const char *type)
{
	if ((p = soap_in__genskel__boneparent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genskel__boneparent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genskel__boneparent(soap, tag, this, type);
}

SOAP_FMAC3 _genskel__boneparent * SOAP_FMAC4 soap_in__genskel__boneparent(struct soap *soap, const char *tag, _genskel__boneparent *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genskel__boneparent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genskel__boneparent, sizeof(_genskel__boneparent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genskel__boneparent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genskel__boneparent *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "bone", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genskel__boneparent *)a)->bone.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "parent", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genskel__boneparent *)a)->parent.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genskel__boneparent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genskel__boneparent, 0, sizeof(_genskel__boneparent), 0, soap_copy__genskel__boneparent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genskel__boneparent * SOAP_FMAC6 soap_new__genskel__boneparent(struct soap *soap, int n)
{	return soap_instantiate__genskel__boneparent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genskel__boneparent(struct soap *soap, _genskel__boneparent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genskel__boneparent * SOAP_FMAC4 soap_instantiate__genskel__boneparent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genskel__boneparent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genskel__boneparent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genskel__boneparent;
		if (size)
			*size = sizeof(_genskel__boneparent);
		((_genskel__boneparent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genskel__boneparent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genskel__boneparent);
		for (int i = 0; i < n; i++)
			((_genskel__boneparent*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genskel__boneparent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genskel__boneparent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genskel__boneparent %p -> %p\n", q, p));
	*(_genskel__boneparent*)p = *(_genskel__boneparent*)q;
}

void _genskel__bonehierarchy::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genskel__boneparent(soap, &this->_genskel__bonehierarchy::genskel__boneparent);
	/* transient soap skipped */
}

void _genskel__bonehierarchy::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genskel__boneparent(soap, &this->_genskel__bonehierarchy::genskel__boneparent);
	/* transient soap skipped */
}

int _genskel__bonehierarchy::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genskel__bonehierarchy);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genskel__bonehierarchy::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genskel__bonehierarchy(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genskel__bonehierarchy(struct soap *soap, const char *tag, int id, const _genskel__bonehierarchy *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genskel__bonehierarchy), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genskel__boneparent(soap, "genskel:boneparent", -1, &(a->_genskel__bonehierarchy::genskel__boneparent), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genskel__bonehierarchy::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genskel__bonehierarchy(soap, this, tag, type);
}

SOAP_FMAC3 _genskel__bonehierarchy * SOAP_FMAC4 soap_get__genskel__bonehierarchy(struct soap *soap, _genskel__bonehierarchy *p, const char *tag, const char *type)
{
	if ((p = soap_in__genskel__bonehierarchy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genskel__bonehierarchy::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genskel__bonehierarchy(soap, tag, this, type);
}

SOAP_FMAC3 _genskel__bonehierarchy * SOAP_FMAC4 soap_in__genskel__bonehierarchy(struct soap *soap, const char *tag, _genskel__bonehierarchy *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genskel__bonehierarchy *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genskel__bonehierarchy, sizeof(_genskel__bonehierarchy), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genskel__bonehierarchy)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genskel__bonehierarchy *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genskel__boneparent(soap, "genskel:boneparent", &(a->_genskel__bonehierarchy::genskel__boneparent), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genskel__bonehierarchy *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genskel__bonehierarchy, 0, sizeof(_genskel__bonehierarchy), 0, soap_copy__genskel__bonehierarchy);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genskel__bonehierarchy * SOAP_FMAC6 soap_new__genskel__bonehierarchy(struct soap *soap, int n)
{	return soap_instantiate__genskel__bonehierarchy(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genskel__bonehierarchy(struct soap *soap, _genskel__bonehierarchy *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genskel__bonehierarchy * SOAP_FMAC4 soap_instantiate__genskel__bonehierarchy(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genskel__bonehierarchy(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genskel__bonehierarchy, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genskel__bonehierarchy;
		if (size)
			*size = sizeof(_genskel__bonehierarchy);
		((_genskel__bonehierarchy*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genskel__bonehierarchy[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genskel__bonehierarchy);
		for (int i = 0; i < n; i++)
			((_genskel__bonehierarchy*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genskel__bonehierarchy*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genskel__bonehierarchy(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genskel__bonehierarchy %p -> %p\n", q, p));
	*(_genskel__bonehierarchy*)p = *(_genskel__bonehierarchy*)q;
}

void _genskel__skeleton::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_genskel__skeleton::bones = NULL;
	this->_genskel__skeleton::genskel__bonehierarchy = NULL;
	this->_genskel__skeleton::genskel__animations = NULL;
	this->_genskel__skeleton::genskel__animationlinks = NULL;
	/* transient soap skipped */
}

void _genskel__skeleton::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTogenskel__bones(soap, &this->_genskel__skeleton::bones);
	soap_serialize_PointerTo_genskel__bonehierarchy(soap, &this->_genskel__skeleton::genskel__bonehierarchy);
	soap_serialize_PointerTo_genskel__animations(soap, &this->_genskel__skeleton::genskel__animations);
	soap_serialize_PointerTo_genskel__animationlinks(soap, &this->_genskel__skeleton::genskel__animationlinks);
	/* transient soap skipped */
}

int _genskel__skeleton::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genskel__skeleton);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genskel__skeleton::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genskel__skeleton(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genskel__skeleton(struct soap *soap, const char *tag, int id, const _genskel__skeleton *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genskel__skeleton), type))
		return soap->error;
	if (soap_out_PointerTogenskel__bones(soap, "genskel:bones", -1, &(a->_genskel__skeleton::bones), ""))
		return soap->error;
	if (soap_out_PointerTo_genskel__bonehierarchy(soap, "genskel:bonehierarchy", -1, &(a->_genskel__skeleton::genskel__bonehierarchy), ""))
		return soap->error;
	if (soap_out_PointerTo_genskel__animations(soap, "genskel:animations", -1, &(a->_genskel__skeleton::genskel__animations), ""))
		return soap->error;
	if (soap_out_PointerTo_genskel__animationlinks(soap, "genskel:animationlinks", -1, &(a->_genskel__skeleton::genskel__animationlinks), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genskel__skeleton::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genskel__skeleton(soap, this, tag, type);
}

SOAP_FMAC3 _genskel__skeleton * SOAP_FMAC4 soap_get__genskel__skeleton(struct soap *soap, _genskel__skeleton *p, const char *tag, const char *type)
{
	if ((p = soap_in__genskel__skeleton(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genskel__skeleton::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genskel__skeleton(soap, tag, this, type);
}

SOAP_FMAC3 _genskel__skeleton * SOAP_FMAC4 soap_in__genskel__skeleton(struct soap *soap, const char *tag, _genskel__skeleton *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genskel__skeleton *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genskel__skeleton, sizeof(_genskel__skeleton), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genskel__skeleton)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genskel__skeleton *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_bones1 = 1, soap_flag_genskel__bonehierarchy1 = 1, soap_flag_genskel__animations1 = 1, soap_flag_genskel__animationlinks1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_bones1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogenskel__bones(soap, "genskel:bones", &(a->_genskel__skeleton::bones), "genskel:bones"))
				{	soap_flag_bones1--;
					continue;
				}
			if (soap_flag_genskel__bonehierarchy1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genskel__bonehierarchy(soap, "genskel:bonehierarchy", &(a->_genskel__skeleton::genskel__bonehierarchy), ""))
				{	soap_flag_genskel__bonehierarchy1--;
					continue;
				}
			if (soap_flag_genskel__animations1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genskel__animations(soap, "genskel:animations", &(a->_genskel__skeleton::genskel__animations), ""))
				{	soap_flag_genskel__animations1--;
					continue;
				}
			if (soap_flag_genskel__animationlinks1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genskel__animationlinks(soap, "genskel:animationlinks", &(a->_genskel__skeleton::genskel__animationlinks), ""))
				{	soap_flag_genskel__animationlinks1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genskel__skeleton *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genskel__skeleton, 0, sizeof(_genskel__skeleton), 0, soap_copy__genskel__skeleton);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_bones1 > 0 || soap_flag_genskel__bonehierarchy1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _genskel__skeleton * SOAP_FMAC6 soap_new__genskel__skeleton(struct soap *soap, int n)
{	return soap_instantiate__genskel__skeleton(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genskel__skeleton(struct soap *soap, _genskel__skeleton *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genskel__skeleton * SOAP_FMAC4 soap_instantiate__genskel__skeleton(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genskel__skeleton(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genskel__skeleton, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genskel__skeleton;
		if (size)
			*size = sizeof(_genskel__skeleton);
		((_genskel__skeleton*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genskel__skeleton[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genskel__skeleton);
		for (int i = 0; i < n; i++)
			((_genskel__skeleton*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genskel__skeleton*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genskel__skeleton(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genskel__skeleton %p -> %p\n", q, p));
	*(_genskel__skeleton*)p = *(_genskel__skeleton*)q;
}

void genskel__scale::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->genskel__scale::factor = NULL;
	this->genskel__scale::x = NULL;
	this->genskel__scale::y = NULL;
	this->genskel__scale::z = NULL;
	/* transient soap skipped */
}

void genskel__scale::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int genskel__scale::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_genskel__scale);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int genskel__scale::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_genskel__scale(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_genskel__scale(struct soap *soap, const char *tag, int id, const genskel__scale *a, const char *type)
{
	if (((genskel__scale *)a)->factor)
		soap_set_attr(soap, "factor", ((genskel__scale *)a)->factor->c_str());
	if (((genskel__scale *)a)->x)
		soap_set_attr(soap, "x", ((genskel__scale *)a)->x->c_str());
	if (((genskel__scale *)a)->y)
		soap_set_attr(soap, "y", ((genskel__scale *)a)->y->c_str());
	if (((genskel__scale *)a)->z)
		soap_set_attr(soap, "z", ((genskel__scale *)a)->z->c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_genskel__scale), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *genskel__scale::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_genskel__scale(soap, this, tag, type);
}

SOAP_FMAC3 genskel__scale * SOAP_FMAC4 soap_get_genskel__scale(struct soap *soap, genskel__scale *p, const char *tag, const char *type)
{
	if ((p = soap_in_genskel__scale(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *genskel__scale::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_genskel__scale(soap, tag, this, type);
}

SOAP_FMAC3 genskel__scale * SOAP_FMAC4 soap_in_genskel__scale(struct soap *soap, const char *tag, genskel__scale *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (genskel__scale *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_genskel__scale, sizeof(genskel__scale), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_genskel__scale)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (genskel__scale *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "factor", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((genskel__scale *)a)->factor = soap_new_std__string(soap, -1);
				((genskel__scale *)a)->factor->assign(s);
			}
		}
	}
	{	const char *t = soap_attr_value(soap, "x", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((genskel__scale *)a)->x = soap_new_std__string(soap, -1);
				((genskel__scale *)a)->x->assign(s);
			}
		}
	}
	{	const char *t = soap_attr_value(soap, "y", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((genskel__scale *)a)->y = soap_new_std__string(soap, -1);
				((genskel__scale *)a)->y->assign(s);
			}
		}
	}
	{	const char *t = soap_attr_value(soap, "z", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((genskel__scale *)a)->z = soap_new_std__string(soap, -1);
				((genskel__scale *)a)->z->assign(s);
			}
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (genskel__scale *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_genskel__scale, 0, sizeof(genskel__scale), 0, soap_copy_genskel__scale);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 genskel__scale * SOAP_FMAC6 soap_new_genskel__scale(struct soap *soap, int n)
{	return soap_instantiate_genskel__scale(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_genskel__scale(struct soap *soap, genskel__scale *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 genskel__scale * SOAP_FMAC4 soap_instantiate_genskel__scale(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_genskel__scale(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_genskel__scale, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new genskel__scale;
		if (size)
			*size = sizeof(genskel__scale);
		((genskel__scale*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new genskel__scale[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(genskel__scale);
		for (int i = 0; i < n; i++)
			((genskel__scale*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (genskel__scale*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_genskel__scale(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying genskel__scale %p -> %p\n", q, p));
	*(genskel__scale*)p = *(genskel__scale*)q;
}

void genskel__axis::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->genskel__axis::x);
	soap_default_std__string(soap, &this->genskel__axis::y);
	soap_default_std__string(soap, &this->genskel__axis::z);
	/* transient soap skipped */
}

void genskel__axis::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int genskel__axis::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_genskel__axis);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int genskel__axis::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_genskel__axis(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_genskel__axis(struct soap *soap, const char *tag, int id, const genskel__axis *a, const char *type)
{
	if (!((genskel__axis *)a)->x.empty())
		soap_set_attr(soap, "x", ((genskel__axis *)a)->x.c_str());
	if (!((genskel__axis *)a)->y.empty())
		soap_set_attr(soap, "y", ((genskel__axis *)a)->y.c_str());
	if (!((genskel__axis *)a)->z.empty())
		soap_set_attr(soap, "z", ((genskel__axis *)a)->z.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_genskel__axis), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *genskel__axis::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_genskel__axis(soap, this, tag, type);
}

SOAP_FMAC3 genskel__axis * SOAP_FMAC4 soap_get_genskel__axis(struct soap *soap, genskel__axis *p, const char *tag, const char *type)
{
	if ((p = soap_in_genskel__axis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *genskel__axis::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_genskel__axis(soap, tag, this, type);
}

SOAP_FMAC3 genskel__axis * SOAP_FMAC4 soap_in_genskel__axis(struct soap *soap, const char *tag, genskel__axis *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (genskel__axis *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_genskel__axis, sizeof(genskel__axis), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_genskel__axis)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (genskel__axis *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "x", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((genskel__axis *)a)->x.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "y", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((genskel__axis *)a)->y.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "z", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((genskel__axis *)a)->z.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (genskel__axis *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_genskel__axis, 0, sizeof(genskel__axis), 0, soap_copy_genskel__axis);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 genskel__axis * SOAP_FMAC6 soap_new_genskel__axis(struct soap *soap, int n)
{	return soap_instantiate_genskel__axis(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_genskel__axis(struct soap *soap, genskel__axis *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 genskel__axis * SOAP_FMAC4 soap_instantiate_genskel__axis(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_genskel__axis(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_genskel__axis, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new genskel__axis;
		if (size)
			*size = sizeof(genskel__axis);
		((genskel__axis*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new genskel__axis[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(genskel__axis);
		for (int i = 0; i < n; i++)
			((genskel__axis*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (genskel__axis*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_genskel__axis(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying genskel__axis %p -> %p\n", q, p));
	*(genskel__axis*)p = *(genskel__axis*)q;
}

void genskel__rotation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->genskel__rotation::axis = NULL;
	soap_default_std__string(soap, &this->genskel__rotation::angle);
	/* transient soap skipped */
}

void genskel__rotation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTogenskel__axis(soap, &this->genskel__rotation::axis);
	/* transient soap skipped */
}

int genskel__rotation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_genskel__rotation);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int genskel__rotation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_genskel__rotation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_genskel__rotation(struct soap *soap, const char *tag, int id, const genskel__rotation *a, const char *type)
{
	if (!((genskel__rotation *)a)->angle.empty())
		soap_set_attr(soap, "angle", ((genskel__rotation *)a)->angle.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_genskel__rotation), type))
		return soap->error;
	if (soap_out_PointerTogenskel__axis(soap, "genskel:axis", -1, &(a->genskel__rotation::axis), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *genskel__rotation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_genskel__rotation(soap, this, tag, type);
}

SOAP_FMAC3 genskel__rotation * SOAP_FMAC4 soap_get_genskel__rotation(struct soap *soap, genskel__rotation *p, const char *tag, const char *type)
{
	if ((p = soap_in_genskel__rotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *genskel__rotation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_genskel__rotation(soap, tag, this, type);
}

SOAP_FMAC3 genskel__rotation * SOAP_FMAC4 soap_in_genskel__rotation(struct soap *soap, const char *tag, genskel__rotation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (genskel__rotation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_genskel__rotation, sizeof(genskel__rotation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_genskel__rotation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (genskel__rotation *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "angle", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((genskel__rotation *)a)->angle.assign(s);
		}
	}
	short soap_flag_axis1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_axis1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogenskel__axis(soap, "genskel:axis", &(a->genskel__rotation::axis), "genskel:axis"))
				{	soap_flag_axis1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (genskel__rotation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_genskel__rotation, 0, sizeof(genskel__rotation), 0, soap_copy_genskel__rotation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_axis1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 genskel__rotation * SOAP_FMAC6 soap_new_genskel__rotation(struct soap *soap, int n)
{	return soap_instantiate_genskel__rotation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_genskel__rotation(struct soap *soap, genskel__rotation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 genskel__rotation * SOAP_FMAC4 soap_instantiate_genskel__rotation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_genskel__rotation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_genskel__rotation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new genskel__rotation;
		if (size)
			*size = sizeof(genskel__rotation);
		((genskel__rotation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new genskel__rotation[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(genskel__rotation);
		for (int i = 0; i < n; i++)
			((genskel__rotation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (genskel__rotation*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_genskel__rotation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying genskel__rotation %p -> %p\n", q, p));
	*(genskel__rotation*)p = *(genskel__rotation*)q;
}

void genskel__position::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->genskel__position::x);
	soap_default_std__string(soap, &this->genskel__position::y);
	soap_default_std__string(soap, &this->genskel__position::z);
	/* transient soap skipped */
}

void genskel__position::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int genskel__position::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_genskel__position);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int genskel__position::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_genskel__position(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_genskel__position(struct soap *soap, const char *tag, int id, const genskel__position *a, const char *type)
{
	if (!((genskel__position *)a)->x.empty())
		soap_set_attr(soap, "x", ((genskel__position *)a)->x.c_str());
	if (!((genskel__position *)a)->y.empty())
		soap_set_attr(soap, "y", ((genskel__position *)a)->y.c_str());
	if (!((genskel__position *)a)->z.empty())
		soap_set_attr(soap, "z", ((genskel__position *)a)->z.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_genskel__position), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *genskel__position::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_genskel__position(soap, this, tag, type);
}

SOAP_FMAC3 genskel__position * SOAP_FMAC4 soap_get_genskel__position(struct soap *soap, genskel__position *p, const char *tag, const char *type)
{
	if ((p = soap_in_genskel__position(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *genskel__position::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_genskel__position(soap, tag, this, type);
}

SOAP_FMAC3 genskel__position * SOAP_FMAC4 soap_in_genskel__position(struct soap *soap, const char *tag, genskel__position *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (genskel__position *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_genskel__position, sizeof(genskel__position), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_genskel__position)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (genskel__position *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "x", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((genskel__position *)a)->x.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "y", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((genskel__position *)a)->y.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "z", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((genskel__position *)a)->z.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (genskel__position *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_genskel__position, 0, sizeof(genskel__position), 0, soap_copy_genskel__position);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 genskel__position * SOAP_FMAC6 soap_new_genskel__position(struct soap *soap, int n)
{	return soap_instantiate_genskel__position(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_genskel__position(struct soap *soap, genskel__position *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 genskel__position * SOAP_FMAC4 soap_instantiate_genskel__position(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_genskel__position(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_genskel__position, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new genskel__position;
		if (size)
			*size = sizeof(genskel__position);
		((genskel__position*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new genskel__position[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(genskel__position);
		for (int i = 0; i < n; i++)
			((genskel__position*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (genskel__position*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_genskel__position(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying genskel__position %p -> %p\n", q, p));
	*(genskel__position*)p = *(genskel__position*)q;
}

void genskel__bone::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->genskel__bone::position = NULL;
	this->genskel__bone::rotation = NULL;
	this->genskel__bone::scale = NULL;
	soap_default_std__string(soap, &this->genskel__bone::id);
	soap_default_std__string(soap, &this->genskel__bone::name);
	/* transient soap skipped */
}

void genskel__bone::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTogenskel__position(soap, &this->genskel__bone::position);
	soap_serialize_PointerTogenskel__rotation(soap, &this->genskel__bone::rotation);
	soap_serialize_PointerTogenskel__scale(soap, &this->genskel__bone::scale);
	/* transient soap skipped */
}

int genskel__bone::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_genskel__bone);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int genskel__bone::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_genskel__bone(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_genskel__bone(struct soap *soap, const char *tag, int id, const genskel__bone *a, const char *type)
{
	if (!((genskel__bone *)a)->id.empty())
		soap_set_attr(soap, "id", ((genskel__bone *)a)->id.c_str());
	if (!((genskel__bone *)a)->name.empty())
		soap_set_attr(soap, "name", ((genskel__bone *)a)->name.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_genskel__bone), type))
		return soap->error;
	if (soap_out_PointerTogenskel__position(soap, "genskel:position", -1, &(a->genskel__bone::position), ""))
		return soap->error;
	if (soap_out_PointerTogenskel__rotation(soap, "genskel:rotation", -1, &(a->genskel__bone::rotation), ""))
		return soap->error;
	if (soap_out_PointerTogenskel__scale(soap, "genskel:scale", -1, &(a->genskel__bone::scale), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *genskel__bone::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_genskel__bone(soap, this, tag, type);
}

SOAP_FMAC3 genskel__bone * SOAP_FMAC4 soap_get_genskel__bone(struct soap *soap, genskel__bone *p, const char *tag, const char *type)
{
	if ((p = soap_in_genskel__bone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *genskel__bone::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_genskel__bone(soap, tag, this, type);
}

SOAP_FMAC3 genskel__bone * SOAP_FMAC4 soap_in_genskel__bone(struct soap *soap, const char *tag, genskel__bone *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (genskel__bone *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_genskel__bone, sizeof(genskel__bone), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_genskel__bone)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (genskel__bone *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "id", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((genskel__bone *)a)->id.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((genskel__bone *)a)->name.assign(s);
		}
	}
	short soap_flag_position1 = 1, soap_flag_rotation1 = 1, soap_flag_scale1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_position1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogenskel__position(soap, "genskel:position", &(a->genskel__bone::position), "genskel:position"))
				{	soap_flag_position1--;
					continue;
				}
			if (soap_flag_rotation1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogenskel__rotation(soap, "genskel:rotation", &(a->genskel__bone::rotation), "genskel:rotation"))
				{	soap_flag_rotation1--;
					continue;
				}
			if (soap_flag_scale1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogenskel__scale(soap, "genskel:scale", &(a->genskel__bone::scale), "genskel:scale"))
				{	soap_flag_scale1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (genskel__bone *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_genskel__bone, 0, sizeof(genskel__bone), 0, soap_copy_genskel__bone);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_position1 > 0 || soap_flag_rotation1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 genskel__bone * SOAP_FMAC6 soap_new_genskel__bone(struct soap *soap, int n)
{	return soap_instantiate_genskel__bone(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_genskel__bone(struct soap *soap, genskel__bone *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 genskel__bone * SOAP_FMAC4 soap_instantiate_genskel__bone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_genskel__bone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_genskel__bone, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new genskel__bone;
		if (size)
			*size = sizeof(genskel__bone);
		((genskel__bone*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new genskel__bone[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(genskel__bone);
		for (int i = 0; i < n; i++)
			((genskel__bone*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (genskel__bone*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_genskel__bone(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying genskel__bone %p -> %p\n", q, p));
	*(genskel__bone*)p = *(genskel__bone*)q;
}

void genskel__bones::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTogenskel__bone(soap, &this->genskel__bones::bone);
	/* transient soap skipped */
}

void genskel__bones::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTogenskel__bone(soap, &this->genskel__bones::bone);
	/* transient soap skipped */
}

int genskel__bones::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_genskel__bones);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int genskel__bones::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_genskel__bones(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_genskel__bones(struct soap *soap, const char *tag, int id, const genskel__bones *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_genskel__bones), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTogenskel__bone(soap, "genskel:bone", -1, &(a->genskel__bones::bone), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *genskel__bones::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_genskel__bones(soap, this, tag, type);
}

SOAP_FMAC3 genskel__bones * SOAP_FMAC4 soap_get_genskel__bones(struct soap *soap, genskel__bones *p, const char *tag, const char *type)
{
	if ((p = soap_in_genskel__bones(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *genskel__bones::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_genskel__bones(soap, tag, this, type);
}

SOAP_FMAC3 genskel__bones * SOAP_FMAC4 soap_in_genskel__bones(struct soap *soap, const char *tag, genskel__bones *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (genskel__bones *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_genskel__bones, sizeof(genskel__bones), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_genskel__bones)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (genskel__bones *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTogenskel__bone(soap, "genskel:bone", &(a->genskel__bones::bone), "genskel:bone"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (genskel__bones *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_genskel__bones, 0, sizeof(genskel__bones), 0, soap_copy_genskel__bones);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 genskel__bones * SOAP_FMAC6 soap_new_genskel__bones(struct soap *soap, int n)
{	return soap_instantiate_genskel__bones(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_genskel__bones(struct soap *soap, genskel__bones *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 genskel__bones * SOAP_FMAC4 soap_instantiate_genskel__bones(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_genskel__bones(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_genskel__bones, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new genskel__bones;
		if (size)
			*size = sizeof(genskel__bones);
		((genskel__bones*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new genskel__bones[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(genskel__bones);
		for (int i = 0; i < n; i++)
			((genskel__bones*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (genskel__bones*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_genskel__bones(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying genskel__bones %p -> %p\n", q, p));
	*(genskel__bones*)p = *(genskel__bones*)q;
}

void _genmesh__submesh_USCOREextremes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__position(soap, &this->_genmesh__submesh_USCOREextremes::genmesh__position);
	soap_default_std__string(soap, &this->_genmesh__submesh_USCOREextremes::index);
	/* transient soap skipped */
}

void _genmesh__submesh_USCOREextremes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__position(soap, &this->_genmesh__submesh_USCOREextremes::genmesh__position);
	/* transient soap skipped */
}

int _genmesh__submesh_USCOREextremes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__submesh_USCOREextremes);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__submesh_USCOREextremes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__submesh_USCOREextremes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__submesh_USCOREextremes(struct soap *soap, const char *tag, int id, const _genmesh__submesh_USCOREextremes *a, const char *type)
{
	if (!((_genmesh__submesh_USCOREextremes *)a)->index.empty())
		soap_set_attr(soap, "index", ((_genmesh__submesh_USCOREextremes *)a)->index.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__submesh_USCOREextremes), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__position(soap, "genmesh:position", -1, &(a->_genmesh__submesh_USCOREextremes::genmesh__position), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__submesh_USCOREextremes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__submesh_USCOREextremes(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__submesh_USCOREextremes * SOAP_FMAC4 soap_get__genmesh__submesh_USCOREextremes(struct soap *soap, _genmesh__submesh_USCOREextremes *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__submesh_USCOREextremes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__submesh_USCOREextremes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__submesh_USCOREextremes(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__submesh_USCOREextremes * SOAP_FMAC4 soap_in__genmesh__submesh_USCOREextremes(struct soap *soap, const char *tag, _genmesh__submesh_USCOREextremes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__submesh_USCOREextremes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__submesh_USCOREextremes, sizeof(_genmesh__submesh_USCOREextremes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__submesh_USCOREextremes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__submesh_USCOREextremes *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "index", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__submesh_USCOREextremes *)a)->index.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__position(soap, "genmesh:position", &(a->_genmesh__submesh_USCOREextremes::genmesh__position), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__submesh_USCOREextremes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__submesh_USCOREextremes, 0, sizeof(_genmesh__submesh_USCOREextremes), 0, soap_copy__genmesh__submesh_USCOREextremes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__submesh_USCOREextremes * SOAP_FMAC6 soap_new__genmesh__submesh_USCOREextremes(struct soap *soap, int n)
{	return soap_instantiate__genmesh__submesh_USCOREextremes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__submesh_USCOREextremes(struct soap *soap, _genmesh__submesh_USCOREextremes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__submesh_USCOREextremes * SOAP_FMAC4 soap_instantiate__genmesh__submesh_USCOREextremes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__submesh_USCOREextremes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__submesh_USCOREextremes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__submesh_USCOREextremes;
		if (size)
			*size = sizeof(_genmesh__submesh_USCOREextremes);
		((_genmesh__submesh_USCOREextremes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__submesh_USCOREextremes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__submesh_USCOREextremes);
		for (int i = 0; i < n; i++)
			((_genmesh__submesh_USCOREextremes*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__submesh_USCOREextremes*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__submesh_USCOREextremes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__submesh_USCOREextremes %p -> %p\n", q, p));
	*(_genmesh__submesh_USCOREextremes*)p = *(_genmesh__submesh_USCOREextremes*)q;
}

void _genmesh__extremes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__submesh(soap, &this->_genmesh__extremes::genmesh__submesh);
	/* transient soap skipped */
}

void _genmesh__extremes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__submesh(soap, &this->_genmesh__extremes::genmesh__submesh);
	/* transient soap skipped */
}

int _genmesh__extremes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__extremes);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__extremes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__extremes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__extremes(struct soap *soap, const char *tag, int id, const _genmesh__extremes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__extremes), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__submesh(soap, "genmesh:submesh", -1, &(a->_genmesh__extremes::genmesh__submesh), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__extremes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__extremes(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__extremes * SOAP_FMAC4 soap_get__genmesh__extremes(struct soap *soap, _genmesh__extremes *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__extremes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__extremes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__extremes(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__extremes * SOAP_FMAC4 soap_in__genmesh__extremes(struct soap *soap, const char *tag, _genmesh__extremes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__extremes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__extremes, sizeof(_genmesh__extremes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__extremes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__extremes *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__submesh(soap, "genmesh:submesh", &(a->_genmesh__extremes::genmesh__submesh), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__extremes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__extremes, 0, sizeof(_genmesh__extremes), 0, soap_copy__genmesh__extremes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__extremes * SOAP_FMAC6 soap_new__genmesh__extremes(struct soap *soap, int n)
{	return soap_instantiate__genmesh__extremes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__extremes(struct soap *soap, _genmesh__extremes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__extremes * SOAP_FMAC4 soap_instantiate__genmesh__extremes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__extremes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__extremes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__extremes;
		if (size)
			*size = sizeof(_genmesh__extremes);
		((_genmesh__extremes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__extremes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__extremes);
		for (int i = 0; i < n; i++)
			((_genmesh__extremes*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__extremes*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__extremes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__extremes %p -> %p\n", q, p));
	*(_genmesh__extremes*)p = *(_genmesh__extremes*)q;
}

void _genmesh__poseref::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genmesh__poseref::poseindex);
	this->_genmesh__poseref::influence = "1.0";
	/* transient soap skipped */
}

void _genmesh__poseref::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genmesh__poseref::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__poseref);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__poseref::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__poseref(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__poseref(struct soap *soap, const char *tag, int id, const _genmesh__poseref *a, const char *type)
{
	if (!((_genmesh__poseref *)a)->poseindex.empty())
		soap_set_attr(soap, "poseindex", ((_genmesh__poseref *)a)->poseindex.c_str());
	if (!((_genmesh__poseref *)a)->influence.empty())
		soap_set_attr(soap, "influence", ((_genmesh__poseref *)a)->influence.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__poseref), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__poseref::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__poseref(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__poseref * SOAP_FMAC4 soap_get__genmesh__poseref(struct soap *soap, _genmesh__poseref *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__poseref(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__poseref::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__poseref(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__poseref * SOAP_FMAC4 soap_in__genmesh__poseref(struct soap *soap, const char *tag, _genmesh__poseref *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__poseref *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__poseref, sizeof(_genmesh__poseref), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__poseref)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__poseref *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "poseindex", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__poseref *)a)->poseindex.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "influence", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__poseref *)a)->influence.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__poseref *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__poseref, 0, sizeof(_genmesh__poseref), 0, soap_copy__genmesh__poseref);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__poseref * SOAP_FMAC6 soap_new__genmesh__poseref(struct soap *soap, int n)
{	return soap_instantiate__genmesh__poseref(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__poseref(struct soap *soap, _genmesh__poseref *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__poseref * SOAP_FMAC4 soap_instantiate__genmesh__poseref(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__poseref(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__poseref, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__poseref;
		if (size)
			*size = sizeof(_genmesh__poseref);
		((_genmesh__poseref*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__poseref[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__poseref);
		for (int i = 0; i < n; i++)
			((_genmesh__poseref*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__poseref*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__poseref(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__poseref %p -> %p\n", q, p));
	*(_genmesh__poseref*)p = *(_genmesh__poseref*)q;
}

void _genmesh__keyframe::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__position(soap, &this->_genmesh__keyframe::genmesh__position);
	soap_default_std__vectorTemplateOfPointerTo_genmesh__poseref(soap, &this->_genmesh__keyframe::genmesh__poseref);
	soap_default_std__string(soap, &this->_genmesh__keyframe::time);
	/* transient soap skipped */
}

void _genmesh__keyframe::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__position(soap, &this->_genmesh__keyframe::genmesh__position);
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__poseref(soap, &this->_genmesh__keyframe::genmesh__poseref);
	/* transient soap skipped */
}

int _genmesh__keyframe::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__keyframe);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__keyframe::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__keyframe(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__keyframe(struct soap *soap, const char *tag, int id, const _genmesh__keyframe *a, const char *type)
{
	if (!((_genmesh__keyframe *)a)->time.empty())
		soap_set_attr(soap, "time", ((_genmesh__keyframe *)a)->time.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__keyframe), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__position(soap, "genmesh:position", -1, &(a->_genmesh__keyframe::genmesh__position), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__poseref(soap, "genmesh:poseref", -1, &(a->_genmesh__keyframe::genmesh__poseref), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__keyframe::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__keyframe(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__keyframe * SOAP_FMAC4 soap_get__genmesh__keyframe(struct soap *soap, _genmesh__keyframe *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__keyframe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__keyframe::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__keyframe(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__keyframe * SOAP_FMAC4 soap_in__genmesh__keyframe(struct soap *soap, const char *tag, _genmesh__keyframe *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__keyframe *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__keyframe, sizeof(_genmesh__keyframe), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__keyframe)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__keyframe *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "time", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__keyframe *)a)->time.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__position(soap, "genmesh:position", &(a->_genmesh__keyframe::genmesh__position), ""))
					continue;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__poseref(soap, "genmesh:poseref", &(a->_genmesh__keyframe::genmesh__poseref), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__keyframe *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__keyframe, 0, sizeof(_genmesh__keyframe), 0, soap_copy__genmesh__keyframe);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__keyframe * SOAP_FMAC6 soap_new__genmesh__keyframe(struct soap *soap, int n)
{	return soap_instantiate__genmesh__keyframe(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__keyframe(struct soap *soap, _genmesh__keyframe *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__keyframe * SOAP_FMAC4 soap_instantiate__genmesh__keyframe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__keyframe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__keyframe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__keyframe;
		if (size)
			*size = sizeof(_genmesh__keyframe);
		((_genmesh__keyframe*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__keyframe[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__keyframe);
		for (int i = 0; i < n; i++)
			((_genmesh__keyframe*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__keyframe*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__keyframe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__keyframe %p -> %p\n", q, p));
	*(_genmesh__keyframe*)p = *(_genmesh__keyframe*)q;
}

void _genmesh__keyframes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__keyframe(soap, &this->_genmesh__keyframes::genmesh__keyframe);
	/* transient soap skipped */
}

void _genmesh__keyframes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__keyframe(soap, &this->_genmesh__keyframes::genmesh__keyframe);
	/* transient soap skipped */
}

int _genmesh__keyframes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__keyframes);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__keyframes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__keyframes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__keyframes(struct soap *soap, const char *tag, int id, const _genmesh__keyframes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__keyframes), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__keyframe(soap, "genmesh:keyframe", -1, &(a->_genmesh__keyframes::genmesh__keyframe), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__keyframes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__keyframes(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__keyframes * SOAP_FMAC4 soap_get__genmesh__keyframes(struct soap *soap, _genmesh__keyframes *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__keyframes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__keyframes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__keyframes(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__keyframes * SOAP_FMAC4 soap_in__genmesh__keyframes(struct soap *soap, const char *tag, _genmesh__keyframes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__keyframes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__keyframes, sizeof(_genmesh__keyframes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__keyframes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__keyframes *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__keyframe(soap, "genmesh:keyframe", &(a->_genmesh__keyframes::genmesh__keyframe), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__keyframes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__keyframes, 0, sizeof(_genmesh__keyframes), 0, soap_copy__genmesh__keyframes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__keyframes * SOAP_FMAC6 soap_new__genmesh__keyframes(struct soap *soap, int n)
{	return soap_instantiate__genmesh__keyframes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__keyframes(struct soap *soap, _genmesh__keyframes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__keyframes * SOAP_FMAC4 soap_instantiate__genmesh__keyframes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__keyframes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__keyframes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__keyframes;
		if (size)
			*size = sizeof(_genmesh__keyframes);
		((_genmesh__keyframes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__keyframes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__keyframes);
		for (int i = 0; i < n; i++)
			((_genmesh__keyframes*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__keyframes*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__keyframes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__keyframes %p -> %p\n", q, p));
	*(_genmesh__keyframes*)p = *(_genmesh__keyframes*)q;
}

void _genmesh__track::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_genmesh__track::genmesh__keyframes = NULL;
	soap_default__genmesh__track_target(soap, &this->_genmesh__track::target);
	this->_genmesh__track::index = "0";
	soap_default__genmesh__track_type(soap, &this->_genmesh__track::type);
	/* transient soap skipped */
}

void _genmesh__track::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_genmesh__keyframes(soap, &this->_genmesh__track::genmesh__keyframes);
	/* transient soap skipped */
}

int _genmesh__track::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__track);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__track::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__track(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__track(struct soap *soap, const char *tag, int id, const _genmesh__track *a, const char *type)
{
	soap_set_attr(soap, "target", soap__genmesh__track_target2s(soap, ((_genmesh__track *)a)->target));
	if (!((_genmesh__track *)a)->index.empty())
		soap_set_attr(soap, "index", ((_genmesh__track *)a)->index.c_str());
	soap_set_attr(soap, "type", soap__genmesh__track_type2s(soap, ((_genmesh__track *)a)->type));
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__track), type))
		return soap->error;
	if (soap_out_PointerTo_genmesh__keyframes(soap, "genmesh:keyframes", -1, &(a->_genmesh__track::genmesh__keyframes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__track::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__track(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__track * SOAP_FMAC4 soap_get__genmesh__track(struct soap *soap, _genmesh__track *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__track(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__track::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__track(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__track * SOAP_FMAC4 soap_in__genmesh__track(struct soap *soap, const char *tag, _genmesh__track *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__track *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__track, sizeof(_genmesh__track), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__track)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__track *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2_genmesh__track_target(soap, soap_attr_value(soap, "target", 1), &((_genmesh__track *)a)->target))
		return NULL;
	{	const char *t = soap_attr_value(soap, "index", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__track *)a)->index.assign(s);
		}
	}
	if (soap_s2_genmesh__track_type(soap, soap_attr_value(soap, "type", 1), &((_genmesh__track *)a)->type))
		return NULL;
	short soap_flag_genmesh__keyframes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genmesh__keyframes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__keyframes(soap, "genmesh:keyframes", &(a->_genmesh__track::genmesh__keyframes), ""))
				{	soap_flag_genmesh__keyframes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__track *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__track, 0, sizeof(_genmesh__track), 0, soap_copy__genmesh__track);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genmesh__keyframes1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__track * SOAP_FMAC6 soap_new__genmesh__track(struct soap *soap, int n)
{	return soap_instantiate__genmesh__track(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__track(struct soap *soap, _genmesh__track *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__track * SOAP_FMAC4 soap_instantiate__genmesh__track(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__track(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__track, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__track;
		if (size)
			*size = sizeof(_genmesh__track);
		((_genmesh__track*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__track[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__track);
		for (int i = 0; i < n; i++)
			((_genmesh__track*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__track*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__track(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__track %p -> %p\n", q, p));
	*(_genmesh__track*)p = *(_genmesh__track*)q;
}

void _genmesh__tracks::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__track(soap, &this->_genmesh__tracks::genmesh__track);
	/* transient soap skipped */
}

void _genmesh__tracks::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__track(soap, &this->_genmesh__tracks::genmesh__track);
	/* transient soap skipped */
}

int _genmesh__tracks::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__tracks);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__tracks::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__tracks(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__tracks(struct soap *soap, const char *tag, int id, const _genmesh__tracks *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__tracks), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__track(soap, "genmesh:track", -1, &(a->_genmesh__tracks::genmesh__track), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__tracks::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__tracks(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__tracks * SOAP_FMAC4 soap_get__genmesh__tracks(struct soap *soap, _genmesh__tracks *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__tracks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__tracks::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__tracks(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__tracks * SOAP_FMAC4 soap_in__genmesh__tracks(struct soap *soap, const char *tag, _genmesh__tracks *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__tracks *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__tracks, sizeof(_genmesh__tracks), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__tracks)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__tracks *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__track(soap, "genmesh:track", &(a->_genmesh__tracks::genmesh__track), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__tracks *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__tracks, 0, sizeof(_genmesh__tracks), 0, soap_copy__genmesh__tracks);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__tracks * SOAP_FMAC6 soap_new__genmesh__tracks(struct soap *soap, int n)
{	return soap_instantiate__genmesh__tracks(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__tracks(struct soap *soap, _genmesh__tracks *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__tracks * SOAP_FMAC4 soap_instantiate__genmesh__tracks(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__tracks(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__tracks, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__tracks;
		if (size)
			*size = sizeof(_genmesh__tracks);
		((_genmesh__tracks*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__tracks[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__tracks);
		for (int i = 0; i < n; i++)
			((_genmesh__tracks*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__tracks*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__tracks(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__tracks %p -> %p\n", q, p));
	*(_genmesh__tracks*)p = *(_genmesh__tracks*)q;
}

void _genmesh__animation::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_genmesh__animation::genmesh__tracks = NULL;
	soap_default_std__string(soap, &this->_genmesh__animation::name);
	soap_default_std__string(soap, &this->_genmesh__animation::length);
	/* transient soap skipped */
}

void _genmesh__animation::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_genmesh__tracks(soap, &this->_genmesh__animation::genmesh__tracks);
	/* transient soap skipped */
}

int _genmesh__animation::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__animation);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__animation::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__animation(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__animation(struct soap *soap, const char *tag, int id, const _genmesh__animation *a, const char *type)
{
	if (!((_genmesh__animation *)a)->name.empty())
		soap_set_attr(soap, "name", ((_genmesh__animation *)a)->name.c_str());
	if (!((_genmesh__animation *)a)->length.empty())
		soap_set_attr(soap, "length", ((_genmesh__animation *)a)->length.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__animation), type))
		return soap->error;
	if (soap_out_PointerTo_genmesh__tracks(soap, "genmesh:tracks", -1, &(a->_genmesh__animation::genmesh__tracks), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__animation::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__animation(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__animation * SOAP_FMAC4 soap_get__genmesh__animation(struct soap *soap, _genmesh__animation *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__animation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__animation::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__animation(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__animation * SOAP_FMAC4 soap_in__genmesh__animation(struct soap *soap, const char *tag, _genmesh__animation *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__animation *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__animation, sizeof(_genmesh__animation), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__animation)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__animation *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__animation *)a)->name.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "length", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__animation *)a)->length.assign(s);
		}
	}
	short soap_flag_genmesh__tracks1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genmesh__tracks1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__tracks(soap, "genmesh:tracks", &(a->_genmesh__animation::genmesh__tracks), ""))
				{	soap_flag_genmesh__tracks1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__animation *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__animation, 0, sizeof(_genmesh__animation), 0, soap_copy__genmesh__animation);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genmesh__tracks1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__animation * SOAP_FMAC6 soap_new__genmesh__animation(struct soap *soap, int n)
{	return soap_instantiate__genmesh__animation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__animation(struct soap *soap, _genmesh__animation *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__animation * SOAP_FMAC4 soap_instantiate__genmesh__animation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__animation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__animation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__animation;
		if (size)
			*size = sizeof(_genmesh__animation);
		((_genmesh__animation*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__animation[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__animation);
		for (int i = 0; i < n; i++)
			((_genmesh__animation*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__animation*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__animation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__animation %p -> %p\n", q, p));
	*(_genmesh__animation*)p = *(_genmesh__animation*)q;
}

void _genmesh__animations::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__animation(soap, &this->_genmesh__animations::genmesh__animation);
	/* transient soap skipped */
}

void _genmesh__animations::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__animation(soap, &this->_genmesh__animations::genmesh__animation);
	/* transient soap skipped */
}

int _genmesh__animations::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__animations);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__animations::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__animations(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__animations(struct soap *soap, const char *tag, int id, const _genmesh__animations *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__animations), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__animation(soap, "genmesh:animation", -1, &(a->_genmesh__animations::genmesh__animation), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__animations::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__animations(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__animations * SOAP_FMAC4 soap_get__genmesh__animations(struct soap *soap, _genmesh__animations *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__animations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__animations::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__animations(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__animations * SOAP_FMAC4 soap_in__genmesh__animations(struct soap *soap, const char *tag, _genmesh__animations *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__animations *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__animations, sizeof(_genmesh__animations), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__animations)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__animations *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__animation(soap, "genmesh:animation", &(a->_genmesh__animations::genmesh__animation), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__animations *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__animations, 0, sizeof(_genmesh__animations), 0, soap_copy__genmesh__animations);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__animations * SOAP_FMAC6 soap_new__genmesh__animations(struct soap *soap, int n)
{	return soap_instantiate__genmesh__animations(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__animations(struct soap *soap, _genmesh__animations *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__animations * SOAP_FMAC4 soap_instantiate__genmesh__animations(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__animations(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__animations, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__animations;
		if (size)
			*size = sizeof(_genmesh__animations);
		((_genmesh__animations*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__animations[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__animations);
		for (int i = 0; i < n; i++)
			((_genmesh__animations*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__animations*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__animations(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__animations %p -> %p\n", q, p));
	*(_genmesh__animations*)p = *(_genmesh__animations*)q;
}

void _genmesh__poseoffset::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genmesh__poseoffset::index);
	soap_default_std__string(soap, &this->_genmesh__poseoffset::x);
	soap_default_std__string(soap, &this->_genmesh__poseoffset::y);
	soap_default_std__string(soap, &this->_genmesh__poseoffset::z);
	/* transient soap skipped */
}

void _genmesh__poseoffset::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genmesh__poseoffset::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__poseoffset);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__poseoffset::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__poseoffset(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__poseoffset(struct soap *soap, const char *tag, int id, const _genmesh__poseoffset *a, const char *type)
{
	if (!((_genmesh__poseoffset *)a)->index.empty())
		soap_set_attr(soap, "index", ((_genmesh__poseoffset *)a)->index.c_str());
	if (!((_genmesh__poseoffset *)a)->x.empty())
		soap_set_attr(soap, "x", ((_genmesh__poseoffset *)a)->x.c_str());
	if (!((_genmesh__poseoffset *)a)->y.empty())
		soap_set_attr(soap, "y", ((_genmesh__poseoffset *)a)->y.c_str());
	if (!((_genmesh__poseoffset *)a)->z.empty())
		soap_set_attr(soap, "z", ((_genmesh__poseoffset *)a)->z.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__poseoffset), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__poseoffset::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__poseoffset(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__poseoffset * SOAP_FMAC4 soap_get__genmesh__poseoffset(struct soap *soap, _genmesh__poseoffset *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__poseoffset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__poseoffset::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__poseoffset(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__poseoffset * SOAP_FMAC4 soap_in__genmesh__poseoffset(struct soap *soap, const char *tag, _genmesh__poseoffset *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__poseoffset *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__poseoffset, sizeof(_genmesh__poseoffset), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__poseoffset)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__poseoffset *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "index", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__poseoffset *)a)->index.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "x", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__poseoffset *)a)->x.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "y", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__poseoffset *)a)->y.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "z", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__poseoffset *)a)->z.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__poseoffset *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__poseoffset, 0, sizeof(_genmesh__poseoffset), 0, soap_copy__genmesh__poseoffset);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__poseoffset * SOAP_FMAC6 soap_new__genmesh__poseoffset(struct soap *soap, int n)
{	return soap_instantiate__genmesh__poseoffset(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__poseoffset(struct soap *soap, _genmesh__poseoffset *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__poseoffset * SOAP_FMAC4 soap_instantiate__genmesh__poseoffset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__poseoffset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__poseoffset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__poseoffset;
		if (size)
			*size = sizeof(_genmesh__poseoffset);
		((_genmesh__poseoffset*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__poseoffset[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__poseoffset);
		for (int i = 0; i < n; i++)
			((_genmesh__poseoffset*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__poseoffset*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__poseoffset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__poseoffset %p -> %p\n", q, p));
	*(_genmesh__poseoffset*)p = *(_genmesh__poseoffset*)q;
}

void _genmesh__pose::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__poseoffset(soap, &this->_genmesh__pose::genmesh__poseoffset);
	soap_default__genmesh__pose_target(soap, &this->_genmesh__pose::target);
	this->_genmesh__pose::index = "0";
	this->_genmesh__pose::name = "";
	/* transient soap skipped */
}

void _genmesh__pose::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__poseoffset(soap, &this->_genmesh__pose::genmesh__poseoffset);
	/* transient soap skipped */
}

int _genmesh__pose::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__pose);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__pose::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__pose(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__pose(struct soap *soap, const char *tag, int id, const _genmesh__pose *a, const char *type)
{
	soap_set_attr(soap, "target", soap__genmesh__pose_target2s(soap, ((_genmesh__pose *)a)->target));
	if (!((_genmesh__pose *)a)->index.empty())
		soap_set_attr(soap, "index", ((_genmesh__pose *)a)->index.c_str());
	if (!((_genmesh__pose *)a)->name.empty())
		soap_set_attr(soap, "name", ((_genmesh__pose *)a)->name.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__pose), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__poseoffset(soap, "genmesh:poseoffset", -1, &(a->_genmesh__pose::genmesh__poseoffset), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__pose::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__pose(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__pose * SOAP_FMAC4 soap_get__genmesh__pose(struct soap *soap, _genmesh__pose *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__pose(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__pose::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__pose(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__pose * SOAP_FMAC4 soap_in__genmesh__pose(struct soap *soap, const char *tag, _genmesh__pose *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__pose *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__pose, sizeof(_genmesh__pose), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__pose)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__pose *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2_genmesh__pose_target(soap, soap_attr_value(soap, "target", 1), &((_genmesh__pose *)a)->target))
		return NULL;
	{	const char *t = soap_attr_value(soap, "index", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__pose *)a)->index.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__pose *)a)->name.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__poseoffset(soap, "genmesh:poseoffset", &(a->_genmesh__pose::genmesh__poseoffset), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__pose *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__pose, 0, sizeof(_genmesh__pose), 0, soap_copy__genmesh__pose);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__pose * SOAP_FMAC6 soap_new__genmesh__pose(struct soap *soap, int n)
{	return soap_instantiate__genmesh__pose(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__pose(struct soap *soap, _genmesh__pose *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__pose * SOAP_FMAC4 soap_instantiate__genmesh__pose(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__pose(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__pose, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__pose;
		if (size)
			*size = sizeof(_genmesh__pose);
		((_genmesh__pose*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__pose[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__pose);
		for (int i = 0; i < n; i++)
			((_genmesh__pose*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__pose*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__pose(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__pose %p -> %p\n", q, p));
	*(_genmesh__pose*)p = *(_genmesh__pose*)q;
}

void _genmesh__poses::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__pose(soap, &this->_genmesh__poses::genmesh__pose);
	/* transient soap skipped */
}

void _genmesh__poses::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__pose(soap, &this->_genmesh__poses::genmesh__pose);
	/* transient soap skipped */
}

int _genmesh__poses::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__poses);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__poses::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__poses(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__poses(struct soap *soap, const char *tag, int id, const _genmesh__poses *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__poses), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__pose(soap, "genmesh:pose", -1, &(a->_genmesh__poses::genmesh__pose), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__poses::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__poses(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__poses * SOAP_FMAC4 soap_get__genmesh__poses(struct soap *soap, _genmesh__poses *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__poses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__poses::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__poses(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__poses * SOAP_FMAC4 soap_in__genmesh__poses(struct soap *soap, const char *tag, _genmesh__poses *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__poses *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__poses, sizeof(_genmesh__poses), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__poses)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__poses *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__pose(soap, "genmesh:pose", &(a->_genmesh__poses::genmesh__pose), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__poses *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__poses, 0, sizeof(_genmesh__poses), 0, soap_copy__genmesh__poses);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__poses * SOAP_FMAC6 soap_new__genmesh__poses(struct soap *soap, int n)
{	return soap_instantiate__genmesh__poses(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__poses(struct soap *soap, _genmesh__poses *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__poses * SOAP_FMAC4 soap_instantiate__genmesh__poses(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__poses(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__poses, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__poses;
		if (size)
			*size = sizeof(_genmesh__poses);
		((_genmesh__poses*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__poses[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__poses);
		for (int i = 0; i < n; i++)
			((_genmesh__poses*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__poses*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__poses(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__poses %p -> %p\n", q, p));
	*(_genmesh__poses*)p = *(_genmesh__poses*)q;
}

void _genmesh__submeshname::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genmesh__submeshname::name);
	soap_default_std__string(soap, &this->_genmesh__submeshname::index);
	/* transient soap skipped */
}

void _genmesh__submeshname::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genmesh__submeshname::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__submeshname);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__submeshname::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__submeshname(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__submeshname(struct soap *soap, const char *tag, int id, const _genmesh__submeshname *a, const char *type)
{
	if (!((_genmesh__submeshname *)a)->name.empty())
		soap_set_attr(soap, "name", ((_genmesh__submeshname *)a)->name.c_str());
	if (!((_genmesh__submeshname *)a)->index.empty())
		soap_set_attr(soap, "index", ((_genmesh__submeshname *)a)->index.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__submeshname), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__submeshname::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__submeshname(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__submeshname * SOAP_FMAC4 soap_get__genmesh__submeshname(struct soap *soap, _genmesh__submeshname *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__submeshname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__submeshname::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__submeshname(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__submeshname * SOAP_FMAC4 soap_in__genmesh__submeshname(struct soap *soap, const char *tag, _genmesh__submeshname *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__submeshname *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__submeshname, sizeof(_genmesh__submeshname), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__submeshname)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__submeshname *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__submeshname *)a)->name.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "index", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__submeshname *)a)->index.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__submeshname *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__submeshname, 0, sizeof(_genmesh__submeshname), 0, soap_copy__genmesh__submeshname);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__submeshname * SOAP_FMAC6 soap_new__genmesh__submeshname(struct soap *soap, int n)
{	return soap_instantiate__genmesh__submeshname(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__submeshname(struct soap *soap, _genmesh__submeshname *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__submeshname * SOAP_FMAC4 soap_instantiate__genmesh__submeshname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__submeshname(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__submeshname, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__submeshname;
		if (size)
			*size = sizeof(_genmesh__submeshname);
		((_genmesh__submeshname*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__submeshname[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__submeshname);
		for (int i = 0; i < n; i++)
			((_genmesh__submeshname*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__submeshname*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__submeshname(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__submeshname %p -> %p\n", q, p));
	*(_genmesh__submeshname*)p = *(_genmesh__submeshname*)q;
}

void _genmesh__submeshnames::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__submeshname(soap, &this->_genmesh__submeshnames::genmesh__submeshname);
	/* transient soap skipped */
}

void _genmesh__submeshnames::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__submeshname(soap, &this->_genmesh__submeshnames::genmesh__submeshname);
	/* transient soap skipped */
}

int _genmesh__submeshnames::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__submeshnames);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__submeshnames::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__submeshnames(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__submeshnames(struct soap *soap, const char *tag, int id, const _genmesh__submeshnames *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__submeshnames), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__submeshname(soap, "genmesh:submeshname", -1, &(a->_genmesh__submeshnames::genmesh__submeshname), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__submeshnames::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__submeshnames(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__submeshnames * SOAP_FMAC4 soap_get__genmesh__submeshnames(struct soap *soap, _genmesh__submeshnames *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__submeshnames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__submeshnames::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__submeshnames(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__submeshnames * SOAP_FMAC4 soap_in__genmesh__submeshnames(struct soap *soap, const char *tag, _genmesh__submeshnames *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__submeshnames *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__submeshnames, sizeof(_genmesh__submeshnames), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__submeshnames)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__submeshnames *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__submeshname(soap, "genmesh:submeshname", &(a->_genmesh__submeshnames::genmesh__submeshname), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__submeshnames *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__submeshnames, 0, sizeof(_genmesh__submeshnames), 0, soap_copy__genmesh__submeshnames);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__submeshnames * SOAP_FMAC6 soap_new__genmesh__submeshnames(struct soap *soap, int n)
{	return soap_instantiate__genmesh__submeshnames(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__submeshnames(struct soap *soap, _genmesh__submeshnames *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__submeshnames * SOAP_FMAC4 soap_instantiate__genmesh__submeshnames(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__submeshnames(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__submeshnames, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__submeshnames;
		if (size)
			*size = sizeof(_genmesh__submeshnames);
		((_genmesh__submeshnames*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__submeshnames[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__submeshnames);
		for (int i = 0; i < n; i++)
			((_genmesh__submeshnames*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__submeshnames*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__submeshnames(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__submeshnames %p -> %p\n", q, p));
	*(_genmesh__submeshnames*)p = *(_genmesh__submeshnames*)q;
}

void _genmesh__texcoord::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genmesh__texcoord::u);
	this->_genmesh__texcoord::v = "0";
	this->_genmesh__texcoord::w = "0";
	/* transient soap skipped */
}

void _genmesh__texcoord::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genmesh__texcoord::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__texcoord);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__texcoord::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__texcoord(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__texcoord(struct soap *soap, const char *tag, int id, const _genmesh__texcoord *a, const char *type)
{
	if (!((_genmesh__texcoord *)a)->u.empty())
		soap_set_attr(soap, "u", ((_genmesh__texcoord *)a)->u.c_str());
	if (!((_genmesh__texcoord *)a)->v.empty())
		soap_set_attr(soap, "v", ((_genmesh__texcoord *)a)->v.c_str());
	if (!((_genmesh__texcoord *)a)->w.empty())
		soap_set_attr(soap, "w", ((_genmesh__texcoord *)a)->w.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__texcoord), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__texcoord::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__texcoord(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__texcoord * SOAP_FMAC4 soap_get__genmesh__texcoord(struct soap *soap, _genmesh__texcoord *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__texcoord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__texcoord::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__texcoord(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__texcoord * SOAP_FMAC4 soap_in__genmesh__texcoord(struct soap *soap, const char *tag, _genmesh__texcoord *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__texcoord *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__texcoord, sizeof(_genmesh__texcoord), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__texcoord)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__texcoord *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "u", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__texcoord *)a)->u.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "v", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__texcoord *)a)->v.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "w", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__texcoord *)a)->w.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__texcoord *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__texcoord, 0, sizeof(_genmesh__texcoord), 0, soap_copy__genmesh__texcoord);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__texcoord * SOAP_FMAC6 soap_new__genmesh__texcoord(struct soap *soap, int n)
{	return soap_instantiate__genmesh__texcoord(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__texcoord(struct soap *soap, _genmesh__texcoord *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__texcoord * SOAP_FMAC4 soap_instantiate__genmesh__texcoord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__texcoord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__texcoord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__texcoord;
		if (size)
			*size = sizeof(_genmesh__texcoord);
		((_genmesh__texcoord*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__texcoord[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__texcoord);
		for (int i = 0; i < n; i++)
			((_genmesh__texcoord*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__texcoord*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__texcoord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__texcoord %p -> %p\n", q, p));
	*(_genmesh__texcoord*)p = *(_genmesh__texcoord*)q;
}

void _genmesh__colour_USCOREspecular::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genmesh__colour_USCOREspecular::value);
	/* transient soap skipped */
}

void _genmesh__colour_USCOREspecular::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genmesh__colour_USCOREspecular::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__colour_USCOREspecular);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__colour_USCOREspecular::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__colour_USCOREspecular(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__colour_USCOREspecular(struct soap *soap, const char *tag, int id, const _genmesh__colour_USCOREspecular *a, const char *type)
{
	if (!((_genmesh__colour_USCOREspecular *)a)->value.empty())
		soap_set_attr(soap, "value", ((_genmesh__colour_USCOREspecular *)a)->value.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__colour_USCOREspecular), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__colour_USCOREspecular::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__colour_USCOREspecular(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__colour_USCOREspecular * SOAP_FMAC4 soap_get__genmesh__colour_USCOREspecular(struct soap *soap, _genmesh__colour_USCOREspecular *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__colour_USCOREspecular(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__colour_USCOREspecular::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__colour_USCOREspecular(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__colour_USCOREspecular * SOAP_FMAC4 soap_in__genmesh__colour_USCOREspecular(struct soap *soap, const char *tag, _genmesh__colour_USCOREspecular *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__colour_USCOREspecular *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__colour_USCOREspecular, sizeof(_genmesh__colour_USCOREspecular), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__colour_USCOREspecular)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__colour_USCOREspecular *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "value", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__colour_USCOREspecular *)a)->value.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__colour_USCOREspecular *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__colour_USCOREspecular, 0, sizeof(_genmesh__colour_USCOREspecular), 0, soap_copy__genmesh__colour_USCOREspecular);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__colour_USCOREspecular * SOAP_FMAC6 soap_new__genmesh__colour_USCOREspecular(struct soap *soap, int n)
{	return soap_instantiate__genmesh__colour_USCOREspecular(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__colour_USCOREspecular(struct soap *soap, _genmesh__colour_USCOREspecular *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__colour_USCOREspecular * SOAP_FMAC4 soap_instantiate__genmesh__colour_USCOREspecular(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__colour_USCOREspecular(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__colour_USCOREspecular, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__colour_USCOREspecular;
		if (size)
			*size = sizeof(_genmesh__colour_USCOREspecular);
		((_genmesh__colour_USCOREspecular*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__colour_USCOREspecular[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__colour_USCOREspecular);
		for (int i = 0; i < n; i++)
			((_genmesh__colour_USCOREspecular*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__colour_USCOREspecular*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__colour_USCOREspecular(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__colour_USCOREspecular %p -> %p\n", q, p));
	*(_genmesh__colour_USCOREspecular*)p = *(_genmesh__colour_USCOREspecular*)q;
}

void _genmesh__colour_USCOREdiffuse::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genmesh__colour_USCOREdiffuse::value);
	/* transient soap skipped */
}

void _genmesh__colour_USCOREdiffuse::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genmesh__colour_USCOREdiffuse::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__colour_USCOREdiffuse);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__colour_USCOREdiffuse::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__colour_USCOREdiffuse(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__colour_USCOREdiffuse(struct soap *soap, const char *tag, int id, const _genmesh__colour_USCOREdiffuse *a, const char *type)
{
	if (!((_genmesh__colour_USCOREdiffuse *)a)->value.empty())
		soap_set_attr(soap, "value", ((_genmesh__colour_USCOREdiffuse *)a)->value.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__colour_USCOREdiffuse), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__colour_USCOREdiffuse::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__colour_USCOREdiffuse(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__colour_USCOREdiffuse * SOAP_FMAC4 soap_get__genmesh__colour_USCOREdiffuse(struct soap *soap, _genmesh__colour_USCOREdiffuse *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__colour_USCOREdiffuse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__colour_USCOREdiffuse::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__colour_USCOREdiffuse(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__colour_USCOREdiffuse * SOAP_FMAC4 soap_in__genmesh__colour_USCOREdiffuse(struct soap *soap, const char *tag, _genmesh__colour_USCOREdiffuse *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__colour_USCOREdiffuse *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__colour_USCOREdiffuse, sizeof(_genmesh__colour_USCOREdiffuse), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__colour_USCOREdiffuse)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__colour_USCOREdiffuse *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "value", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__colour_USCOREdiffuse *)a)->value.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__colour_USCOREdiffuse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__colour_USCOREdiffuse, 0, sizeof(_genmesh__colour_USCOREdiffuse), 0, soap_copy__genmesh__colour_USCOREdiffuse);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__colour_USCOREdiffuse * SOAP_FMAC6 soap_new__genmesh__colour_USCOREdiffuse(struct soap *soap, int n)
{	return soap_instantiate__genmesh__colour_USCOREdiffuse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__colour_USCOREdiffuse(struct soap *soap, _genmesh__colour_USCOREdiffuse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__colour_USCOREdiffuse * SOAP_FMAC4 soap_instantiate__genmesh__colour_USCOREdiffuse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__colour_USCOREdiffuse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__colour_USCOREdiffuse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__colour_USCOREdiffuse;
		if (size)
			*size = sizeof(_genmesh__colour_USCOREdiffuse);
		((_genmesh__colour_USCOREdiffuse*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__colour_USCOREdiffuse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__colour_USCOREdiffuse);
		for (int i = 0; i < n; i++)
			((_genmesh__colour_USCOREdiffuse*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__colour_USCOREdiffuse*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__colour_USCOREdiffuse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__colour_USCOREdiffuse %p -> %p\n", q, p));
	*(_genmesh__colour_USCOREdiffuse*)p = *(_genmesh__colour_USCOREdiffuse*)q;
}

void _genmesh__binormal::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genmesh__binormal::x);
	soap_default_std__string(soap, &this->_genmesh__binormal::y);
	soap_default_std__string(soap, &this->_genmesh__binormal::z);
	/* transient soap skipped */
}

void _genmesh__binormal::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genmesh__binormal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__binormal);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__binormal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__binormal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__binormal(struct soap *soap, const char *tag, int id, const _genmesh__binormal *a, const char *type)
{
	if (!((_genmesh__binormal *)a)->x.empty())
		soap_set_attr(soap, "x", ((_genmesh__binormal *)a)->x.c_str());
	if (!((_genmesh__binormal *)a)->y.empty())
		soap_set_attr(soap, "y", ((_genmesh__binormal *)a)->y.c_str());
	if (!((_genmesh__binormal *)a)->z.empty())
		soap_set_attr(soap, "z", ((_genmesh__binormal *)a)->z.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__binormal), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__binormal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__binormal(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__binormal * SOAP_FMAC4 soap_get__genmesh__binormal(struct soap *soap, _genmesh__binormal *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__binormal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__binormal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__binormal(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__binormal * SOAP_FMAC4 soap_in__genmesh__binormal(struct soap *soap, const char *tag, _genmesh__binormal *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__binormal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__binormal, sizeof(_genmesh__binormal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__binormal)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__binormal *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "x", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__binormal *)a)->x.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "y", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__binormal *)a)->y.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "z", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__binormal *)a)->z.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__binormal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__binormal, 0, sizeof(_genmesh__binormal), 0, soap_copy__genmesh__binormal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__binormal * SOAP_FMAC6 soap_new__genmesh__binormal(struct soap *soap, int n)
{	return soap_instantiate__genmesh__binormal(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__binormal(struct soap *soap, _genmesh__binormal *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__binormal * SOAP_FMAC4 soap_instantiate__genmesh__binormal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__binormal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__binormal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__binormal;
		if (size)
			*size = sizeof(_genmesh__binormal);
		((_genmesh__binormal*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__binormal[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__binormal);
		for (int i = 0; i < n; i++)
			((_genmesh__binormal*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__binormal*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__binormal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__binormal %p -> %p\n", q, p));
	*(_genmesh__binormal*)p = *(_genmesh__binormal*)q;
}

void _genmesh__tangent::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genmesh__tangent::x);
	soap_default_std__string(soap, &this->_genmesh__tangent::y);
	soap_default_std__string(soap, &this->_genmesh__tangent::z);
	this->_genmesh__tangent::w = "1";
	/* transient soap skipped */
}

void _genmesh__tangent::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genmesh__tangent::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__tangent);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__tangent::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__tangent(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__tangent(struct soap *soap, const char *tag, int id, const _genmesh__tangent *a, const char *type)
{
	if (!((_genmesh__tangent *)a)->x.empty())
		soap_set_attr(soap, "x", ((_genmesh__tangent *)a)->x.c_str());
	if (!((_genmesh__tangent *)a)->y.empty())
		soap_set_attr(soap, "y", ((_genmesh__tangent *)a)->y.c_str());
	if (!((_genmesh__tangent *)a)->z.empty())
		soap_set_attr(soap, "z", ((_genmesh__tangent *)a)->z.c_str());
	if (!((_genmesh__tangent *)a)->w.empty())
		soap_set_attr(soap, "w", ((_genmesh__tangent *)a)->w.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__tangent), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__tangent::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__tangent(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__tangent * SOAP_FMAC4 soap_get__genmesh__tangent(struct soap *soap, _genmesh__tangent *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__tangent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__tangent::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__tangent(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__tangent * SOAP_FMAC4 soap_in__genmesh__tangent(struct soap *soap, const char *tag, _genmesh__tangent *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__tangent *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__tangent, sizeof(_genmesh__tangent), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__tangent)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__tangent *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "x", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__tangent *)a)->x.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "y", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__tangent *)a)->y.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "z", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__tangent *)a)->z.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "w", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__tangent *)a)->w.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__tangent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__tangent, 0, sizeof(_genmesh__tangent), 0, soap_copy__genmesh__tangent);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__tangent * SOAP_FMAC6 soap_new__genmesh__tangent(struct soap *soap, int n)
{	return soap_instantiate__genmesh__tangent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__tangent(struct soap *soap, _genmesh__tangent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__tangent * SOAP_FMAC4 soap_instantiate__genmesh__tangent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__tangent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__tangent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__tangent;
		if (size)
			*size = sizeof(_genmesh__tangent);
		((_genmesh__tangent*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__tangent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__tangent);
		for (int i = 0; i < n; i++)
			((_genmesh__tangent*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__tangent*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__tangent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__tangent %p -> %p\n", q, p));
	*(_genmesh__tangent*)p = *(_genmesh__tangent*)q;
}

void _genmesh__normal::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genmesh__normal::x);
	soap_default_std__string(soap, &this->_genmesh__normal::y);
	soap_default_std__string(soap, &this->_genmesh__normal::z);
	/* transient soap skipped */
}

void _genmesh__normal::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genmesh__normal::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__normal);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__normal::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__normal(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__normal(struct soap *soap, const char *tag, int id, const _genmesh__normal *a, const char *type)
{
	if (!((_genmesh__normal *)a)->x.empty())
		soap_set_attr(soap, "x", ((_genmesh__normal *)a)->x.c_str());
	if (!((_genmesh__normal *)a)->y.empty())
		soap_set_attr(soap, "y", ((_genmesh__normal *)a)->y.c_str());
	if (!((_genmesh__normal *)a)->z.empty())
		soap_set_attr(soap, "z", ((_genmesh__normal *)a)->z.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__normal), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__normal::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__normal(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__normal * SOAP_FMAC4 soap_get__genmesh__normal(struct soap *soap, _genmesh__normal *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__normal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__normal::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__normal(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__normal * SOAP_FMAC4 soap_in__genmesh__normal(struct soap *soap, const char *tag, _genmesh__normal *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__normal *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__normal, sizeof(_genmesh__normal), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__normal)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__normal *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "x", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__normal *)a)->x.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "y", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__normal *)a)->y.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "z", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__normal *)a)->z.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__normal *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__normal, 0, sizeof(_genmesh__normal), 0, soap_copy__genmesh__normal);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__normal * SOAP_FMAC6 soap_new__genmesh__normal(struct soap *soap, int n)
{	return soap_instantiate__genmesh__normal(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__normal(struct soap *soap, _genmesh__normal *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__normal * SOAP_FMAC4 soap_instantiate__genmesh__normal(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__normal(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__normal, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__normal;
		if (size)
			*size = sizeof(_genmesh__normal);
		((_genmesh__normal*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__normal[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__normal);
		for (int i = 0; i < n; i++)
			((_genmesh__normal*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__normal*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__normal(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__normal %p -> %p\n", q, p));
	*(_genmesh__normal*)p = *(_genmesh__normal*)q;
}

void _genmesh__position::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genmesh__position::x);
	soap_default_std__string(soap, &this->_genmesh__position::y);
	soap_default_std__string(soap, &this->_genmesh__position::z);
	/* transient soap skipped */
}

void _genmesh__position::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genmesh__position::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__position);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__position::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__position(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__position(struct soap *soap, const char *tag, int id, const _genmesh__position *a, const char *type)
{
	if (!((_genmesh__position *)a)->x.empty())
		soap_set_attr(soap, "x", ((_genmesh__position *)a)->x.c_str());
	if (!((_genmesh__position *)a)->y.empty())
		soap_set_attr(soap, "y", ((_genmesh__position *)a)->y.c_str());
	if (!((_genmesh__position *)a)->z.empty())
		soap_set_attr(soap, "z", ((_genmesh__position *)a)->z.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__position), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__position::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__position(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__position * SOAP_FMAC4 soap_get__genmesh__position(struct soap *soap, _genmesh__position *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__position(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__position::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__position(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__position * SOAP_FMAC4 soap_in__genmesh__position(struct soap *soap, const char *tag, _genmesh__position *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__position *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__position, sizeof(_genmesh__position), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__position)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__position *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "x", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__position *)a)->x.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "y", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__position *)a)->y.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "z", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__position *)a)->z.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__position *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__position, 0, sizeof(_genmesh__position), 0, soap_copy__genmesh__position);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__position * SOAP_FMAC6 soap_new__genmesh__position(struct soap *soap, int n)
{	return soap_instantiate__genmesh__position(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__position(struct soap *soap, _genmesh__position *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__position * SOAP_FMAC4 soap_instantiate__genmesh__position(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__position(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__position, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__position;
		if (size)
			*size = sizeof(_genmesh__position);
		((_genmesh__position*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__position[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__position);
		for (int i = 0; i < n; i++)
			((_genmesh__position*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__position*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__position(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__position %p -> %p\n", q, p));
	*(_genmesh__position*)p = *(_genmesh__position*)q;
}

void _genmesh__vertex::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_genmesh__vertex::genmesh__position = NULL;
	this->_genmesh__vertex::genmesh__normal = NULL;
	this->_genmesh__vertex::genmesh__tangent = NULL;
	this->_genmesh__vertex::genmesh__binormal = NULL;
	this->_genmesh__vertex::genmesh__colour_USCOREdiffuse = NULL;
	this->_genmesh__vertex::genmesh__colour_USCOREspecular = NULL;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__texcoord(soap, &this->_genmesh__vertex::genmesh__texcoord);
	/* transient soap skipped */
}

void _genmesh__vertex::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_genmesh__position(soap, &this->_genmesh__vertex::genmesh__position);
	soap_serialize_PointerTo_genmesh__normal(soap, &this->_genmesh__vertex::genmesh__normal);
	soap_serialize_PointerTo_genmesh__tangent(soap, &this->_genmesh__vertex::genmesh__tangent);
	soap_serialize_PointerTo_genmesh__binormal(soap, &this->_genmesh__vertex::genmesh__binormal);
	soap_serialize_PointerTo_genmesh__colour_USCOREdiffuse(soap, &this->_genmesh__vertex::genmesh__colour_USCOREdiffuse);
	soap_serialize_PointerTo_genmesh__colour_USCOREspecular(soap, &this->_genmesh__vertex::genmesh__colour_USCOREspecular);
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__texcoord(soap, &this->_genmesh__vertex::genmesh__texcoord);
	/* transient soap skipped */
}

int _genmesh__vertex::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__vertex);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__vertex::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__vertex(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertex(struct soap *soap, const char *tag, int id, const _genmesh__vertex *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertex), type))
		return soap->error;
	if (soap_out_PointerTo_genmesh__position(soap, "genmesh:position", -1, &(a->_genmesh__vertex::genmesh__position), ""))
		return soap->error;
	if (soap_out_PointerTo_genmesh__normal(soap, "genmesh:normal", -1, &(a->_genmesh__vertex::genmesh__normal), ""))
		return soap->error;
	if (soap_out_PointerTo_genmesh__tangent(soap, "genmesh:tangent", -1, &(a->_genmesh__vertex::genmesh__tangent), ""))
		return soap->error;
	if (soap_out_PointerTo_genmesh__binormal(soap, "genmesh:binormal", -1, &(a->_genmesh__vertex::genmesh__binormal), ""))
		return soap->error;
	if (soap_out_PointerTo_genmesh__colour_USCOREdiffuse(soap, "genmesh:colour_diffuse", -1, &(a->_genmesh__vertex::genmesh__colour_USCOREdiffuse), ""))
		return soap->error;
	if (soap_out_PointerTo_genmesh__colour_USCOREspecular(soap, "genmesh:colour_specular", -1, &(a->_genmesh__vertex::genmesh__colour_USCOREspecular), ""))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__texcoord(soap, "genmesh:texcoord", -1, &(a->_genmesh__vertex::genmesh__texcoord), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__vertex::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__vertex(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__vertex * SOAP_FMAC4 soap_get__genmesh__vertex(struct soap *soap, _genmesh__vertex *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__vertex::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__vertex(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__vertex * SOAP_FMAC4 soap_in__genmesh__vertex(struct soap *soap, const char *tag, _genmesh__vertex *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__vertex *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertex, sizeof(_genmesh__vertex), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__vertex)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__vertex *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_genmesh__position1 = 1, soap_flag_genmesh__normal1 = 1, soap_flag_genmesh__tangent1 = 1, soap_flag_genmesh__binormal1 = 1, soap_flag_genmesh__colour_USCOREdiffuse1 = 1, soap_flag_genmesh__colour_USCOREspecular1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genmesh__position1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__position(soap, "genmesh:position", &(a->_genmesh__vertex::genmesh__position), ""))
				{	soap_flag_genmesh__position1--;
					continue;
				}
			if (soap_flag_genmesh__normal1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__normal(soap, "genmesh:normal", &(a->_genmesh__vertex::genmesh__normal), ""))
				{	soap_flag_genmesh__normal1--;
					continue;
				}
			if (soap_flag_genmesh__tangent1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__tangent(soap, "genmesh:tangent", &(a->_genmesh__vertex::genmesh__tangent), ""))
				{	soap_flag_genmesh__tangent1--;
					continue;
				}
			if (soap_flag_genmesh__binormal1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__binormal(soap, "genmesh:binormal", &(a->_genmesh__vertex::genmesh__binormal), ""))
				{	soap_flag_genmesh__binormal1--;
					continue;
				}
			if (soap_flag_genmesh__colour_USCOREdiffuse1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__colour_USCOREdiffuse(soap, "genmesh:colour_diffuse", &(a->_genmesh__vertex::genmesh__colour_USCOREdiffuse), ""))
				{	soap_flag_genmesh__colour_USCOREdiffuse1--;
					continue;
				}
			if (soap_flag_genmesh__colour_USCOREspecular1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__colour_USCOREspecular(soap, "genmesh:colour_specular", &(a->_genmesh__vertex::genmesh__colour_USCOREspecular), ""))
				{	soap_flag_genmesh__colour_USCOREspecular1--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__texcoord(soap, "genmesh:texcoord", &(a->_genmesh__vertex::genmesh__texcoord), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__vertex *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertex, 0, sizeof(_genmesh__vertex), 0, soap_copy__genmesh__vertex);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genmesh__position1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__vertex * SOAP_FMAC6 soap_new__genmesh__vertex(struct soap *soap, int n)
{	return soap_instantiate__genmesh__vertex(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__vertex(struct soap *soap, _genmesh__vertex *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__vertex * SOAP_FMAC4 soap_instantiate__genmesh__vertex(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__vertex(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__vertex, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__vertex;
		if (size)
			*size = sizeof(_genmesh__vertex);
		((_genmesh__vertex*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__vertex[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__vertex);
		for (int i = 0; i < n; i++)
			((_genmesh__vertex*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__vertex*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__vertex(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__vertex %p -> %p\n", q, p));
	*(_genmesh__vertex*)p = *(_genmesh__vertex*)q;
}

void _genmesh__vertexbuffer::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__vertex(soap, &this->_genmesh__vertexbuffer::genmesh__vertex);
	soap_default__genmesh__vertexbuffer_positions(soap, &this->_genmesh__vertexbuffer::positions);
	soap_default__genmesh__vertexbuffer_normals(soap, &this->_genmesh__vertexbuffer::normals);
	soap_default__genmesh__vertexbuffer_colours_USCOREdiffuse(soap, &this->_genmesh__vertexbuffer::colours_USCOREdiffuse);
	soap_default__genmesh__vertexbuffer_colours_USCOREspecular(soap, &this->_genmesh__vertexbuffer::colours_USCOREspecular);
	soap_default__genmesh__vertexbuffer_texture_USCOREcoords(soap, &this->_genmesh__vertexbuffer::texture_USCOREcoords);
	soap_default__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0(soap, &this->_genmesh__vertexbuffer::texture_USCOREcoord_USCOREdimensions_USCORE0);
	soap_default__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1(soap, &this->_genmesh__vertexbuffer::texture_USCOREcoord_USCOREdimensions_USCORE1);
	soap_default__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2(soap, &this->_genmesh__vertexbuffer::texture_USCOREcoord_USCOREdimensions_USCORE2);
	soap_default__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3(soap, &this->_genmesh__vertexbuffer::texture_USCOREcoord_USCOREdimensions_USCORE3);
	soap_default__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4(soap, &this->_genmesh__vertexbuffer::texture_USCOREcoord_USCOREdimensions_USCORE4);
	soap_default__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5(soap, &this->_genmesh__vertexbuffer::texture_USCOREcoord_USCOREdimensions_USCORE5);
	soap_default__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6(soap, &this->_genmesh__vertexbuffer::texture_USCOREcoord_USCOREdimensions_USCORE6);
	soap_default__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7(soap, &this->_genmesh__vertexbuffer::texture_USCOREcoord_USCOREdimensions_USCORE7);
	soap_default__genmesh__vertexbuffer_tangents(soap, &this->_genmesh__vertexbuffer::tangents);
	soap_default__genmesh__vertexbuffer_tangent_USCOREdimensions(soap, &this->_genmesh__vertexbuffer::tangent_USCOREdimensions);
	soap_default__genmesh__vertexbuffer_binormals(soap, &this->_genmesh__vertexbuffer::binormals);
	/* transient soap skipped */
}

void _genmesh__vertexbuffer::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__vertex(soap, &this->_genmesh__vertexbuffer::genmesh__vertex);
	/* transient soap skipped */
}

int _genmesh__vertexbuffer::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__vertexbuffer);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__vertexbuffer::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__vertexbuffer(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexbuffer(struct soap *soap, const char *tag, int id, const _genmesh__vertexbuffer *a, const char *type)
{
	soap_set_attr(soap, "positions", soap__genmesh__vertexbuffer_positions2s(soap, ((_genmesh__vertexbuffer *)a)->positions));
	soap_set_attr(soap, "normals", soap__genmesh__vertexbuffer_normals2s(soap, ((_genmesh__vertexbuffer *)a)->normals));
	soap_set_attr(soap, "colours_diffuse", soap__genmesh__vertexbuffer_colours_USCOREdiffuse2s(soap, ((_genmesh__vertexbuffer *)a)->colours_USCOREdiffuse));
	soap_set_attr(soap, "colours_specular", soap__genmesh__vertexbuffer_colours_USCOREspecular2s(soap, ((_genmesh__vertexbuffer *)a)->colours_USCOREspecular));
	soap_set_attr(soap, "texture_coords", soap__genmesh__vertexbuffer_texture_USCOREcoords2s(soap, ((_genmesh__vertexbuffer *)a)->texture_USCOREcoords));
	soap_set_attr(soap, "texture_coord_dimensions_0", soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE02s(soap, ((_genmesh__vertexbuffer *)a)->texture_USCOREcoord_USCOREdimensions_USCORE0));
	soap_set_attr(soap, "texture_coord_dimensions_1", soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE12s(soap, ((_genmesh__vertexbuffer *)a)->texture_USCOREcoord_USCOREdimensions_USCORE1));
	soap_set_attr(soap, "texture_coord_dimensions_2", soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE22s(soap, ((_genmesh__vertexbuffer *)a)->texture_USCOREcoord_USCOREdimensions_USCORE2));
	soap_set_attr(soap, "texture_coord_dimensions_3", soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE32s(soap, ((_genmesh__vertexbuffer *)a)->texture_USCOREcoord_USCOREdimensions_USCORE3));
	soap_set_attr(soap, "texture_coord_dimensions_4", soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE42s(soap, ((_genmesh__vertexbuffer *)a)->texture_USCOREcoord_USCOREdimensions_USCORE4));
	soap_set_attr(soap, "texture_coord_dimensions_5", soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE52s(soap, ((_genmesh__vertexbuffer *)a)->texture_USCOREcoord_USCOREdimensions_USCORE5));
	soap_set_attr(soap, "texture_coord_dimensions_6", soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE62s(soap, ((_genmesh__vertexbuffer *)a)->texture_USCOREcoord_USCOREdimensions_USCORE6));
	soap_set_attr(soap, "texture_coord_dimensions_7", soap__genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE72s(soap, ((_genmesh__vertexbuffer *)a)->texture_USCOREcoord_USCOREdimensions_USCORE7));
	soap_set_attr(soap, "tangents", soap__genmesh__vertexbuffer_tangents2s(soap, ((_genmesh__vertexbuffer *)a)->tangents));
	soap_set_attr(soap, "tangent_dimensions", soap__genmesh__vertexbuffer_tangent_USCOREdimensions2s(soap, ((_genmesh__vertexbuffer *)a)->tangent_USCOREdimensions));
	soap_set_attr(soap, "binormals", soap__genmesh__vertexbuffer_binormals2s(soap, ((_genmesh__vertexbuffer *)a)->binormals));
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexbuffer), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__vertex(soap, "genmesh:vertex", -1, &(a->_genmesh__vertexbuffer::genmesh__vertex), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__vertexbuffer::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__vertexbuffer(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__vertexbuffer * SOAP_FMAC4 soap_get__genmesh__vertexbuffer(struct soap *soap, _genmesh__vertexbuffer *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexbuffer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__vertexbuffer::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__vertexbuffer(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__vertexbuffer * SOAP_FMAC4 soap_in__genmesh__vertexbuffer(struct soap *soap, const char *tag, _genmesh__vertexbuffer *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__vertexbuffer *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexbuffer, sizeof(_genmesh__vertexbuffer), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__vertexbuffer)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__vertexbuffer *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2_genmesh__vertexbuffer_positions(soap, soap_attr_value(soap, "positions", 0), &((_genmesh__vertexbuffer *)a)->positions))
		return NULL;
	if (soap_s2_genmesh__vertexbuffer_normals(soap, soap_attr_value(soap, "normals", 0), &((_genmesh__vertexbuffer *)a)->normals))
		return NULL;
	if (soap_s2_genmesh__vertexbuffer_colours_USCOREdiffuse(soap, soap_attr_value(soap, "colours_diffuse", 0), &((_genmesh__vertexbuffer *)a)->colours_USCOREdiffuse))
		return NULL;
	if (soap_s2_genmesh__vertexbuffer_colours_USCOREspecular(soap, soap_attr_value(soap, "colours_specular", 0), &((_genmesh__vertexbuffer *)a)->colours_USCOREspecular))
		return NULL;
	if (soap_s2_genmesh__vertexbuffer_texture_USCOREcoords(soap, soap_attr_value(soap, "texture_coords", 0), &((_genmesh__vertexbuffer *)a)->texture_USCOREcoords))
		return NULL;
	if (soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE0(soap, soap_attr_value(soap, "texture_coord_dimensions_0", 0), &((_genmesh__vertexbuffer *)a)->texture_USCOREcoord_USCOREdimensions_USCORE0))
		return NULL;
	if (soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE1(soap, soap_attr_value(soap, "texture_coord_dimensions_1", 0), &((_genmesh__vertexbuffer *)a)->texture_USCOREcoord_USCOREdimensions_USCORE1))
		return NULL;
	if (soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE2(soap, soap_attr_value(soap, "texture_coord_dimensions_2", 0), &((_genmesh__vertexbuffer *)a)->texture_USCOREcoord_USCOREdimensions_USCORE2))
		return NULL;
	if (soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE3(soap, soap_attr_value(soap, "texture_coord_dimensions_3", 0), &((_genmesh__vertexbuffer *)a)->texture_USCOREcoord_USCOREdimensions_USCORE3))
		return NULL;
	if (soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE4(soap, soap_attr_value(soap, "texture_coord_dimensions_4", 0), &((_genmesh__vertexbuffer *)a)->texture_USCOREcoord_USCOREdimensions_USCORE4))
		return NULL;
	if (soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE5(soap, soap_attr_value(soap, "texture_coord_dimensions_5", 0), &((_genmesh__vertexbuffer *)a)->texture_USCOREcoord_USCOREdimensions_USCORE5))
		return NULL;
	if (soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE6(soap, soap_attr_value(soap, "texture_coord_dimensions_6", 0), &((_genmesh__vertexbuffer *)a)->texture_USCOREcoord_USCOREdimensions_USCORE6))
		return NULL;
	if (soap_s2_genmesh__vertexbuffer_texture_USCOREcoord_USCOREdimensions_USCORE7(soap, soap_attr_value(soap, "texture_coord_dimensions_7", 0), &((_genmesh__vertexbuffer *)a)->texture_USCOREcoord_USCOREdimensions_USCORE7))
		return NULL;
	if (soap_s2_genmesh__vertexbuffer_tangents(soap, soap_attr_value(soap, "tangents", 0), &((_genmesh__vertexbuffer *)a)->tangents))
		return NULL;
	if (soap_s2_genmesh__vertexbuffer_tangent_USCOREdimensions(soap, soap_attr_value(soap, "tangent_dimensions", 0), &((_genmesh__vertexbuffer *)a)->tangent_USCOREdimensions))
		return NULL;
	if (soap_s2_genmesh__vertexbuffer_binormals(soap, soap_attr_value(soap, "binormals", 0), &((_genmesh__vertexbuffer *)a)->binormals))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__vertex(soap, "genmesh:vertex", &(a->_genmesh__vertexbuffer::genmesh__vertex), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__vertexbuffer *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexbuffer, 0, sizeof(_genmesh__vertexbuffer), 0, soap_copy__genmesh__vertexbuffer);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__vertexbuffer * SOAP_FMAC6 soap_new__genmesh__vertexbuffer(struct soap *soap, int n)
{	return soap_instantiate__genmesh__vertexbuffer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__vertexbuffer(struct soap *soap, _genmesh__vertexbuffer *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__vertexbuffer * SOAP_FMAC4 soap_instantiate__genmesh__vertexbuffer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__vertexbuffer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__vertexbuffer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__vertexbuffer;
		if (size)
			*size = sizeof(_genmesh__vertexbuffer);
		((_genmesh__vertexbuffer*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__vertexbuffer[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__vertexbuffer);
		for (int i = 0; i < n; i++)
			((_genmesh__vertexbuffer*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__vertexbuffer*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__vertexbuffer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__vertexbuffer %p -> %p\n", q, p));
	*(_genmesh__vertexbuffer*)p = *(_genmesh__vertexbuffer*)q;
}

void _genmesh__lodfacelist::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_genmesh__lodfacelist::__size_lodfacelist_sequence = 0;
	this->_genmesh__lodfacelist::__lodfacelist_sequence = NULL;
	soap_default_std__string(soap, &this->_genmesh__lodfacelist::submeshindex);
	soap_default_std__string(soap, &this->_genmesh__lodfacelist::numfaces);
	/* transient soap skipped */
}

void _genmesh__lodfacelist::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_genmesh__lodfacelist::__lodfacelist_sequence)
	{	int i;
		for (i = 0; i < this->_genmesh__lodfacelist::__size_lodfacelist_sequence; i++)
		{
			this->_genmesh__lodfacelist::__lodfacelist_sequence[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int _genmesh__lodfacelist::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__lodfacelist);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__lodfacelist::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__lodfacelist(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__lodfacelist(struct soap *soap, const char *tag, int id, const _genmesh__lodfacelist *a, const char *type)
{
	if (!((_genmesh__lodfacelist *)a)->submeshindex.empty())
		soap_set_attr(soap, "submeshindex", ((_genmesh__lodfacelist *)a)->submeshindex.c_str());
	if (!((_genmesh__lodfacelist *)a)->numfaces.empty())
		soap_set_attr(soap, "numfaces", ((_genmesh__lodfacelist *)a)->numfaces.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__lodfacelist), type))
		return soap->error;
	if (a->_genmesh__lodfacelist::__lodfacelist_sequence)
	{	int i;
		for (i = 0; i < a->_genmesh__lodfacelist::__size_lodfacelist_sequence; i++)
			if (a->_genmesh__lodfacelist::__lodfacelist_sequence[i].soap_out(soap, "-lodfacelist-sequence", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__lodfacelist::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__lodfacelist(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__lodfacelist * SOAP_FMAC4 soap_get__genmesh__lodfacelist(struct soap *soap, _genmesh__lodfacelist *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__lodfacelist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__lodfacelist::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__lodfacelist(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__lodfacelist * SOAP_FMAC4 soap_in__genmesh__lodfacelist(struct soap *soap, const char *tag, _genmesh__lodfacelist *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__lodfacelist *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__lodfacelist, sizeof(_genmesh__lodfacelist), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__lodfacelist)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__lodfacelist *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "submeshindex", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__lodfacelist *)a)->submeshindex.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "numfaces", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__lodfacelist *)a)->numfaces.assign(s);
		}
	}
	short soap_flag___lodfacelist_sequence1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___lodfacelist_sequence1 && soap->error == SOAP_TAG_MISMATCH)
			{	__genmesh__lodfacelist_sequence *p;
				__genmesh__lodfacelist_sequence q;
				q.soap_default(soap);
				soap_new_block(soap);
				for (a->_genmesh__lodfacelist::__size_lodfacelist_sequence = 0; !soap_peek_element(soap); a->_genmesh__lodfacelist::__size_lodfacelist_sequence++)
				{	p = (__genmesh__lodfacelist_sequence *)soap_push_block(soap, sizeof(__genmesh__lodfacelist_sequence));
					if (!p)
						return NULL;
					memcpy(p, &q, sizeof(__genmesh__lodfacelist_sequence));
					p->soap_default(soap);
					if (!soap_in___genmesh__lodfacelist_sequence(soap, "-lodfacelist-sequence", p, "-genmesh:lodfacelist-sequence"))
						break;
					soap_flag___lodfacelist_sequence1 = 0;
				}
				a->_genmesh__lodfacelist::__lodfacelist_sequence = (__genmesh__lodfacelist_sequence *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___lodfacelist_sequence1 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__lodfacelist *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__lodfacelist, 0, sizeof(_genmesh__lodfacelist), 0, soap_copy__genmesh__lodfacelist);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__lodfacelist * SOAP_FMAC6 soap_new__genmesh__lodfacelist(struct soap *soap, int n)
{	return soap_instantiate__genmesh__lodfacelist(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__lodfacelist(struct soap *soap, _genmesh__lodfacelist *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__lodfacelist * SOAP_FMAC4 soap_instantiate__genmesh__lodfacelist(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__lodfacelist(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__lodfacelist, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__lodfacelist;
		if (size)
			*size = sizeof(_genmesh__lodfacelist);
		((_genmesh__lodfacelist*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__lodfacelist[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__lodfacelist);
		for (int i = 0; i < n; i++)
			((_genmesh__lodfacelist*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__lodfacelist*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__lodfacelist(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__lodfacelist %p -> %p\n", q, p));
	*(_genmesh__lodfacelist*)p = *(_genmesh__lodfacelist*)q;
}

void _genmesh__lodgenerated::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_genmesh__lodgenerated::genmesh__lodfacelist = NULL;
	soap_default_std__string(soap, &this->_genmesh__lodgenerated::fromdepthsquared);
	soap_default_std__string(soap, &this->_genmesh__lodgenerated::meshname);
	/* transient soap skipped */
}

void _genmesh__lodgenerated::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_genmesh__lodfacelist(soap, &this->_genmesh__lodgenerated::genmesh__lodfacelist);
	/* transient soap skipped */
}

int _genmesh__lodgenerated::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__lodgenerated);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__lodgenerated::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__lodgenerated(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__lodgenerated(struct soap *soap, const char *tag, int id, const _genmesh__lodgenerated *a, const char *type)
{
	if (!((_genmesh__lodgenerated *)a)->fromdepthsquared.empty())
		soap_set_attr(soap, "fromdepthsquared", ((_genmesh__lodgenerated *)a)->fromdepthsquared.c_str());
	if (!((_genmesh__lodgenerated *)a)->meshname.empty())
		soap_set_attr(soap, "meshname", ((_genmesh__lodgenerated *)a)->meshname.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__lodgenerated), type))
		return soap->error;
	if (soap_out_PointerTo_genmesh__lodfacelist(soap, "genmesh:lodfacelist", -1, &(a->_genmesh__lodgenerated::genmesh__lodfacelist), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__lodgenerated::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__lodgenerated(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__lodgenerated * SOAP_FMAC4 soap_get__genmesh__lodgenerated(struct soap *soap, _genmesh__lodgenerated *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__lodgenerated(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__lodgenerated::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__lodgenerated(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__lodgenerated * SOAP_FMAC4 soap_in__genmesh__lodgenerated(struct soap *soap, const char *tag, _genmesh__lodgenerated *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__lodgenerated *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__lodgenerated, sizeof(_genmesh__lodgenerated), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__lodgenerated)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__lodgenerated *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "fromdepthsquared", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__lodgenerated *)a)->fromdepthsquared.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "meshname", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__lodgenerated *)a)->meshname.assign(s);
		}
	}
	short soap_flag_genmesh__lodfacelist1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genmesh__lodfacelist1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__lodfacelist(soap, "genmesh:lodfacelist", &(a->_genmesh__lodgenerated::genmesh__lodfacelist), ""))
				{	soap_flag_genmesh__lodfacelist1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__lodgenerated *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__lodgenerated, 0, sizeof(_genmesh__lodgenerated), 0, soap_copy__genmesh__lodgenerated);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genmesh__lodfacelist1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__lodgenerated * SOAP_FMAC6 soap_new__genmesh__lodgenerated(struct soap *soap, int n)
{	return soap_instantiate__genmesh__lodgenerated(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__lodgenerated(struct soap *soap, _genmesh__lodgenerated *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__lodgenerated * SOAP_FMAC4 soap_instantiate__genmesh__lodgenerated(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__lodgenerated(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__lodgenerated, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__lodgenerated;
		if (size)
			*size = sizeof(_genmesh__lodgenerated);
		((_genmesh__lodgenerated*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__lodgenerated[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__lodgenerated);
		for (int i = 0; i < n; i++)
			((_genmesh__lodgenerated*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__lodgenerated*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__lodgenerated(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__lodgenerated %p -> %p\n", q, p));
	*(_genmesh__lodgenerated*)p = *(_genmesh__lodgenerated*)q;
}

void _genmesh__lodmanual::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genmesh__lodmanual::fromdepthsquared);
	soap_default_std__string(soap, &this->_genmesh__lodmanual::meshname);
	/* transient soap skipped */
}

void _genmesh__lodmanual::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genmesh__lodmanual::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__lodmanual);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__lodmanual::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__lodmanual(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__lodmanual(struct soap *soap, const char *tag, int id, const _genmesh__lodmanual *a, const char *type)
{
	if (!((_genmesh__lodmanual *)a)->fromdepthsquared.empty())
		soap_set_attr(soap, "fromdepthsquared", ((_genmesh__lodmanual *)a)->fromdepthsquared.c_str());
	if (!((_genmesh__lodmanual *)a)->meshname.empty())
		soap_set_attr(soap, "meshname", ((_genmesh__lodmanual *)a)->meshname.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__lodmanual), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__lodmanual::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__lodmanual(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__lodmanual * SOAP_FMAC4 soap_get__genmesh__lodmanual(struct soap *soap, _genmesh__lodmanual *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__lodmanual(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__lodmanual::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__lodmanual(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__lodmanual * SOAP_FMAC4 soap_in__genmesh__lodmanual(struct soap *soap, const char *tag, _genmesh__lodmanual *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__lodmanual *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__lodmanual, sizeof(_genmesh__lodmanual), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__lodmanual)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__lodmanual *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "fromdepthsquared", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__lodmanual *)a)->fromdepthsquared.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "meshname", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__lodmanual *)a)->meshname.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__lodmanual *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__lodmanual, 0, sizeof(_genmesh__lodmanual), 0, soap_copy__genmesh__lodmanual);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__lodmanual * SOAP_FMAC6 soap_new__genmesh__lodmanual(struct soap *soap, int n)
{	return soap_instantiate__genmesh__lodmanual(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__lodmanual(struct soap *soap, _genmesh__lodmanual *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__lodmanual * SOAP_FMAC4 soap_instantiate__genmesh__lodmanual(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__lodmanual(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__lodmanual, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__lodmanual;
		if (size)
			*size = sizeof(_genmesh__lodmanual);
		((_genmesh__lodmanual*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__lodmanual[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__lodmanual);
		for (int i = 0; i < n; i++)
			((_genmesh__lodmanual*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__lodmanual*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__lodmanual(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__lodmanual %p -> %p\n", q, p));
	*(_genmesh__lodmanual*)p = *(_genmesh__lodmanual*)q;
}

void _genmesh__levelofdetail::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_genmesh__levelofdetail::__size_levelofdetail = 0;
	this->_genmesh__levelofdetail::__union_levelofdetail = NULL;
	soap_default_std__string(soap, &this->_genmesh__levelofdetail::numlevels);
	soap_default__genmesh__levelofdetail_manual(soap, &this->_genmesh__levelofdetail::manual);
	/* transient soap skipped */
}

void _genmesh__levelofdetail::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	if (this->_genmesh__levelofdetail::__union_levelofdetail)
	{	int i;
		for (i = 0; i < this->_genmesh__levelofdetail::__size_levelofdetail; i++)
		{
			this->_genmesh__levelofdetail::__union_levelofdetail[i].soap_serialize(soap);
		}
	}
	/* transient soap skipped */
}

int _genmesh__levelofdetail::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__levelofdetail);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__levelofdetail::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__levelofdetail(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__levelofdetail(struct soap *soap, const char *tag, int id, const _genmesh__levelofdetail *a, const char *type)
{
	if (!((_genmesh__levelofdetail *)a)->numlevels.empty())
		soap_set_attr(soap, "numlevels", ((_genmesh__levelofdetail *)a)->numlevels.c_str());
	soap_set_attr(soap, "manual", soap__genmesh__levelofdetail_manual2s(soap, ((_genmesh__levelofdetail *)a)->manual));
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__levelofdetail), type))
		return soap->error;
	if (a->_genmesh__levelofdetail::__union_levelofdetail)
	{	int i;
		for (i = 0; i < a->_genmesh__levelofdetail::__size_levelofdetail; i++)
			if (a->_genmesh__levelofdetail::__union_levelofdetail[i].soap_out(soap, "-union-levelofdetail", -1, ""))
				return soap->error;
	}
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__levelofdetail::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__levelofdetail(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__levelofdetail * SOAP_FMAC4 soap_get__genmesh__levelofdetail(struct soap *soap, _genmesh__levelofdetail *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__levelofdetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__levelofdetail::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__levelofdetail(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__levelofdetail * SOAP_FMAC4 soap_in__genmesh__levelofdetail(struct soap *soap, const char *tag, _genmesh__levelofdetail *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__levelofdetail *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__levelofdetail, sizeof(_genmesh__levelofdetail), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__levelofdetail)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__levelofdetail *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "numlevels", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__levelofdetail *)a)->numlevels.assign(s);
		}
	}
	if (soap_s2_genmesh__levelofdetail_manual(soap, soap_attr_value(soap, "manual", 0), &((_genmesh__levelofdetail *)a)->manual))
		return NULL;
	short soap_flag___union_levelofdetail1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag___union_levelofdetail1 && soap->error == SOAP_TAG_MISMATCH)
			{	__genmesh__union_levelofdetail *p;
				__genmesh__union_levelofdetail q;
				q.soap_default(soap);
				soap_new_block(soap);
				for (a->_genmesh__levelofdetail::__size_levelofdetail = 0; !soap_peek_element(soap); a->_genmesh__levelofdetail::__size_levelofdetail++)
				{	p = (__genmesh__union_levelofdetail *)soap_push_block(soap, sizeof(__genmesh__union_levelofdetail));
					if (!p)
						return NULL;
					memcpy(p, &q, sizeof(__genmesh__union_levelofdetail));
					p->soap_default(soap);
					if (!soap_in___genmesh__union_levelofdetail(soap, "-union-levelofdetail", p, "-genmesh:union-levelofdetail"))
						break;
					soap_flag___union_levelofdetail1 = 0;
				}
				a->_genmesh__levelofdetail::__union_levelofdetail = (__genmesh__union_levelofdetail *)soap_save_block(soap, NULL, 1);
				if (!soap_flag___union_levelofdetail1 && soap->error == SOAP_TAG_MISMATCH)
					continue;
			}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__levelofdetail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__levelofdetail, 0, sizeof(_genmesh__levelofdetail), 0, soap_copy__genmesh__levelofdetail);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__levelofdetail * SOAP_FMAC6 soap_new__genmesh__levelofdetail(struct soap *soap, int n)
{	return soap_instantiate__genmesh__levelofdetail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__levelofdetail(struct soap *soap, _genmesh__levelofdetail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__levelofdetail * SOAP_FMAC4 soap_instantiate__genmesh__levelofdetail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__levelofdetail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__levelofdetail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__levelofdetail;
		if (size)
			*size = sizeof(_genmesh__levelofdetail);
		((_genmesh__levelofdetail*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__levelofdetail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__levelofdetail);
		for (int i = 0; i < n; i++)
			((_genmesh__levelofdetail*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__levelofdetail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__levelofdetail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__levelofdetail %p -> %p\n", q, p));
	*(_genmesh__levelofdetail*)p = *(_genmesh__levelofdetail*)q;
}

void _genmesh__vertexboneassignment::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genmesh__vertexboneassignment::vertexindex);
	soap_default_std__string(soap, &this->_genmesh__vertexboneassignment::boneindex);
	this->_genmesh__vertexboneassignment::weight = "1.0";
	/* transient soap skipped */
}

void _genmesh__vertexboneassignment::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genmesh__vertexboneassignment::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__vertexboneassignment);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__vertexboneassignment::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__vertexboneassignment(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__vertexboneassignment(struct soap *soap, const char *tag, int id, const _genmesh__vertexboneassignment *a, const char *type)
{
	if (!((_genmesh__vertexboneassignment *)a)->vertexindex.empty())
		soap_set_attr(soap, "vertexindex", ((_genmesh__vertexboneassignment *)a)->vertexindex.c_str());
	if (!((_genmesh__vertexboneassignment *)a)->boneindex.empty())
		soap_set_attr(soap, "boneindex", ((_genmesh__vertexboneassignment *)a)->boneindex.c_str());
	if (!((_genmesh__vertexboneassignment *)a)->weight.empty())
		soap_set_attr(soap, "weight", ((_genmesh__vertexboneassignment *)a)->weight.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__vertexboneassignment), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__vertexboneassignment::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__vertexboneassignment(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__vertexboneassignment * SOAP_FMAC4 soap_get__genmesh__vertexboneassignment(struct soap *soap, _genmesh__vertexboneassignment *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__vertexboneassignment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__vertexboneassignment::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__vertexboneassignment(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__vertexboneassignment * SOAP_FMAC4 soap_in__genmesh__vertexboneassignment(struct soap *soap, const char *tag, _genmesh__vertexboneassignment *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__vertexboneassignment *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__vertexboneassignment, sizeof(_genmesh__vertexboneassignment), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__vertexboneassignment)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__vertexboneassignment *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "vertexindex", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__vertexboneassignment *)a)->vertexindex.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "boneindex", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__vertexboneassignment *)a)->boneindex.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "weight", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__vertexboneassignment *)a)->weight.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__vertexboneassignment *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__vertexboneassignment, 0, sizeof(_genmesh__vertexboneassignment), 0, soap_copy__genmesh__vertexboneassignment);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__vertexboneassignment * SOAP_FMAC6 soap_new__genmesh__vertexboneassignment(struct soap *soap, int n)
{	return soap_instantiate__genmesh__vertexboneassignment(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__vertexboneassignment(struct soap *soap, _genmesh__vertexboneassignment *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__vertexboneassignment * SOAP_FMAC4 soap_instantiate__genmesh__vertexboneassignment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__vertexboneassignment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__vertexboneassignment, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__vertexboneassignment;
		if (size)
			*size = sizeof(_genmesh__vertexboneassignment);
		((_genmesh__vertexboneassignment*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__vertexboneassignment[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__vertexboneassignment);
		for (int i = 0; i < n; i++)
			((_genmesh__vertexboneassignment*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__vertexboneassignment*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__vertexboneassignment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__vertexboneassignment %p -> %p\n", q, p));
	*(_genmesh__vertexboneassignment*)p = *(_genmesh__vertexboneassignment*)q;
}

void _genmesh__boneassignments::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment(soap, &this->_genmesh__boneassignments::genmesh__vertexboneassignment);
	/* transient soap skipped */
}

void _genmesh__boneassignments::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment(soap, &this->_genmesh__boneassignments::genmesh__vertexboneassignment);
	/* transient soap skipped */
}

int _genmesh__boneassignments::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__boneassignments);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__boneassignments::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__boneassignments(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__boneassignments(struct soap *soap, const char *tag, int id, const _genmesh__boneassignments *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__boneassignments), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment(soap, "genmesh:vertexboneassignment", -1, &(a->_genmesh__boneassignments::genmesh__vertexboneassignment), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__boneassignments::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__boneassignments(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__boneassignments * SOAP_FMAC4 soap_get__genmesh__boneassignments(struct soap *soap, _genmesh__boneassignments *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__boneassignments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__boneassignments::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__boneassignments(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__boneassignments * SOAP_FMAC4 soap_in__genmesh__boneassignments(struct soap *soap, const char *tag, _genmesh__boneassignments *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__boneassignments *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__boneassignments, sizeof(_genmesh__boneassignments), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__boneassignments)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__boneassignments *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment(soap, "genmesh:vertexboneassignment", &(a->_genmesh__boneassignments::genmesh__vertexboneassignment), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__boneassignments *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__boneassignments, 0, sizeof(_genmesh__boneassignments), 0, soap_copy__genmesh__boneassignments);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__boneassignments * SOAP_FMAC6 soap_new__genmesh__boneassignments(struct soap *soap, int n)
{	return soap_instantiate__genmesh__boneassignments(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__boneassignments(struct soap *soap, _genmesh__boneassignments *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__boneassignments * SOAP_FMAC4 soap_instantiate__genmesh__boneassignments(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__boneassignments(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__boneassignments, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__boneassignments;
		if (size)
			*size = sizeof(_genmesh__boneassignments);
		((_genmesh__boneassignments*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__boneassignments[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__boneassignments);
		for (int i = 0; i < n; i++)
			((_genmesh__boneassignments*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__boneassignments*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__boneassignments(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__boneassignments %p -> %p\n", q, p));
	*(_genmesh__boneassignments*)p = *(_genmesh__boneassignments*)q;
}

void _genmesh__skeletonlink::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genmesh__skeletonlink::name);
	/* transient soap skipped */
}

void _genmesh__skeletonlink::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genmesh__skeletonlink::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__skeletonlink);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__skeletonlink::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__skeletonlink(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__skeletonlink(struct soap *soap, const char *tag, int id, const _genmesh__skeletonlink *a, const char *type)
{
	if (!((_genmesh__skeletonlink *)a)->name.empty())
		soap_set_attr(soap, "name", ((_genmesh__skeletonlink *)a)->name.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__skeletonlink), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__skeletonlink::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__skeletonlink(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__skeletonlink * SOAP_FMAC4 soap_get__genmesh__skeletonlink(struct soap *soap, _genmesh__skeletonlink *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__skeletonlink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__skeletonlink::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__skeletonlink(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__skeletonlink * SOAP_FMAC4 soap_in__genmesh__skeletonlink(struct soap *soap, const char *tag, _genmesh__skeletonlink *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__skeletonlink *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__skeletonlink, sizeof(_genmesh__skeletonlink), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__skeletonlink)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__skeletonlink *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__skeletonlink *)a)->name.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__skeletonlink *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__skeletonlink, 0, sizeof(_genmesh__skeletonlink), 0, soap_copy__genmesh__skeletonlink);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__skeletonlink * SOAP_FMAC6 soap_new__genmesh__skeletonlink(struct soap *soap, int n)
{	return soap_instantiate__genmesh__skeletonlink(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__skeletonlink(struct soap *soap, _genmesh__skeletonlink *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__skeletonlink * SOAP_FMAC4 soap_instantiate__genmesh__skeletonlink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__skeletonlink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__skeletonlink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__skeletonlink;
		if (size)
			*size = sizeof(_genmesh__skeletonlink);
		((_genmesh__skeletonlink*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__skeletonlink[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__skeletonlink);
		for (int i = 0; i < n; i++)
			((_genmesh__skeletonlink*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__skeletonlink*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__skeletonlink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__skeletonlink %p -> %p\n", q, p));
	*(_genmesh__skeletonlink*)p = *(_genmesh__skeletonlink*)q;
}

void _genmesh__geometry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(soap, &this->_genmesh__geometry::genmesh__vertexbuffer);
	this->_genmesh__geometry::vertexcount = NULL;
	/* transient soap skipped */
}

void _genmesh__geometry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(soap, &this->_genmesh__geometry::genmesh__vertexbuffer);
	/* transient soap skipped */
}

int _genmesh__geometry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__geometry);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__geometry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__geometry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__geometry(struct soap *soap, const char *tag, int id, const _genmesh__geometry *a, const char *type)
{
	if (((_genmesh__geometry *)a)->vertexcount)
		soap_set_attr(soap, "vertexcount", ((_genmesh__geometry *)a)->vertexcount->c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__geometry), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(soap, "genmesh:vertexbuffer", -1, &(a->_genmesh__geometry::genmesh__vertexbuffer), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__geometry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__geometry(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__geometry * SOAP_FMAC4 soap_get__genmesh__geometry(struct soap *soap, _genmesh__geometry *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__geometry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__geometry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__geometry(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__geometry * SOAP_FMAC4 soap_in__genmesh__geometry(struct soap *soap, const char *tag, _genmesh__geometry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__geometry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__geometry, sizeof(_genmesh__geometry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__geometry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__geometry *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "vertexcount", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((_genmesh__geometry *)a)->vertexcount = soap_new_std__string(soap, -1);
				((_genmesh__geometry *)a)->vertexcount->assign(s);
			}
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(soap, "genmesh:vertexbuffer", &(a->_genmesh__geometry::genmesh__vertexbuffer), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__geometry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__geometry, 0, sizeof(_genmesh__geometry), 0, soap_copy__genmesh__geometry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__geometry * SOAP_FMAC6 soap_new__genmesh__geometry(struct soap *soap, int n)
{	return soap_instantiate__genmesh__geometry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__geometry(struct soap *soap, _genmesh__geometry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__geometry * SOAP_FMAC4 soap_instantiate__genmesh__geometry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__geometry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__geometry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__geometry;
		if (size)
			*size = sizeof(_genmesh__geometry);
		((_genmesh__geometry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__geometry[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__geometry);
		for (int i = 0; i < n; i++)
			((_genmesh__geometry*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__geometry*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__geometry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__geometry %p -> %p\n", q, p));
	*(_genmesh__geometry*)p = *(_genmesh__geometry*)q;
}

void _genmesh__face::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genmesh__face::v1);
	this->_genmesh__face::v2 = NULL;
	this->_genmesh__face::v3 = NULL;
	/* transient soap skipped */
}

void _genmesh__face::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genmesh__face::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__face);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__face::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__face(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__face(struct soap *soap, const char *tag, int id, const _genmesh__face *a, const char *type)
{
	if (!((_genmesh__face *)a)->v1.empty())
		soap_set_attr(soap, "v1", ((_genmesh__face *)a)->v1.c_str());
	if (((_genmesh__face *)a)->v2)
		soap_set_attr(soap, "v2", ((_genmesh__face *)a)->v2->c_str());
	if (((_genmesh__face *)a)->v3)
		soap_set_attr(soap, "v3", ((_genmesh__face *)a)->v3->c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__face), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__face::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__face(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__face * SOAP_FMAC4 soap_get__genmesh__face(struct soap *soap, _genmesh__face *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__face(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__face::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__face(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__face * SOAP_FMAC4 soap_in__genmesh__face(struct soap *soap, const char *tag, _genmesh__face *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__face *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__face, sizeof(_genmesh__face), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__face)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__face *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "v1", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__face *)a)->v1.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "v2", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((_genmesh__face *)a)->v2 = soap_new_std__string(soap, -1);
				((_genmesh__face *)a)->v2->assign(s);
			}
		}
	}
	{	const char *t = soap_attr_value(soap, "v3", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((_genmesh__face *)a)->v3 = soap_new_std__string(soap, -1);
				((_genmesh__face *)a)->v3->assign(s);
			}
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__face *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__face, 0, sizeof(_genmesh__face), 0, soap_copy__genmesh__face);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__face * SOAP_FMAC6 soap_new__genmesh__face(struct soap *soap, int n)
{	return soap_instantiate__genmesh__face(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__face(struct soap *soap, _genmesh__face *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__face * SOAP_FMAC4 soap_instantiate__genmesh__face(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__face(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__face, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__face;
		if (size)
			*size = sizeof(_genmesh__face);
		((_genmesh__face*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__face[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__face);
		for (int i = 0; i < n; i++)
			((_genmesh__face*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__face*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__face(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__face %p -> %p\n", q, p));
	*(_genmesh__face*)p = *(_genmesh__face*)q;
}

void _genmesh__faces::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__face(soap, &this->_genmesh__faces::genmesh__face);
	this->_genmesh__faces::count = NULL;
	/* transient soap skipped */
}

void _genmesh__faces::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__face(soap, &this->_genmesh__faces::genmesh__face);
	/* transient soap skipped */
}

int _genmesh__faces::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__faces);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__faces::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__faces(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__faces(struct soap *soap, const char *tag, int id, const _genmesh__faces *a, const char *type)
{
	if (((_genmesh__faces *)a)->count)
		soap_set_attr(soap, "count", ((_genmesh__faces *)a)->count->c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__faces), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__face(soap, "genmesh:face", -1, &(a->_genmesh__faces::genmesh__face), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__faces::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__faces(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__faces * SOAP_FMAC4 soap_get__genmesh__faces(struct soap *soap, _genmesh__faces *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__faces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__faces::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__faces(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__faces * SOAP_FMAC4 soap_in__genmesh__faces(struct soap *soap, const char *tag, _genmesh__faces *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__faces *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__faces, sizeof(_genmesh__faces), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__faces)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__faces *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "count", 0);
		if (t)
		{
			char *s = NULL;
			if (soap_s2string(soap, t, &s))
				return NULL;
			if (s)
			{	((_genmesh__faces *)a)->count = soap_new_std__string(soap, -1);
				((_genmesh__faces *)a)->count->assign(s);
			}
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__face(soap, "genmesh:face", &(a->_genmesh__faces::genmesh__face), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__faces *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__faces, 0, sizeof(_genmesh__faces), 0, soap_copy__genmesh__faces);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__faces * SOAP_FMAC6 soap_new__genmesh__faces(struct soap *soap, int n)
{	return soap_instantiate__genmesh__faces(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__faces(struct soap *soap, _genmesh__faces *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__faces * SOAP_FMAC4 soap_instantiate__genmesh__faces(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__faces(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__faces, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__faces;
		if (size)
			*size = sizeof(_genmesh__faces);
		((_genmesh__faces*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__faces[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__faces);
		for (int i = 0; i < n; i++)
			((_genmesh__faces*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__faces*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__faces(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__faces %p -> %p\n", q, p));
	*(_genmesh__faces*)p = *(_genmesh__faces*)q;
}

void _genmesh__texture::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->_genmesh__texture::alias);
	soap_default_std__string(soap, &this->_genmesh__texture::name);
	/* transient soap skipped */
}

void _genmesh__texture::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int _genmesh__texture::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__texture);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__texture::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__texture(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__texture(struct soap *soap, const char *tag, int id, const _genmesh__texture *a, const char *type)
{
	if (!((_genmesh__texture *)a)->alias.empty())
		soap_set_attr(soap, "alias", ((_genmesh__texture *)a)->alias.c_str());
	if (!((_genmesh__texture *)a)->name.empty())
		soap_set_attr(soap, "name", ((_genmesh__texture *)a)->name.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__texture), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__texture::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__texture(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__texture * SOAP_FMAC4 soap_get__genmesh__texture(struct soap *soap, _genmesh__texture *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__texture(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__texture::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__texture(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__texture * SOAP_FMAC4 soap_in__genmesh__texture(struct soap *soap, const char *tag, _genmesh__texture *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__texture *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__texture, sizeof(_genmesh__texture), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__texture)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__texture *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "alias", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__texture *)a)->alias.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "name", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__texture *)a)->name.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__texture *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__texture, 0, sizeof(_genmesh__texture), 0, soap_copy__genmesh__texture);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__texture * SOAP_FMAC6 soap_new__genmesh__texture(struct soap *soap, int n)
{	return soap_instantiate__genmesh__texture(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__texture(struct soap *soap, _genmesh__texture *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__texture * SOAP_FMAC4 soap_instantiate__genmesh__texture(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__texture(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__texture, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__texture;
		if (size)
			*size = sizeof(_genmesh__texture);
		((_genmesh__texture*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__texture[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__texture);
		for (int i = 0; i < n; i++)
			((_genmesh__texture*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__texture*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__texture(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__texture %p -> %p\n", q, p));
	*(_genmesh__texture*)p = *(_genmesh__texture*)q;
}

void _genmesh__textures::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__texture(soap, &this->_genmesh__textures::genmesh__texture);
	/* transient soap skipped */
}

void _genmesh__textures::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__texture(soap, &this->_genmesh__textures::genmesh__texture);
	/* transient soap skipped */
}

int _genmesh__textures::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__textures);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__textures::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__textures(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__textures(struct soap *soap, const char *tag, int id, const _genmesh__textures *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__textures), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__texture(soap, "genmesh:texture", -1, &(a->_genmesh__textures::genmesh__texture), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__textures::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__textures(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__textures * SOAP_FMAC4 soap_get__genmesh__textures(struct soap *soap, _genmesh__textures *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__textures(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__textures::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__textures(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__textures * SOAP_FMAC4 soap_in__genmesh__textures(struct soap *soap, const char *tag, _genmesh__textures *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__textures *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__textures, sizeof(_genmesh__textures), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__textures)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__textures *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__texture(soap, "genmesh:texture", &(a->_genmesh__textures::genmesh__texture), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__textures *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__textures, 0, sizeof(_genmesh__textures), 0, soap_copy__genmesh__textures);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__textures * SOAP_FMAC6 soap_new__genmesh__textures(struct soap *soap, int n)
{	return soap_instantiate__genmesh__textures(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__textures(struct soap *soap, _genmesh__textures *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__textures * SOAP_FMAC4 soap_instantiate__genmesh__textures(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__textures(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__textures, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__textures;
		if (size)
			*size = sizeof(_genmesh__textures);
		((_genmesh__textures*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__textures[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__textures);
		for (int i = 0; i < n; i++)
			((_genmesh__textures*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__textures*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__textures(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__textures %p -> %p\n", q, p));
	*(_genmesh__textures*)p = *(_genmesh__textures*)q;
}

void _genmesh__submesh::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_genmesh__submesh::genmesh__textures = NULL;
	this->_genmesh__submesh::genmesh__faces = NULL;
	this->_genmesh__submesh::genmesh__geometry = NULL;
	this->_genmesh__submesh::genmesh__boneassignments = NULL;
	soap_default_std__string(soap, &this->_genmesh__submesh::material);
	soap_default__genmesh__submesh_usesharedvertices(soap, &this->_genmesh__submesh::usesharedvertices);
	soap_default__genmesh__submesh_use32bitindexes(soap, &this->_genmesh__submesh::use32bitindexes);
	soap_default__genmesh__submesh_operationtype(soap, &this->_genmesh__submesh::operationtype);
	/* transient soap skipped */
}

void _genmesh__submesh::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_genmesh__textures(soap, &this->_genmesh__submesh::genmesh__textures);
	soap_serialize_PointerTo_genmesh__faces(soap, &this->_genmesh__submesh::genmesh__faces);
	soap_serialize_PointerTo_genmesh__geometry(soap, &this->_genmesh__submesh::genmesh__geometry);
	soap_serialize_PointerTo_genmesh__boneassignments(soap, &this->_genmesh__submesh::genmesh__boneassignments);
	/* transient soap skipped */
}

int _genmesh__submesh::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__submesh);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__submesh::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__submesh(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__submesh(struct soap *soap, const char *tag, int id, const _genmesh__submesh *a, const char *type)
{
	if (!((_genmesh__submesh *)a)->material.empty())
		soap_set_attr(soap, "material", ((_genmesh__submesh *)a)->material.c_str());
	soap_set_attr(soap, "usesharedvertices", soap__genmesh__submesh_usesharedvertices2s(soap, ((_genmesh__submesh *)a)->usesharedvertices));
	soap_set_attr(soap, "use32bitindexes", soap__genmesh__submesh_use32bitindexes2s(soap, ((_genmesh__submesh *)a)->use32bitindexes));
	soap_set_attr(soap, "operationtype", soap__genmesh__submesh_operationtype2s(soap, ((_genmesh__submesh *)a)->operationtype));
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__submesh), type))
		return soap->error;
	if (soap_out_PointerTo_genmesh__textures(soap, "genmesh:textures", -1, &(a->_genmesh__submesh::genmesh__textures), ""))
		return soap->error;
	if (soap_out_PointerTo_genmesh__faces(soap, "genmesh:faces", -1, &(a->_genmesh__submesh::genmesh__faces), ""))
		return soap->error;
	if (soap_out_PointerTo_genmesh__geometry(soap, "genmesh:geometry", -1, &(a->_genmesh__submesh::genmesh__geometry), ""))
		return soap->error;
	if (soap_out_PointerTo_genmesh__boneassignments(soap, "genmesh:boneassignments", -1, &(a->_genmesh__submesh::genmesh__boneassignments), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__submesh::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__submesh(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__submesh * SOAP_FMAC4 soap_get__genmesh__submesh(struct soap *soap, _genmesh__submesh *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__submesh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__submesh::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__submesh(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__submesh * SOAP_FMAC4 soap_in__genmesh__submesh(struct soap *soap, const char *tag, _genmesh__submesh *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__submesh *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__submesh, sizeof(_genmesh__submesh), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__submesh)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__submesh *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "material", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__submesh *)a)->material.assign(s);
		}
	}
	if (soap_s2_genmesh__submesh_usesharedvertices(soap, soap_attr_value(soap, "usesharedvertices", 0), &((_genmesh__submesh *)a)->usesharedvertices))
		return NULL;
	if (soap_s2_genmesh__submesh_use32bitindexes(soap, soap_attr_value(soap, "use32bitindexes", 0), &((_genmesh__submesh *)a)->use32bitindexes))
		return NULL;
	if (soap_s2_genmesh__submesh_operationtype(soap, soap_attr_value(soap, "operationtype", 0), &((_genmesh__submesh *)a)->operationtype))
		return NULL;
	short soap_flag_genmesh__textures1 = 1, soap_flag_genmesh__faces1 = 1, soap_flag_genmesh__geometry1 = 1, soap_flag_genmesh__boneassignments1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genmesh__textures1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__textures(soap, "genmesh:textures", &(a->_genmesh__submesh::genmesh__textures), ""))
				{	soap_flag_genmesh__textures1--;
					continue;
				}
			if (soap_flag_genmesh__faces1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__faces(soap, "genmesh:faces", &(a->_genmesh__submesh::genmesh__faces), ""))
				{	soap_flag_genmesh__faces1--;
					continue;
				}
			if (soap_flag_genmesh__geometry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__geometry(soap, "genmesh:geometry", &(a->_genmesh__submesh::genmesh__geometry), ""))
				{	soap_flag_genmesh__geometry1--;
					continue;
				}
			if (soap_flag_genmesh__boneassignments1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__boneassignments(soap, "genmesh:boneassignments", &(a->_genmesh__submesh::genmesh__boneassignments), ""))
				{	soap_flag_genmesh__boneassignments1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__submesh *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__submesh, 0, sizeof(_genmesh__submesh), 0, soap_copy__genmesh__submesh);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genmesh__faces1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__submesh * SOAP_FMAC6 soap_new__genmesh__submesh(struct soap *soap, int n)
{	return soap_instantiate__genmesh__submesh(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__submesh(struct soap *soap, _genmesh__submesh *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__submesh * SOAP_FMAC4 soap_instantiate__genmesh__submesh(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__submesh(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__submesh, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__submesh;
		if (size)
			*size = sizeof(_genmesh__submesh);
		((_genmesh__submesh*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__submesh[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__submesh);
		for (int i = 0; i < n; i++)
			((_genmesh__submesh*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__submesh*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__submesh(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__submesh %p -> %p\n", q, p));
	*(_genmesh__submesh*)p = *(_genmesh__submesh*)q;
}

void _genmesh__submeshes::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__submesh(soap, &this->_genmesh__submeshes::genmesh__submesh);
	/* transient soap skipped */
}

void _genmesh__submeshes::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__submesh(soap, &this->_genmesh__submeshes::genmesh__submesh);
	/* transient soap skipped */
}

int _genmesh__submeshes::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__submeshes);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__submeshes::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__submeshes(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__submeshes(struct soap *soap, const char *tag, int id, const _genmesh__submeshes *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__submeshes), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__submesh(soap, "genmesh:submesh", -1, &(a->_genmesh__submeshes::genmesh__submesh), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__submeshes::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__submeshes(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__submeshes * SOAP_FMAC4 soap_get__genmesh__submeshes(struct soap *soap, _genmesh__submeshes *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__submeshes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__submeshes::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__submeshes(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__submeshes * SOAP_FMAC4 soap_in__genmesh__submeshes(struct soap *soap, const char *tag, _genmesh__submeshes *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__submeshes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__submeshes, sizeof(_genmesh__submeshes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__submeshes)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__submeshes *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__submesh(soap, "genmesh:submesh", &(a->_genmesh__submeshes::genmesh__submesh), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__submeshes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__submeshes, 0, sizeof(_genmesh__submeshes), 0, soap_copy__genmesh__submeshes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__submeshes * SOAP_FMAC6 soap_new__genmesh__submeshes(struct soap *soap, int n)
{	return soap_instantiate__genmesh__submeshes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__submeshes(struct soap *soap, _genmesh__submeshes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__submeshes * SOAP_FMAC4 soap_instantiate__genmesh__submeshes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__submeshes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__submeshes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__submeshes;
		if (size)
			*size = sizeof(_genmesh__submeshes);
		((_genmesh__submeshes*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__submeshes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__submeshes);
		for (int i = 0; i < n; i++)
			((_genmesh__submeshes*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__submeshes*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__submeshes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__submeshes %p -> %p\n", q, p));
	*(_genmesh__submeshes*)p = *(_genmesh__submeshes*)q;
}

void _genmesh__sharedgeometry::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(soap, &this->_genmesh__sharedgeometry::genmesh__vertexbuffer);
	soap_default_std__string(soap, &this->_genmesh__sharedgeometry::vertexcount);
	/* transient soap skipped */
}

void _genmesh__sharedgeometry::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(soap, &this->_genmesh__sharedgeometry::genmesh__vertexbuffer);
	/* transient soap skipped */
}

int _genmesh__sharedgeometry::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__sharedgeometry);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__sharedgeometry::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__sharedgeometry(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__sharedgeometry(struct soap *soap, const char *tag, int id, const _genmesh__sharedgeometry *a, const char *type)
{
	if (!((_genmesh__sharedgeometry *)a)->vertexcount.empty())
		soap_set_attr(soap, "vertexcount", ((_genmesh__sharedgeometry *)a)->vertexcount.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__sharedgeometry), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(soap, "genmesh:vertexbuffer", -1, &(a->_genmesh__sharedgeometry::genmesh__vertexbuffer), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__sharedgeometry::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__sharedgeometry(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__sharedgeometry * SOAP_FMAC4 soap_get__genmesh__sharedgeometry(struct soap *soap, _genmesh__sharedgeometry *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__sharedgeometry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__sharedgeometry::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__sharedgeometry(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__sharedgeometry * SOAP_FMAC4 soap_in__genmesh__sharedgeometry(struct soap *soap, const char *tag, _genmesh__sharedgeometry *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__sharedgeometry *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__sharedgeometry, sizeof(_genmesh__sharedgeometry), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__sharedgeometry)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__sharedgeometry *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "vertexcount", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((_genmesh__sharedgeometry *)a)->vertexcount.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(soap, "genmesh:vertexbuffer", &(a->_genmesh__sharedgeometry::genmesh__vertexbuffer), ""))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__sharedgeometry *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__sharedgeometry, 0, sizeof(_genmesh__sharedgeometry), 0, soap_copy__genmesh__sharedgeometry);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__sharedgeometry * SOAP_FMAC6 soap_new__genmesh__sharedgeometry(struct soap *soap, int n)
{	return soap_instantiate__genmesh__sharedgeometry(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__sharedgeometry(struct soap *soap, _genmesh__sharedgeometry *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__sharedgeometry * SOAP_FMAC4 soap_instantiate__genmesh__sharedgeometry(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__sharedgeometry(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__sharedgeometry, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__sharedgeometry;
		if (size)
			*size = sizeof(_genmesh__sharedgeometry);
		((_genmesh__sharedgeometry*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__sharedgeometry[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__sharedgeometry);
		for (int i = 0; i < n; i++)
			((_genmesh__sharedgeometry*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__sharedgeometry*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__sharedgeometry(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__sharedgeometry %p -> %p\n", q, p));
	*(_genmesh__sharedgeometry*)p = *(_genmesh__sharedgeometry*)q;
}

void _genmesh__mesh::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->_genmesh__mesh::genmesh__sharedgeometry = NULL;
	this->_genmesh__mesh::genmesh__submeshes = NULL;
	this->_genmesh__mesh::genmesh__skeletonlink = NULL;
	this->_genmesh__mesh::genmesh__boneassignments = NULL;
	this->_genmesh__mesh::genmesh__levelofdetail = NULL;
	this->_genmesh__mesh::genmesh__submeshnames = NULL;
	this->_genmesh__mesh::genmesh__poses = NULL;
	this->_genmesh__mesh::genmesh__animations = NULL;
	this->_genmesh__mesh::genmesh__extremes = NULL;
	/* transient soap skipped */
}

void _genmesh__mesh::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTo_genmesh__sharedgeometry(soap, &this->_genmesh__mesh::genmesh__sharedgeometry);
	soap_serialize_PointerTo_genmesh__submeshes(soap, &this->_genmesh__mesh::genmesh__submeshes);
	soap_serialize_PointerTo_genmesh__skeletonlink(soap, &this->_genmesh__mesh::genmesh__skeletonlink);
	soap_serialize_PointerTo_genmesh__boneassignments(soap, &this->_genmesh__mesh::genmesh__boneassignments);
	soap_serialize_PointerTo_genmesh__levelofdetail(soap, &this->_genmesh__mesh::genmesh__levelofdetail);
	soap_serialize_PointerTo_genmesh__submeshnames(soap, &this->_genmesh__mesh::genmesh__submeshnames);
	soap_serialize_PointerTo_genmesh__poses(soap, &this->_genmesh__mesh::genmesh__poses);
	soap_serialize_PointerTo_genmesh__animations(soap, &this->_genmesh__mesh::genmesh__animations);
	soap_serialize_PointerTo_genmesh__extremes(soap, &this->_genmesh__mesh::genmesh__extremes);
	/* transient soap skipped */
}

int _genmesh__mesh::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmesh__mesh);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmesh__mesh::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmesh__mesh(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__mesh(struct soap *soap, const char *tag, int id, const _genmesh__mesh *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmesh__mesh), type))
		return soap->error;
	if (soap_out_PointerTo_genmesh__sharedgeometry(soap, "genmesh:sharedgeometry", -1, &(a->_genmesh__mesh::genmesh__sharedgeometry), ""))
		return soap->error;
	if (soap_out_PointerTo_genmesh__submeshes(soap, "genmesh:submeshes", -1, &(a->_genmesh__mesh::genmesh__submeshes), ""))
		return soap->error;
	if (soap_out_PointerTo_genmesh__skeletonlink(soap, "genmesh:skeletonlink", -1, &(a->_genmesh__mesh::genmesh__skeletonlink), ""))
		return soap->error;
	if (soap_out_PointerTo_genmesh__boneassignments(soap, "genmesh:boneassignments", -1, &(a->_genmesh__mesh::genmesh__boneassignments), ""))
		return soap->error;
	if (soap_out_PointerTo_genmesh__levelofdetail(soap, "genmesh:levelofdetail", -1, &(a->_genmesh__mesh::genmesh__levelofdetail), ""))
		return soap->error;
	if (soap_out_PointerTo_genmesh__submeshnames(soap, "genmesh:submeshnames", -1, &(a->_genmesh__mesh::genmesh__submeshnames), ""))
		return soap->error;
	if (soap_out_PointerTo_genmesh__poses(soap, "genmesh:poses", -1, &(a->_genmesh__mesh::genmesh__poses), ""))
		return soap->error;
	if (soap_out_PointerTo_genmesh__animations(soap, "genmesh:animations", -1, &(a->_genmesh__mesh::genmesh__animations), ""))
		return soap->error;
	if (soap_out_PointerTo_genmesh__extremes(soap, "genmesh:extremes", -1, &(a->_genmesh__mesh::genmesh__extremes), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmesh__mesh::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmesh__mesh(soap, this, tag, type);
}

SOAP_FMAC3 _genmesh__mesh * SOAP_FMAC4 soap_get__genmesh__mesh(struct soap *soap, _genmesh__mesh *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmesh__mesh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmesh__mesh::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmesh__mesh(soap, tag, this, type);
}

SOAP_FMAC3 _genmesh__mesh * SOAP_FMAC4 soap_in__genmesh__mesh(struct soap *soap, const char *tag, _genmesh__mesh *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmesh__mesh *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmesh__mesh, sizeof(_genmesh__mesh), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmesh__mesh)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmesh__mesh *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_genmesh__sharedgeometry1 = 1, soap_flag_genmesh__submeshes1 = 1, soap_flag_genmesh__skeletonlink1 = 1, soap_flag_genmesh__boneassignments1 = 1, soap_flag_genmesh__levelofdetail1 = 1, soap_flag_genmesh__submeshnames1 = 1, soap_flag_genmesh__poses1 = 1, soap_flag_genmesh__animations1 = 1, soap_flag_genmesh__extremes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_genmesh__sharedgeometry1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__sharedgeometry(soap, "genmesh:sharedgeometry", &(a->_genmesh__mesh::genmesh__sharedgeometry), ""))
				{	soap_flag_genmesh__sharedgeometry1--;
					continue;
				}
			if (soap_flag_genmesh__submeshes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__submeshes(soap, "genmesh:submeshes", &(a->_genmesh__mesh::genmesh__submeshes), ""))
				{	soap_flag_genmesh__submeshes1--;
					continue;
				}
			if (soap_flag_genmesh__skeletonlink1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__skeletonlink(soap, "genmesh:skeletonlink", &(a->_genmesh__mesh::genmesh__skeletonlink), ""))
				{	soap_flag_genmesh__skeletonlink1--;
					continue;
				}
			if (soap_flag_genmesh__boneassignments1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__boneassignments(soap, "genmesh:boneassignments", &(a->_genmesh__mesh::genmesh__boneassignments), ""))
				{	soap_flag_genmesh__boneassignments1--;
					continue;
				}
			if (soap_flag_genmesh__levelofdetail1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__levelofdetail(soap, "genmesh:levelofdetail", &(a->_genmesh__mesh::genmesh__levelofdetail), ""))
				{	soap_flag_genmesh__levelofdetail1--;
					continue;
				}
			if (soap_flag_genmesh__submeshnames1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__submeshnames(soap, "genmesh:submeshnames", &(a->_genmesh__mesh::genmesh__submeshnames), ""))
				{	soap_flag_genmesh__submeshnames1--;
					continue;
				}
			if (soap_flag_genmesh__poses1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__poses(soap, "genmesh:poses", &(a->_genmesh__mesh::genmesh__poses), ""))
				{	soap_flag_genmesh__poses1--;
					continue;
				}
			if (soap_flag_genmesh__animations1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__animations(soap, "genmesh:animations", &(a->_genmesh__mesh::genmesh__animations), ""))
				{	soap_flag_genmesh__animations1--;
					continue;
				}
			if (soap_flag_genmesh__extremes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTo_genmesh__extremes(soap, "genmesh:extremes", &(a->_genmesh__mesh::genmesh__extremes), ""))
				{	soap_flag_genmesh__extremes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmesh__mesh *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmesh__mesh, 0, sizeof(_genmesh__mesh), 0, soap_copy__genmesh__mesh);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_genmesh__submeshes1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmesh__mesh * SOAP_FMAC6 soap_new__genmesh__mesh(struct soap *soap, int n)
{	return soap_instantiate__genmesh__mesh(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmesh__mesh(struct soap *soap, _genmesh__mesh *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmesh__mesh * SOAP_FMAC4 soap_instantiate__genmesh__mesh(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmesh__mesh(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmesh__mesh, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmesh__mesh;
		if (size)
			*size = sizeof(_genmesh__mesh);
		((_genmesh__mesh*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmesh__mesh[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmesh__mesh);
		for (int i = 0; i < n; i++)
			((_genmesh__mesh*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmesh__mesh*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmesh__mesh(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmesh__mesh %p -> %p\n", q, p));
	*(_genmesh__mesh*)p = *(_genmesh__mesh*)q;
}

void _genmech__mech::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->_genmech__mech::schemaVersion);
	soap_default_std__string(soap, &this->_genmech__mech::name);
	this->_genmech__mech::stats = NULL;
	this->_genmech__mech::design = NULL;
	this->_genmech__mech::mesh = NULL;
	/* transient soap skipped */
}

void _genmech__mech::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->_genmech__mech::name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->_genmech__mech::name);
	soap_serialize_PointerTogenmech__stats(soap, &this->_genmech__mech::stats);
	soap_serialize_PointerTogenmech__design(soap, &this->_genmech__mech::design);
	soap_serialize_PointerTogenmech__mesh(soap, &this->_genmech__mech::mesh);
	/* transient soap skipped */
}

int _genmech__mech::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE__genmech__mech);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int _genmech__mech::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out__genmech__mech(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmech__mech(struct soap *soap, const char *tag, int id, const _genmech__mech *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE__genmech__mech), type))
		return soap->error;
	if (soap_out_int(soap, "genmech:schemaVersion", -1, &(a->_genmech__mech::schemaVersion), ""))
		return soap->error;
	if (soap_out_std__string(soap, "genmech:name", -1, &(a->_genmech__mech::name), ""))
		return soap->error;
	if (soap_out_PointerTogenmech__stats(soap, "genmech:stats", -1, &(a->_genmech__mech::stats), ""))
		return soap->error;
	if (soap_out_PointerTogenmech__design(soap, "genmech:design", -1, &(a->_genmech__mech::design), ""))
		return soap->error;
	if (soap_out_PointerTogenmech__mesh(soap, "genmech:mesh", -1, &(a->_genmech__mech::mesh), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *_genmech__mech::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get__genmech__mech(soap, this, tag, type);
}

SOAP_FMAC3 _genmech__mech * SOAP_FMAC4 soap_get__genmech__mech(struct soap *soap, _genmech__mech *p, const char *tag, const char *type)
{
	if ((p = soap_in__genmech__mech(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *_genmech__mech::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in__genmech__mech(soap, tag, this, type);
}

SOAP_FMAC3 _genmech__mech * SOAP_FMAC4 soap_in__genmech__mech(struct soap *soap, const char *tag, _genmech__mech *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (_genmech__mech *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE__genmech__mech, sizeof(_genmech__mech), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE__genmech__mech)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (_genmech__mech *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_schemaVersion1 = 1, soap_flag_name1 = 1, soap_flag_stats1 = 1, soap_flag_design1 = 1, soap_flag_mesh1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_schemaVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "genmech:schemaVersion", &(a->_genmech__mech::schemaVersion), "xsd:int"))
				{	soap_flag_schemaVersion1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "genmech:name", &(a->_genmech__mech::name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_stats1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogenmech__stats(soap, "genmech:stats", &(a->_genmech__mech::stats), "genmech:stats"))
				{	soap_flag_stats1--;
					continue;
				}
			if (soap_flag_design1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogenmech__design(soap, "genmech:design", &(a->_genmech__mech::design), "genmech:design"))
				{	soap_flag_design1--;
					continue;
				}
			if (soap_flag_mesh1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogenmech__mesh(soap, "genmech:mesh", &(a->_genmech__mech::mesh), "genmech:mesh"))
				{	soap_flag_mesh1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (_genmech__mech *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE__genmech__mech, 0, sizeof(_genmech__mech), 0, soap_copy__genmech__mech);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_schemaVersion1 > 0 || soap_flag_name1 > 0 || soap_flag_stats1 > 0 || soap_flag_design1 > 0 || soap_flag_mesh1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 _genmech__mech * SOAP_FMAC6 soap_new__genmech__mech(struct soap *soap, int n)
{	return soap_instantiate__genmech__mech(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__genmech__mech(struct soap *soap, _genmech__mech *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 _genmech__mech * SOAP_FMAC4 soap_instantiate__genmech__mech(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__genmech__mech(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__genmech__mech, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new _genmech__mech;
		if (size)
			*size = sizeof(_genmech__mech);
		((_genmech__mech*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new _genmech__mech[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(_genmech__mech);
		for (int i = 0; i < n; i++)
			((_genmech__mech*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (_genmech__mech*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__genmech__mech(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying _genmech__mech %p -> %p\n", q, p));
	*(_genmech__mech*)p = *(_genmech__mech*)q;
}

void genmech__mesh::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->genmech__mesh::translation = "000.00;000.00;000.00";
	soap_default_std__string(soap, &this->genmech__mesh::file);
	/* transient soap skipped */
}

void genmech__mesh::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int genmech__mesh::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_genmech__mesh);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int genmech__mesh::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_genmech__mesh(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_genmech__mesh(struct soap *soap, const char *tag, int id, const genmech__mesh *a, const char *type)
{
	if (!((genmech__mesh *)a)->translation.empty())
		soap_set_attr(soap, "translation", ((genmech__mesh *)a)->translation.c_str());
	if (!((genmech__mesh *)a)->file.empty())
		soap_set_attr(soap, "file", ((genmech__mesh *)a)->file.c_str());
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_genmech__mesh), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *genmech__mesh::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_genmech__mesh(soap, this, tag, type);
}

SOAP_FMAC3 genmech__mesh * SOAP_FMAC4 soap_get_genmech__mesh(struct soap *soap, genmech__mesh *p, const char *tag, const char *type)
{
	if ((p = soap_in_genmech__mesh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *genmech__mesh::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_genmech__mesh(soap, tag, this, type);
}

SOAP_FMAC3 genmech__mesh * SOAP_FMAC4 soap_in_genmech__mesh(struct soap *soap, const char *tag, genmech__mesh *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (genmech__mesh *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_genmech__mesh, sizeof(genmech__mesh), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_genmech__mesh)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (genmech__mesh *)a->soap_in(soap, tag, type);
		}
	}
	{	const char *t = soap_attr_value(soap, "translation", 0);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((genmech__mesh *)a)->translation.assign(s);
		}
	}
	{	const char *t = soap_attr_value(soap, "file", 1);
		if (t)
		{	char *s;
			if (soap_s2string(soap, t, &s))
				return NULL;
			((genmech__mesh *)a)->file.assign(s);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (genmech__mesh *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_genmech__mesh, 0, sizeof(genmech__mesh), 0, soap_copy_genmech__mesh);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 genmech__mesh * SOAP_FMAC6 soap_new_genmech__mesh(struct soap *soap, int n)
{	return soap_instantiate_genmech__mesh(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_genmech__mesh(struct soap *soap, genmech__mesh *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 genmech__mesh * SOAP_FMAC4 soap_instantiate_genmech__mesh(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_genmech__mesh(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_genmech__mesh, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new genmech__mesh;
		if (size)
			*size = sizeof(genmech__mesh);
		((genmech__mesh*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new genmech__mesh[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(genmech__mesh);
		for (int i = 0; i < n; i++)
			((genmech__mesh*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (genmech__mesh*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_genmech__mesh(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying genmech__mesh %p -> %p\n", q, p));
	*(genmech__mesh*)p = *(genmech__mesh*)q;
}

void genmech__torso::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->genmech__torso::turningRadius = 90;
	/* transient soap skipped */
}

void genmech__torso::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int genmech__torso::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_genmech__torso);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int genmech__torso::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_genmech__torso(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_genmech__torso(struct soap *soap, const char *tag, int id, const genmech__torso *a, const char *type)
{
	soap_set_attr(soap, "turningRadius", soap_int2s(soap, ((genmech__torso *)a)->turningRadius));
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_genmech__torso), type))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *genmech__torso::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_genmech__torso(soap, this, tag, type);
}

SOAP_FMAC3 genmech__torso * SOAP_FMAC4 soap_get_genmech__torso(struct soap *soap, genmech__torso *p, const char *tag, const char *type)
{
	if ((p = soap_in_genmech__torso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *genmech__torso::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_genmech__torso(soap, tag, this, type);
}

SOAP_FMAC3 genmech__torso * SOAP_FMAC4 soap_in_genmech__torso(struct soap *soap, const char *tag, genmech__torso *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (genmech__torso *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_genmech__torso, sizeof(genmech__torso), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_genmech__torso)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (genmech__torso *)a->soap_in(soap, tag, type);
		}
	}
	if (soap_s2int(soap, soap_attr_value(soap, "turningRadius", 0), &((genmech__torso *)a)->turningRadius))
		return NULL;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (genmech__torso *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_genmech__torso, 0, sizeof(genmech__torso), 0, soap_copy_genmech__torso);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 genmech__torso * SOAP_FMAC6 soap_new_genmech__torso(struct soap *soap, int n)
{	return soap_instantiate_genmech__torso(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_genmech__torso(struct soap *soap, genmech__torso *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 genmech__torso * SOAP_FMAC4 soap_instantiate_genmech__torso(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_genmech__torso(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_genmech__torso, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new genmech__torso;
		if (size)
			*size = sizeof(genmech__torso);
		((genmech__torso*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new genmech__torso[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(genmech__torso);
		for (int i = 0; i < n; i++)
			((genmech__torso*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (genmech__torso*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_genmech__torso(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying genmech__torso %p -> %p\n", q, p));
	*(genmech__torso*)p = *(genmech__torso*)q;
}

void genmech__equSlot::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &this->genmech__equSlot::boneName);
	this->genmech__equSlot::defaultEqu = "UNUSED";
	/* transient soap skipped */
}

void genmech__equSlot::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &this->genmech__equSlot::boneName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->genmech__equSlot::boneName);
	soap_embedded(soap, &this->genmech__equSlot::defaultEqu, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->genmech__equSlot::defaultEqu);
	/* transient soap skipped */
}

int genmech__equSlot::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_genmech__equSlot);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int genmech__equSlot::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_genmech__equSlot(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_genmech__equSlot(struct soap *soap, const char *tag, int id, const genmech__equSlot *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_genmech__equSlot), type))
		return soap->error;
	if (soap_out_std__string(soap, "genmech:boneName", -1, &(a->genmech__equSlot::boneName), ""))
		return soap->error;
	if (soap_out_std__string(soap, "genmech:defaultEqu", -1, &(a->genmech__equSlot::defaultEqu), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *genmech__equSlot::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_genmech__equSlot(soap, this, tag, type);
}

SOAP_FMAC3 genmech__equSlot * SOAP_FMAC4 soap_get_genmech__equSlot(struct soap *soap, genmech__equSlot *p, const char *tag, const char *type)
{
	if ((p = soap_in_genmech__equSlot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *genmech__equSlot::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_genmech__equSlot(soap, tag, this, type);
}

SOAP_FMAC3 genmech__equSlot * SOAP_FMAC4 soap_in_genmech__equSlot(struct soap *soap, const char *tag, genmech__equSlot *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (genmech__equSlot *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_genmech__equSlot, sizeof(genmech__equSlot), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_genmech__equSlot)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (genmech__equSlot *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_boneName1 = 1, soap_flag_defaultEqu1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_boneName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "genmech:boneName", &(a->genmech__equSlot::boneName), "xsd:string"))
				{	soap_flag_boneName1--;
					continue;
				}
			if (soap_flag_defaultEqu1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "genmech:defaultEqu", &(a->genmech__equSlot::defaultEqu), "xsd:string"))
				{	soap_flag_defaultEqu1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (genmech__equSlot *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_genmech__equSlot, 0, sizeof(genmech__equSlot), 0, soap_copy_genmech__equSlot);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_boneName1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 genmech__equSlot * SOAP_FMAC6 soap_new_genmech__equSlot(struct soap *soap, int n)
{	return soap_instantiate_genmech__equSlot(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_genmech__equSlot(struct soap *soap, genmech__equSlot *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 genmech__equSlot * SOAP_FMAC4 soap_instantiate_genmech__equSlot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_genmech__equSlot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_genmech__equSlot, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new genmech__equSlot;
		if (size)
			*size = sizeof(genmech__equSlot);
		((genmech__equSlot*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new genmech__equSlot[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(genmech__equSlot);
		for (int i = 0; i < n; i++)
			((genmech__equSlot*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (genmech__equSlot*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_genmech__equSlot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying genmech__equSlot %p -> %p\n", q, p));
	*(genmech__equSlot*)p = *(genmech__equSlot*)q;
}

void genmech__equSlots::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__vectorTemplateOfPointerTogenmech__equSlot(soap, &this->genmech__equSlots::slot);
	/* transient soap skipped */
}

void genmech__equSlots::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_std__vectorTemplateOfPointerTogenmech__equSlot(soap, &this->genmech__equSlots::slot);
	/* transient soap skipped */
}

int genmech__equSlots::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_genmech__equSlots);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int genmech__equSlots::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_genmech__equSlots(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_genmech__equSlots(struct soap *soap, const char *tag, int id, const genmech__equSlots *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_genmech__equSlots), type))
		return soap->error;
	if (soap_out_std__vectorTemplateOfPointerTogenmech__equSlot(soap, "genmech:slot", -1, &(a->genmech__equSlots::slot), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *genmech__equSlots::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_genmech__equSlots(soap, this, tag, type);
}

SOAP_FMAC3 genmech__equSlots * SOAP_FMAC4 soap_get_genmech__equSlots(struct soap *soap, genmech__equSlots *p, const char *tag, const char *type)
{
	if ((p = soap_in_genmech__equSlots(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *genmech__equSlots::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_genmech__equSlots(soap, tag, this, type);
}

SOAP_FMAC3 genmech__equSlots * SOAP_FMAC4 soap_in_genmech__equSlots(struct soap *soap, const char *tag, genmech__equSlots *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (genmech__equSlots *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_genmech__equSlots, sizeof(genmech__equSlots), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_genmech__equSlots)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (genmech__equSlots *)a->soap_in(soap, tag, type);
		}
	}
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_std__vectorTemplateOfPointerTogenmech__equSlot(soap, "genmech:slot", &(a->genmech__equSlots::slot), "genmech:equSlot"))
					continue;
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (genmech__equSlots *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_genmech__equSlots, 0, sizeof(genmech__equSlots), 0, soap_copy_genmech__equSlots);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 genmech__equSlots * SOAP_FMAC6 soap_new_genmech__equSlots(struct soap *soap, int n)
{	return soap_instantiate_genmech__equSlots(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_genmech__equSlots(struct soap *soap, genmech__equSlots *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 genmech__equSlots * SOAP_FMAC4 soap_instantiate_genmech__equSlots(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_genmech__equSlots(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_genmech__equSlots, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new genmech__equSlots;
		if (size)
			*size = sizeof(genmech__equSlots);
		((genmech__equSlots*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new genmech__equSlots[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(genmech__equSlots);
		for (int i = 0; i < n; i++)
			((genmech__equSlots*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (genmech__equSlots*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_genmech__equSlots(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying genmech__equSlots %p -> %p\n", q, p));
	*(genmech__equSlots*)p = *(genmech__equSlots*)q;
}

void genmech__design::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->genmech__design::torso = NULL;
	this->genmech__design::equipmentSlots = NULL;
	soap_default_std__string(soap, &this->genmech__design::torsoBone);
	/* transient soap skipped */
}

void genmech__design::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTogenmech__torso(soap, &this->genmech__design::torso);
	soap_serialize_PointerTogenmech__equSlots(soap, &this->genmech__design::equipmentSlots);
	soap_embedded(soap, &this->genmech__design::torsoBone, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &this->genmech__design::torsoBone);
	/* transient soap skipped */
}

int genmech__design::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_genmech__design);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int genmech__design::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_genmech__design(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_genmech__design(struct soap *soap, const char *tag, int id, const genmech__design *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_genmech__design), type))
		return soap->error;
	if (soap_out_PointerTogenmech__torso(soap, "genmech:torso", -1, &(a->genmech__design::torso), ""))
		return soap->error;
	if (soap_out_PointerTogenmech__equSlots(soap, "genmech:equipmentSlots", -1, &(a->genmech__design::equipmentSlots), ""))
		return soap->error;
	if (soap_out_std__string(soap, "genmech:torsoBone", -1, &(a->genmech__design::torsoBone), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *genmech__design::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_genmech__design(soap, this, tag, type);
}

SOAP_FMAC3 genmech__design * SOAP_FMAC4 soap_get_genmech__design(struct soap *soap, genmech__design *p, const char *tag, const char *type)
{
	if ((p = soap_in_genmech__design(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *genmech__design::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_genmech__design(soap, tag, this, type);
}

SOAP_FMAC3 genmech__design * SOAP_FMAC4 soap_in_genmech__design(struct soap *soap, const char *tag, genmech__design *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (genmech__design *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_genmech__design, sizeof(genmech__design), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_genmech__design)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (genmech__design *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_torso1 = 1, soap_flag_equipmentSlots1 = 1, soap_flag_torsoBone1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_torso1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogenmech__torso(soap, "genmech:torso", &(a->genmech__design::torso), "genmech:torso"))
				{	soap_flag_torso1--;
					continue;
				}
			if (soap_flag_equipmentSlots1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTogenmech__equSlots(soap, "genmech:equipmentSlots", &(a->genmech__design::equipmentSlots), "genmech:equSlots"))
				{	soap_flag_equipmentSlots1--;
					continue;
				}
			if (soap_flag_torsoBone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "genmech:torsoBone", &(a->genmech__design::torsoBone), "xsd:string"))
				{	soap_flag_torsoBone1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (genmech__design *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_genmech__design, 0, sizeof(genmech__design), 0, soap_copy_genmech__design);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_torso1 > 0 || soap_flag_equipmentSlots1 > 0 || soap_flag_torsoBone1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 genmech__design * SOAP_FMAC6 soap_new_genmech__design(struct soap *soap, int n)
{	return soap_instantiate_genmech__design(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_genmech__design(struct soap *soap, genmech__design *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 genmech__design * SOAP_FMAC4 soap_instantiate_genmech__design(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_genmech__design(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_genmech__design, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new genmech__design;
		if (size)
			*size = sizeof(genmech__design);
		((genmech__design*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new genmech__design[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(genmech__design);
		for (int i = 0; i < n; i++)
			((genmech__design*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (genmech__design*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_genmech__design(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying genmech__design %p -> %p\n", q, p));
	*(genmech__design*)p = *(genmech__design*)q;
}

void genmech__stats::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_int(soap, &this->genmech__stats::maxTurnRate);
	soap_default_int(soap, &this->genmech__stats::maxForwardAcceleration);
	soap_default_int(soap, &this->genmech__stats::maxBackwardAcceleration);
	soap_default_int(soap, &this->genmech__stats::maxSpeed);
	/* transient soap skipped */
}

void genmech__stats::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int genmech__stats::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_genmech__stats);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int genmech__stats::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_genmech__stats(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_genmech__stats(struct soap *soap, const char *tag, int id, const genmech__stats *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_genmech__stats), type))
		return soap->error;
	if (soap_out_int(soap, "genmech:maxTurnRate", -1, &(a->genmech__stats::maxTurnRate), ""))
		return soap->error;
	if (soap_out_int(soap, "genmech:maxForwardAcceleration", -1, &(a->genmech__stats::maxForwardAcceleration), ""))
		return soap->error;
	if (soap_out_int(soap, "genmech:maxBackwardAcceleration", -1, &(a->genmech__stats::maxBackwardAcceleration), ""))
		return soap->error;
	if (soap_out_int(soap, "genmech:maxSpeed", -1, &(a->genmech__stats::maxSpeed), ""))
		return soap->error;
	/* transient soap skipped */
	return soap_element_end_out(soap, tag);
}

void *genmech__stats::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_genmech__stats(soap, this, tag, type);
}

SOAP_FMAC3 genmech__stats * SOAP_FMAC4 soap_get_genmech__stats(struct soap *soap, genmech__stats *p, const char *tag, const char *type)
{
	if ((p = soap_in_genmech__stats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

void *genmech__stats::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_genmech__stats(soap, tag, this, type);
}

SOAP_FMAC3 genmech__stats * SOAP_FMAC4 soap_in_genmech__stats(struct soap *soap, const char *tag, genmech__stats *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (genmech__stats *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_genmech__stats, sizeof(genmech__stats), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_genmech__stats)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (genmech__stats *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_maxTurnRate1 = 1, soap_flag_maxForwardAcceleration1 = 1, soap_flag_maxBackwardAcceleration1 = 1, soap_flag_maxSpeed1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_maxTurnRate1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "genmech:maxTurnRate", &(a->genmech__stats::maxTurnRate), "xsd:int"))
				{	soap_flag_maxTurnRate1--;
					continue;
				}
			if (soap_flag_maxForwardAcceleration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "genmech:maxForwardAcceleration", &(a->genmech__stats::maxForwardAcceleration), "xsd:int"))
				{	soap_flag_maxForwardAcceleration1--;
					continue;
				}
			if (soap_flag_maxBackwardAcceleration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "genmech:maxBackwardAcceleration", &(a->genmech__stats::maxBackwardAcceleration), "xsd:int"))
				{	soap_flag_maxBackwardAcceleration1--;
					continue;
				}
			if (soap_flag_maxSpeed1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_int(soap, "genmech:maxSpeed", &(a->genmech__stats::maxSpeed), "xsd:int"))
				{	soap_flag_maxSpeed1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (genmech__stats *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_genmech__stats, 0, sizeof(genmech__stats), 0, soap_copy_genmech__stats);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_maxTurnRate1 > 0 || soap_flag_maxForwardAcceleration1 > 0 || soap_flag_maxBackwardAcceleration1 > 0 || soap_flag_maxSpeed1 > 0))
	{	soap->error = SOAP_OCCURS;
		return NULL;
	}
	return a;
}

SOAP_FMAC5 genmech__stats * SOAP_FMAC6 soap_new_genmech__stats(struct soap *soap, int n)
{	return soap_instantiate_genmech__stats(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_genmech__stats(struct soap *soap, genmech__stats *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 genmech__stats * SOAP_FMAC4 soap_instantiate_genmech__stats(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_genmech__stats(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_genmech__stats, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new genmech__stats;
		if (size)
			*size = sizeof(genmech__stats);
		((genmech__stats*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new genmech__stats[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(genmech__stats);
		for (int i = 0; i < n; i++)
			((genmech__stats*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (genmech__stats*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_genmech__stats(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying genmech__stats %p -> %p\n", q, p));
	*(genmech__stats*)p = *(genmech__stats*)q;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, &a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, &a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	soap_outliteral(soap, "-any", &a->__any, NULL);
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__genmesh__union_levelofdetail(struct soap *soap, int choice, const union _genmesh__union_levelofdetail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	switch (choice)
	{
	case SOAP_UNION__genmesh__union_levelofdetail_genmesh__lodmanual:
		soap_serialize_PointerTo_genmesh__lodmanual(soap, &a->genmesh__lodmanual);
		break;
	case SOAP_UNION__genmesh__union_levelofdetail_genmesh__lodgenerated:
		soap_serialize_PointerTo_genmesh__lodgenerated(soap, &a->genmesh__lodgenerated);
		break;
	default:
		break;
	}
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__genmesh__union_levelofdetail(struct soap *soap, int choice, const union _genmesh__union_levelofdetail *a)
{
	switch (choice)
	{
	case SOAP_UNION__genmesh__union_levelofdetail_genmesh__lodmanual:
		return soap_out_PointerTo_genmesh__lodmanual(soap, "genmesh:lodmanual", -1, &a->genmesh__lodmanual, "");
	case SOAP_UNION__genmesh__union_levelofdetail_genmesh__lodgenerated:
		return soap_out_PointerTo_genmesh__lodgenerated(soap, "genmesh:lodgenerated", -1, &a->genmesh__lodgenerated, "");
	default:
		break;
	}
	return SOAP_OK;
}

SOAP_FMAC3 union _genmesh__union_levelofdetail * SOAP_FMAC4 soap_in__genmesh__union_levelofdetail(struct soap *soap, int *choice, union _genmesh__union_levelofdetail *a)
{	soap->error = SOAP_TAG_MISMATCH;
	a->genmesh__lodmanual = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTo_genmesh__lodmanual(soap, "genmesh:lodmanual", &a->genmesh__lodmanual, ""))
	{	*choice = SOAP_UNION__genmesh__union_levelofdetail_genmesh__lodmanual;
		return a;
	}
	a->genmesh__lodgenerated = NULL;
	if (soap->error == SOAP_TAG_MISMATCH && soap_in_PointerTo_genmesh__lodgenerated(soap, "genmesh:lodgenerated", &a->genmesh__lodgenerated, ""))
	{	*choice = SOAP_UNION__genmesh__union_levelofdetail_genmesh__lodgenerated;
		return a;
	}
	*choice = 0;
	if (!soap->error)
		soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genskel__animationlink(struct soap *soap, _genskel__animationlink *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genskel__animationlink))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genskel__animationlink(struct soap *soap, _genskel__animationlink *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genskel__animationlink);
	if (soap_out_PointerTo_genskel__animationlink(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genskel__animationlink(struct soap *soap, const char *tag, int id, _genskel__animationlink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genskel__animationlink);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genskel__animationlink ** SOAP_FMAC4 soap_get_PointerTo_genskel__animationlink(struct soap *soap, _genskel__animationlink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genskel__animationlink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genskel__animationlink ** SOAP_FMAC4 soap_in_PointerTo_genskel__animationlink(struct soap *soap, const char *tag, _genskel__animationlink **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genskel__animationlink **)soap_malloc(soap, sizeof(_genskel__animationlink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genskel__animationlink *)soap_instantiate__genskel__animationlink(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genskel__animationlink ** p = (_genskel__animationlink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genskel__animationlink, sizeof(_genskel__animationlink), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genskel__rotate(struct soap *soap, _genskel__rotate *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genskel__rotate))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genskel__rotate(struct soap *soap, _genskel__rotate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genskel__rotate);
	if (soap_out_PointerTo_genskel__rotate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genskel__rotate(struct soap *soap, const char *tag, int id, _genskel__rotate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genskel__rotate);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genskel__rotate ** SOAP_FMAC4 soap_get_PointerTo_genskel__rotate(struct soap *soap, _genskel__rotate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genskel__rotate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genskel__rotate ** SOAP_FMAC4 soap_in_PointerTo_genskel__rotate(struct soap *soap, const char *tag, _genskel__rotate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genskel__rotate **)soap_malloc(soap, sizeof(_genskel__rotate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genskel__rotate *)soap_instantiate__genskel__rotate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genskel__rotate ** p = (_genskel__rotate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genskel__rotate, sizeof(_genskel__rotate), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genskel__translate(struct soap *soap, _genskel__translate *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genskel__translate))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genskel__translate(struct soap *soap, _genskel__translate *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genskel__translate);
	if (soap_out_PointerTo_genskel__translate(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genskel__translate(struct soap *soap, const char *tag, int id, _genskel__translate *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genskel__translate);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genskel__translate ** SOAP_FMAC4 soap_get_PointerTo_genskel__translate(struct soap *soap, _genskel__translate **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genskel__translate(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genskel__translate ** SOAP_FMAC4 soap_in_PointerTo_genskel__translate(struct soap *soap, const char *tag, _genskel__translate **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genskel__translate **)soap_malloc(soap, sizeof(_genskel__translate *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genskel__translate *)soap_instantiate__genskel__translate(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genskel__translate ** p = (_genskel__translate **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genskel__translate, sizeof(_genskel__translate), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genskel__keyframe(struct soap *soap, _genskel__keyframe *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genskel__keyframe))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genskel__keyframe(struct soap *soap, _genskel__keyframe *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genskel__keyframe);
	if (soap_out_PointerTo_genskel__keyframe(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genskel__keyframe(struct soap *soap, const char *tag, int id, _genskel__keyframe *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genskel__keyframe);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genskel__keyframe ** SOAP_FMAC4 soap_get_PointerTo_genskel__keyframe(struct soap *soap, _genskel__keyframe **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genskel__keyframe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genskel__keyframe ** SOAP_FMAC4 soap_in_PointerTo_genskel__keyframe(struct soap *soap, const char *tag, _genskel__keyframe **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genskel__keyframe **)soap_malloc(soap, sizeof(_genskel__keyframe *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genskel__keyframe *)soap_instantiate__genskel__keyframe(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genskel__keyframe ** p = (_genskel__keyframe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genskel__keyframe, sizeof(_genskel__keyframe), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genskel__keyframes(struct soap *soap, _genskel__keyframes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genskel__keyframes))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genskel__keyframes(struct soap *soap, _genskel__keyframes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genskel__keyframes);
	if (soap_out_PointerTo_genskel__keyframes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genskel__keyframes(struct soap *soap, const char *tag, int id, _genskel__keyframes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genskel__keyframes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genskel__keyframes ** SOAP_FMAC4 soap_get_PointerTo_genskel__keyframes(struct soap *soap, _genskel__keyframes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genskel__keyframes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genskel__keyframes ** SOAP_FMAC4 soap_in_PointerTo_genskel__keyframes(struct soap *soap, const char *tag, _genskel__keyframes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genskel__keyframes **)soap_malloc(soap, sizeof(_genskel__keyframes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genskel__keyframes *)soap_instantiate__genskel__keyframes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genskel__keyframes ** p = (_genskel__keyframes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genskel__keyframes, sizeof(_genskel__keyframes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genskel__track(struct soap *soap, _genskel__track *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genskel__track))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genskel__track(struct soap *soap, _genskel__track *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genskel__track);
	if (soap_out_PointerTo_genskel__track(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genskel__track(struct soap *soap, const char *tag, int id, _genskel__track *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genskel__track);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genskel__track ** SOAP_FMAC4 soap_get_PointerTo_genskel__track(struct soap *soap, _genskel__track **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genskel__track(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genskel__track ** SOAP_FMAC4 soap_in_PointerTo_genskel__track(struct soap *soap, const char *tag, _genskel__track **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genskel__track **)soap_malloc(soap, sizeof(_genskel__track *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genskel__track *)soap_instantiate__genskel__track(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genskel__track ** p = (_genskel__track **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genskel__track, sizeof(_genskel__track), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genskel__tracks(struct soap *soap, _genskel__tracks *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genskel__tracks))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genskel__tracks(struct soap *soap, _genskel__tracks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genskel__tracks);
	if (soap_out_PointerTo_genskel__tracks(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genskel__tracks(struct soap *soap, const char *tag, int id, _genskel__tracks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genskel__tracks);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genskel__tracks ** SOAP_FMAC4 soap_get_PointerTo_genskel__tracks(struct soap *soap, _genskel__tracks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genskel__tracks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genskel__tracks ** SOAP_FMAC4 soap_in_PointerTo_genskel__tracks(struct soap *soap, const char *tag, _genskel__tracks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genskel__tracks **)soap_malloc(soap, sizeof(_genskel__tracks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genskel__tracks *)soap_instantiate__genskel__tracks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genskel__tracks ** p = (_genskel__tracks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genskel__tracks, sizeof(_genskel__tracks), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genskel__animation(struct soap *soap, _genskel__animation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genskel__animation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genskel__animation(struct soap *soap, _genskel__animation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genskel__animation);
	if (soap_out_PointerTo_genskel__animation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genskel__animation(struct soap *soap, const char *tag, int id, _genskel__animation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genskel__animation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genskel__animation ** SOAP_FMAC4 soap_get_PointerTo_genskel__animation(struct soap *soap, _genskel__animation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genskel__animation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genskel__animation ** SOAP_FMAC4 soap_in_PointerTo_genskel__animation(struct soap *soap, const char *tag, _genskel__animation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genskel__animation **)soap_malloc(soap, sizeof(_genskel__animation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genskel__animation *)soap_instantiate__genskel__animation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genskel__animation ** p = (_genskel__animation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genskel__animation, sizeof(_genskel__animation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genskel__boneparent(struct soap *soap, _genskel__boneparent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genskel__boneparent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genskel__boneparent(struct soap *soap, _genskel__boneparent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genskel__boneparent);
	if (soap_out_PointerTo_genskel__boneparent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genskel__boneparent(struct soap *soap, const char *tag, int id, _genskel__boneparent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genskel__boneparent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genskel__boneparent ** SOAP_FMAC4 soap_get_PointerTo_genskel__boneparent(struct soap *soap, _genskel__boneparent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genskel__boneparent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genskel__boneparent ** SOAP_FMAC4 soap_in_PointerTo_genskel__boneparent(struct soap *soap, const char *tag, _genskel__boneparent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genskel__boneparent **)soap_malloc(soap, sizeof(_genskel__boneparent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genskel__boneparent *)soap_instantiate__genskel__boneparent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genskel__boneparent ** p = (_genskel__boneparent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genskel__boneparent, sizeof(_genskel__boneparent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genskel__animationlinks(struct soap *soap, _genskel__animationlinks *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genskel__animationlinks))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genskel__animationlinks(struct soap *soap, _genskel__animationlinks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genskel__animationlinks);
	if (soap_out_PointerTo_genskel__animationlinks(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genskel__animationlinks(struct soap *soap, const char *tag, int id, _genskel__animationlinks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genskel__animationlinks);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genskel__animationlinks ** SOAP_FMAC4 soap_get_PointerTo_genskel__animationlinks(struct soap *soap, _genskel__animationlinks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genskel__animationlinks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genskel__animationlinks ** SOAP_FMAC4 soap_in_PointerTo_genskel__animationlinks(struct soap *soap, const char *tag, _genskel__animationlinks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genskel__animationlinks **)soap_malloc(soap, sizeof(_genskel__animationlinks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genskel__animationlinks *)soap_instantiate__genskel__animationlinks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genskel__animationlinks ** p = (_genskel__animationlinks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genskel__animationlinks, sizeof(_genskel__animationlinks), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genskel__animations(struct soap *soap, _genskel__animations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genskel__animations))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genskel__animations(struct soap *soap, _genskel__animations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genskel__animations);
	if (soap_out_PointerTo_genskel__animations(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genskel__animations(struct soap *soap, const char *tag, int id, _genskel__animations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genskel__animations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genskel__animations ** SOAP_FMAC4 soap_get_PointerTo_genskel__animations(struct soap *soap, _genskel__animations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genskel__animations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genskel__animations ** SOAP_FMAC4 soap_in_PointerTo_genskel__animations(struct soap *soap, const char *tag, _genskel__animations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genskel__animations **)soap_malloc(soap, sizeof(_genskel__animations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genskel__animations *)soap_instantiate__genskel__animations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genskel__animations ** p = (_genskel__animations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genskel__animations, sizeof(_genskel__animations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genskel__bonehierarchy(struct soap *soap, _genskel__bonehierarchy *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genskel__bonehierarchy))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genskel__bonehierarchy(struct soap *soap, _genskel__bonehierarchy *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genskel__bonehierarchy);
	if (soap_out_PointerTo_genskel__bonehierarchy(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genskel__bonehierarchy(struct soap *soap, const char *tag, int id, _genskel__bonehierarchy *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genskel__bonehierarchy);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genskel__bonehierarchy ** SOAP_FMAC4 soap_get_PointerTo_genskel__bonehierarchy(struct soap *soap, _genskel__bonehierarchy **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genskel__bonehierarchy(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genskel__bonehierarchy ** SOAP_FMAC4 soap_in_PointerTo_genskel__bonehierarchy(struct soap *soap, const char *tag, _genskel__bonehierarchy **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genskel__bonehierarchy **)soap_malloc(soap, sizeof(_genskel__bonehierarchy *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genskel__bonehierarchy *)soap_instantiate__genskel__bonehierarchy(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genskel__bonehierarchy ** p = (_genskel__bonehierarchy **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genskel__bonehierarchy, sizeof(_genskel__bonehierarchy), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogenskel__bones(struct soap *soap, genskel__bones *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_genskel__bones))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogenskel__bones(struct soap *soap, genskel__bones *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogenskel__bones);
	if (soap_out_PointerTogenskel__bones(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogenskel__bones(struct soap *soap, const char *tag, int id, genskel__bones *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_genskel__bones);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 genskel__bones ** SOAP_FMAC4 soap_get_PointerTogenskel__bones(struct soap *soap, genskel__bones **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogenskel__bones(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 genskel__bones ** SOAP_FMAC4 soap_in_PointerTogenskel__bones(struct soap *soap, const char *tag, genskel__bones **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (genskel__bones **)soap_malloc(soap, sizeof(genskel__bones *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (genskel__bones *)soap_instantiate_genskel__bones(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	genskel__bones ** p = (genskel__bones **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_genskel__bones, sizeof(genskel__bones), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogenskel__axis(struct soap *soap, genskel__axis *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_genskel__axis))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogenskel__axis(struct soap *soap, genskel__axis *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogenskel__axis);
	if (soap_out_PointerTogenskel__axis(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogenskel__axis(struct soap *soap, const char *tag, int id, genskel__axis *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_genskel__axis);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 genskel__axis ** SOAP_FMAC4 soap_get_PointerTogenskel__axis(struct soap *soap, genskel__axis **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogenskel__axis(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 genskel__axis ** SOAP_FMAC4 soap_in_PointerTogenskel__axis(struct soap *soap, const char *tag, genskel__axis **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (genskel__axis **)soap_malloc(soap, sizeof(genskel__axis *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (genskel__axis *)soap_instantiate_genskel__axis(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	genskel__axis ** p = (genskel__axis **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_genskel__axis, sizeof(genskel__axis), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogenskel__scale(struct soap *soap, genskel__scale *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_genskel__scale))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogenskel__scale(struct soap *soap, genskel__scale *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogenskel__scale);
	if (soap_out_PointerTogenskel__scale(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogenskel__scale(struct soap *soap, const char *tag, int id, genskel__scale *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_genskel__scale);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 genskel__scale ** SOAP_FMAC4 soap_get_PointerTogenskel__scale(struct soap *soap, genskel__scale **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogenskel__scale(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 genskel__scale ** SOAP_FMAC4 soap_in_PointerTogenskel__scale(struct soap *soap, const char *tag, genskel__scale **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (genskel__scale **)soap_malloc(soap, sizeof(genskel__scale *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (genskel__scale *)soap_instantiate_genskel__scale(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	genskel__scale ** p = (genskel__scale **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_genskel__scale, sizeof(genskel__scale), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogenskel__rotation(struct soap *soap, genskel__rotation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_genskel__rotation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogenskel__rotation(struct soap *soap, genskel__rotation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogenskel__rotation);
	if (soap_out_PointerTogenskel__rotation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogenskel__rotation(struct soap *soap, const char *tag, int id, genskel__rotation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_genskel__rotation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 genskel__rotation ** SOAP_FMAC4 soap_get_PointerTogenskel__rotation(struct soap *soap, genskel__rotation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogenskel__rotation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 genskel__rotation ** SOAP_FMAC4 soap_in_PointerTogenskel__rotation(struct soap *soap, const char *tag, genskel__rotation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (genskel__rotation **)soap_malloc(soap, sizeof(genskel__rotation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (genskel__rotation *)soap_instantiate_genskel__rotation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	genskel__rotation ** p = (genskel__rotation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_genskel__rotation, sizeof(genskel__rotation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogenskel__position(struct soap *soap, genskel__position *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_genskel__position))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogenskel__position(struct soap *soap, genskel__position *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogenskel__position);
	if (soap_out_PointerTogenskel__position(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogenskel__position(struct soap *soap, const char *tag, int id, genskel__position *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_genskel__position);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 genskel__position ** SOAP_FMAC4 soap_get_PointerTogenskel__position(struct soap *soap, genskel__position **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogenskel__position(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 genskel__position ** SOAP_FMAC4 soap_in_PointerTogenskel__position(struct soap *soap, const char *tag, genskel__position **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (genskel__position **)soap_malloc(soap, sizeof(genskel__position *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (genskel__position *)soap_instantiate_genskel__position(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	genskel__position ** p = (genskel__position **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_genskel__position, sizeof(genskel__position), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogenskel__bone(struct soap *soap, genskel__bone *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_genskel__bone))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogenskel__bone(struct soap *soap, genskel__bone *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogenskel__bone);
	if (soap_out_PointerTogenskel__bone(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogenskel__bone(struct soap *soap, const char *tag, int id, genskel__bone *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_genskel__bone);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 genskel__bone ** SOAP_FMAC4 soap_get_PointerTogenskel__bone(struct soap *soap, genskel__bone **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogenskel__bone(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 genskel__bone ** SOAP_FMAC4 soap_in_PointerTogenskel__bone(struct soap *soap, const char *tag, genskel__bone **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (genskel__bone **)soap_malloc(soap, sizeof(genskel__bone *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (genskel__bone *)soap_instantiate_genskel__bone(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	genskel__bone ** p = (genskel__bone **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_genskel__bone, sizeof(genskel__bone), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__poseref(struct soap *soap, _genmesh__poseref *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__poseref))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__poseref(struct soap *soap, _genmesh__poseref *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__poseref);
	if (soap_out_PointerTo_genmesh__poseref(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__poseref(struct soap *soap, const char *tag, int id, _genmesh__poseref *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__poseref);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__poseref ** SOAP_FMAC4 soap_get_PointerTo_genmesh__poseref(struct soap *soap, _genmesh__poseref **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__poseref(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__poseref ** SOAP_FMAC4 soap_in_PointerTo_genmesh__poseref(struct soap *soap, const char *tag, _genmesh__poseref **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__poseref **)soap_malloc(soap, sizeof(_genmesh__poseref *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__poseref *)soap_instantiate__genmesh__poseref(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__poseref ** p = (_genmesh__poseref **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__poseref, sizeof(_genmesh__poseref), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__keyframe(struct soap *soap, _genmesh__keyframe *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__keyframe))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__keyframe(struct soap *soap, _genmesh__keyframe *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__keyframe);
	if (soap_out_PointerTo_genmesh__keyframe(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__keyframe(struct soap *soap, const char *tag, int id, _genmesh__keyframe *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__keyframe);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__keyframe ** SOAP_FMAC4 soap_get_PointerTo_genmesh__keyframe(struct soap *soap, _genmesh__keyframe **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__keyframe(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__keyframe ** SOAP_FMAC4 soap_in_PointerTo_genmesh__keyframe(struct soap *soap, const char *tag, _genmesh__keyframe **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__keyframe **)soap_malloc(soap, sizeof(_genmesh__keyframe *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__keyframe *)soap_instantiate__genmesh__keyframe(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__keyframe ** p = (_genmesh__keyframe **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__keyframe, sizeof(_genmesh__keyframe), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__keyframes(struct soap *soap, _genmesh__keyframes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__keyframes))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__keyframes(struct soap *soap, _genmesh__keyframes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__keyframes);
	if (soap_out_PointerTo_genmesh__keyframes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__keyframes(struct soap *soap, const char *tag, int id, _genmesh__keyframes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__keyframes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__keyframes ** SOAP_FMAC4 soap_get_PointerTo_genmesh__keyframes(struct soap *soap, _genmesh__keyframes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__keyframes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__keyframes ** SOAP_FMAC4 soap_in_PointerTo_genmesh__keyframes(struct soap *soap, const char *tag, _genmesh__keyframes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__keyframes **)soap_malloc(soap, sizeof(_genmesh__keyframes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__keyframes *)soap_instantiate__genmesh__keyframes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__keyframes ** p = (_genmesh__keyframes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__keyframes, sizeof(_genmesh__keyframes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__track(struct soap *soap, _genmesh__track *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__track))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__track(struct soap *soap, _genmesh__track *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__track);
	if (soap_out_PointerTo_genmesh__track(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__track(struct soap *soap, const char *tag, int id, _genmesh__track *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__track);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__track ** SOAP_FMAC4 soap_get_PointerTo_genmesh__track(struct soap *soap, _genmesh__track **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__track(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__track ** SOAP_FMAC4 soap_in_PointerTo_genmesh__track(struct soap *soap, const char *tag, _genmesh__track **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__track **)soap_malloc(soap, sizeof(_genmesh__track *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__track *)soap_instantiate__genmesh__track(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__track ** p = (_genmesh__track **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__track, sizeof(_genmesh__track), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__tracks(struct soap *soap, _genmesh__tracks *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__tracks))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__tracks(struct soap *soap, _genmesh__tracks *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__tracks);
	if (soap_out_PointerTo_genmesh__tracks(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__tracks(struct soap *soap, const char *tag, int id, _genmesh__tracks *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__tracks);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__tracks ** SOAP_FMAC4 soap_get_PointerTo_genmesh__tracks(struct soap *soap, _genmesh__tracks **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__tracks(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__tracks ** SOAP_FMAC4 soap_in_PointerTo_genmesh__tracks(struct soap *soap, const char *tag, _genmesh__tracks **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__tracks **)soap_malloc(soap, sizeof(_genmesh__tracks *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__tracks *)soap_instantiate__genmesh__tracks(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__tracks ** p = (_genmesh__tracks **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__tracks, sizeof(_genmesh__tracks), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__animation(struct soap *soap, _genmesh__animation *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__animation))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__animation(struct soap *soap, _genmesh__animation *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__animation);
	if (soap_out_PointerTo_genmesh__animation(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__animation(struct soap *soap, const char *tag, int id, _genmesh__animation *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__animation);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__animation ** SOAP_FMAC4 soap_get_PointerTo_genmesh__animation(struct soap *soap, _genmesh__animation **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__animation(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__animation ** SOAP_FMAC4 soap_in_PointerTo_genmesh__animation(struct soap *soap, const char *tag, _genmesh__animation **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__animation **)soap_malloc(soap, sizeof(_genmesh__animation *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__animation *)soap_instantiate__genmesh__animation(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__animation ** p = (_genmesh__animation **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__animation, sizeof(_genmesh__animation), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__poseoffset(struct soap *soap, _genmesh__poseoffset *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__poseoffset))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__poseoffset(struct soap *soap, _genmesh__poseoffset *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__poseoffset);
	if (soap_out_PointerTo_genmesh__poseoffset(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__poseoffset(struct soap *soap, const char *tag, int id, _genmesh__poseoffset *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__poseoffset);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__poseoffset ** SOAP_FMAC4 soap_get_PointerTo_genmesh__poseoffset(struct soap *soap, _genmesh__poseoffset **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__poseoffset(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__poseoffset ** SOAP_FMAC4 soap_in_PointerTo_genmesh__poseoffset(struct soap *soap, const char *tag, _genmesh__poseoffset **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__poseoffset **)soap_malloc(soap, sizeof(_genmesh__poseoffset *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__poseoffset *)soap_instantiate__genmesh__poseoffset(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__poseoffset ** p = (_genmesh__poseoffset **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__poseoffset, sizeof(_genmesh__poseoffset), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__pose(struct soap *soap, _genmesh__pose *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__pose))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__pose(struct soap *soap, _genmesh__pose *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__pose);
	if (soap_out_PointerTo_genmesh__pose(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__pose(struct soap *soap, const char *tag, int id, _genmesh__pose *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__pose);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__pose ** SOAP_FMAC4 soap_get_PointerTo_genmesh__pose(struct soap *soap, _genmesh__pose **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__pose(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__pose ** SOAP_FMAC4 soap_in_PointerTo_genmesh__pose(struct soap *soap, const char *tag, _genmesh__pose **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__pose **)soap_malloc(soap, sizeof(_genmesh__pose *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__pose *)soap_instantiate__genmesh__pose(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__pose ** p = (_genmesh__pose **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__pose, sizeof(_genmesh__pose), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__submeshname(struct soap *soap, _genmesh__submeshname *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__submeshname))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__submeshname(struct soap *soap, _genmesh__submeshname *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__submeshname);
	if (soap_out_PointerTo_genmesh__submeshname(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__submeshname(struct soap *soap, const char *tag, int id, _genmesh__submeshname *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__submeshname);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__submeshname ** SOAP_FMAC4 soap_get_PointerTo_genmesh__submeshname(struct soap *soap, _genmesh__submeshname **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__submeshname(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__submeshname ** SOAP_FMAC4 soap_in_PointerTo_genmesh__submeshname(struct soap *soap, const char *tag, _genmesh__submeshname **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__submeshname **)soap_malloc(soap, sizeof(_genmesh__submeshname *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__submeshname *)soap_instantiate__genmesh__submeshname(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__submeshname ** p = (_genmesh__submeshname **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__submeshname, sizeof(_genmesh__submeshname), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__texcoord(struct soap *soap, _genmesh__texcoord *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__texcoord))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__texcoord(struct soap *soap, _genmesh__texcoord *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__texcoord);
	if (soap_out_PointerTo_genmesh__texcoord(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__texcoord(struct soap *soap, const char *tag, int id, _genmesh__texcoord *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__texcoord);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__texcoord ** SOAP_FMAC4 soap_get_PointerTo_genmesh__texcoord(struct soap *soap, _genmesh__texcoord **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__texcoord(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__texcoord ** SOAP_FMAC4 soap_in_PointerTo_genmesh__texcoord(struct soap *soap, const char *tag, _genmesh__texcoord **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__texcoord **)soap_malloc(soap, sizeof(_genmesh__texcoord *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__texcoord *)soap_instantiate__genmesh__texcoord(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__texcoord ** p = (_genmesh__texcoord **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__texcoord, sizeof(_genmesh__texcoord), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__colour_USCOREspecular(struct soap *soap, _genmesh__colour_USCOREspecular *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__colour_USCOREspecular))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__colour_USCOREspecular(struct soap *soap, _genmesh__colour_USCOREspecular *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__colour_USCOREspecular);
	if (soap_out_PointerTo_genmesh__colour_USCOREspecular(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__colour_USCOREspecular(struct soap *soap, const char *tag, int id, _genmesh__colour_USCOREspecular *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__colour_USCOREspecular);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__colour_USCOREspecular ** SOAP_FMAC4 soap_get_PointerTo_genmesh__colour_USCOREspecular(struct soap *soap, _genmesh__colour_USCOREspecular **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__colour_USCOREspecular(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__colour_USCOREspecular ** SOAP_FMAC4 soap_in_PointerTo_genmesh__colour_USCOREspecular(struct soap *soap, const char *tag, _genmesh__colour_USCOREspecular **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__colour_USCOREspecular **)soap_malloc(soap, sizeof(_genmesh__colour_USCOREspecular *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__colour_USCOREspecular *)soap_instantiate__genmesh__colour_USCOREspecular(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__colour_USCOREspecular ** p = (_genmesh__colour_USCOREspecular **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__colour_USCOREspecular, sizeof(_genmesh__colour_USCOREspecular), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__colour_USCOREdiffuse(struct soap *soap, _genmesh__colour_USCOREdiffuse *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__colour_USCOREdiffuse))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__colour_USCOREdiffuse(struct soap *soap, _genmesh__colour_USCOREdiffuse *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__colour_USCOREdiffuse);
	if (soap_out_PointerTo_genmesh__colour_USCOREdiffuse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__colour_USCOREdiffuse(struct soap *soap, const char *tag, int id, _genmesh__colour_USCOREdiffuse *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__colour_USCOREdiffuse);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__colour_USCOREdiffuse ** SOAP_FMAC4 soap_get_PointerTo_genmesh__colour_USCOREdiffuse(struct soap *soap, _genmesh__colour_USCOREdiffuse **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__colour_USCOREdiffuse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__colour_USCOREdiffuse ** SOAP_FMAC4 soap_in_PointerTo_genmesh__colour_USCOREdiffuse(struct soap *soap, const char *tag, _genmesh__colour_USCOREdiffuse **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__colour_USCOREdiffuse **)soap_malloc(soap, sizeof(_genmesh__colour_USCOREdiffuse *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__colour_USCOREdiffuse *)soap_instantiate__genmesh__colour_USCOREdiffuse(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__colour_USCOREdiffuse ** p = (_genmesh__colour_USCOREdiffuse **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__colour_USCOREdiffuse, sizeof(_genmesh__colour_USCOREdiffuse), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__binormal(struct soap *soap, _genmesh__binormal *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__binormal))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__binormal(struct soap *soap, _genmesh__binormal *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__binormal);
	if (soap_out_PointerTo_genmesh__binormal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__binormal(struct soap *soap, const char *tag, int id, _genmesh__binormal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__binormal);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__binormal ** SOAP_FMAC4 soap_get_PointerTo_genmesh__binormal(struct soap *soap, _genmesh__binormal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__binormal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__binormal ** SOAP_FMAC4 soap_in_PointerTo_genmesh__binormal(struct soap *soap, const char *tag, _genmesh__binormal **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__binormal **)soap_malloc(soap, sizeof(_genmesh__binormal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__binormal *)soap_instantiate__genmesh__binormal(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__binormal ** p = (_genmesh__binormal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__binormal, sizeof(_genmesh__binormal), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__tangent(struct soap *soap, _genmesh__tangent *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__tangent))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__tangent(struct soap *soap, _genmesh__tangent *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__tangent);
	if (soap_out_PointerTo_genmesh__tangent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__tangent(struct soap *soap, const char *tag, int id, _genmesh__tangent *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__tangent);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__tangent ** SOAP_FMAC4 soap_get_PointerTo_genmesh__tangent(struct soap *soap, _genmesh__tangent **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__tangent(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__tangent ** SOAP_FMAC4 soap_in_PointerTo_genmesh__tangent(struct soap *soap, const char *tag, _genmesh__tangent **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__tangent **)soap_malloc(soap, sizeof(_genmesh__tangent *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__tangent *)soap_instantiate__genmesh__tangent(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__tangent ** p = (_genmesh__tangent **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__tangent, sizeof(_genmesh__tangent), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__normal(struct soap *soap, _genmesh__normal *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__normal))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__normal(struct soap *soap, _genmesh__normal *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__normal);
	if (soap_out_PointerTo_genmesh__normal(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__normal(struct soap *soap, const char *tag, int id, _genmesh__normal *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__normal);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__normal ** SOAP_FMAC4 soap_get_PointerTo_genmesh__normal(struct soap *soap, _genmesh__normal **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__normal(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__normal ** SOAP_FMAC4 soap_in_PointerTo_genmesh__normal(struct soap *soap, const char *tag, _genmesh__normal **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__normal **)soap_malloc(soap, sizeof(_genmesh__normal *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__normal *)soap_instantiate__genmesh__normal(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__normal ** p = (_genmesh__normal **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__normal, sizeof(_genmesh__normal), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__position(struct soap *soap, _genmesh__position *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__position))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__position(struct soap *soap, _genmesh__position *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__position);
	if (soap_out_PointerTo_genmesh__position(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__position(struct soap *soap, const char *tag, int id, _genmesh__position *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__position);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__position ** SOAP_FMAC4 soap_get_PointerTo_genmesh__position(struct soap *soap, _genmesh__position **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__position(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__position ** SOAP_FMAC4 soap_in_PointerTo_genmesh__position(struct soap *soap, const char *tag, _genmesh__position **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__position **)soap_malloc(soap, sizeof(_genmesh__position *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__position *)soap_instantiate__genmesh__position(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__position ** p = (_genmesh__position **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__position, sizeof(_genmesh__position), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__vertex(struct soap *soap, _genmesh__vertex *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__vertex))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__vertex(struct soap *soap, _genmesh__vertex *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__vertex);
	if (soap_out_PointerTo_genmesh__vertex(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__vertex(struct soap *soap, const char *tag, int id, _genmesh__vertex *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__vertex);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__vertex ** SOAP_FMAC4 soap_get_PointerTo_genmesh__vertex(struct soap *soap, _genmesh__vertex **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__vertex(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__vertex ** SOAP_FMAC4 soap_in_PointerTo_genmesh__vertex(struct soap *soap, const char *tag, _genmesh__vertex **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__vertex **)soap_malloc(soap, sizeof(_genmesh__vertex *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__vertex *)soap_instantiate__genmesh__vertex(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__vertex ** p = (_genmesh__vertex **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__vertex, sizeof(_genmesh__vertex), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__genmesh__lodfacelist_sequence(struct soap *soap, __genmesh__lodfacelist_sequence *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___genmesh__lodfacelist_sequence))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__genmesh__lodfacelist_sequence(struct soap *soap, __genmesh__lodfacelist_sequence *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__genmesh__lodfacelist_sequence);
	if (soap_out_PointerTo__genmesh__lodfacelist_sequence(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__genmesh__lodfacelist_sequence(struct soap *soap, const char *tag, int id, __genmesh__lodfacelist_sequence *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___genmesh__lodfacelist_sequence);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __genmesh__lodfacelist_sequence ** SOAP_FMAC4 soap_get_PointerTo__genmesh__lodfacelist_sequence(struct soap *soap, __genmesh__lodfacelist_sequence **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__genmesh__lodfacelist_sequence(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 __genmesh__lodfacelist_sequence ** SOAP_FMAC4 soap_in_PointerTo__genmesh__lodfacelist_sequence(struct soap *soap, const char *tag, __genmesh__lodfacelist_sequence **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__genmesh__lodfacelist_sequence **)soap_malloc(soap, sizeof(__genmesh__lodfacelist_sequence *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__genmesh__lodfacelist_sequence *)soap_instantiate___genmesh__lodfacelist_sequence(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__genmesh__lodfacelist_sequence ** p = (__genmesh__lodfacelist_sequence **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___genmesh__lodfacelist_sequence, sizeof(__genmesh__lodfacelist_sequence), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__lodfacelist(struct soap *soap, _genmesh__lodfacelist *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__lodfacelist))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__lodfacelist(struct soap *soap, _genmesh__lodfacelist *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__lodfacelist);
	if (soap_out_PointerTo_genmesh__lodfacelist(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__lodfacelist(struct soap *soap, const char *tag, int id, _genmesh__lodfacelist *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__lodfacelist);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__lodfacelist ** SOAP_FMAC4 soap_get_PointerTo_genmesh__lodfacelist(struct soap *soap, _genmesh__lodfacelist **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__lodfacelist(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__lodfacelist ** SOAP_FMAC4 soap_in_PointerTo_genmesh__lodfacelist(struct soap *soap, const char *tag, _genmesh__lodfacelist **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__lodfacelist **)soap_malloc(soap, sizeof(_genmesh__lodfacelist *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__lodfacelist *)soap_instantiate__genmesh__lodfacelist(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__lodfacelist ** p = (_genmesh__lodfacelist **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__lodfacelist, sizeof(_genmesh__lodfacelist), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo__genmesh__union_levelofdetail(struct soap *soap, __genmesh__union_levelofdetail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE___genmesh__union_levelofdetail))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo__genmesh__union_levelofdetail(struct soap *soap, __genmesh__union_levelofdetail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo__genmesh__union_levelofdetail);
	if (soap_out_PointerTo__genmesh__union_levelofdetail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo__genmesh__union_levelofdetail(struct soap *soap, const char *tag, int id, __genmesh__union_levelofdetail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE___genmesh__union_levelofdetail);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 __genmesh__union_levelofdetail ** SOAP_FMAC4 soap_get_PointerTo__genmesh__union_levelofdetail(struct soap *soap, __genmesh__union_levelofdetail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo__genmesh__union_levelofdetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 __genmesh__union_levelofdetail ** SOAP_FMAC4 soap_in_PointerTo__genmesh__union_levelofdetail(struct soap *soap, const char *tag, __genmesh__union_levelofdetail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (__genmesh__union_levelofdetail **)soap_malloc(soap, sizeof(__genmesh__union_levelofdetail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (__genmesh__union_levelofdetail *)soap_instantiate___genmesh__union_levelofdetail(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	__genmesh__union_levelofdetail ** p = (__genmesh__union_levelofdetail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE___genmesh__union_levelofdetail, sizeof(__genmesh__union_levelofdetail), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__lodgenerated(struct soap *soap, _genmesh__lodgenerated *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__lodgenerated))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__lodgenerated(struct soap *soap, _genmesh__lodgenerated *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__lodgenerated);
	if (soap_out_PointerTo_genmesh__lodgenerated(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__lodgenerated(struct soap *soap, const char *tag, int id, _genmesh__lodgenerated *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__lodgenerated);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__lodgenerated ** SOAP_FMAC4 soap_get_PointerTo_genmesh__lodgenerated(struct soap *soap, _genmesh__lodgenerated **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__lodgenerated(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__lodgenerated ** SOAP_FMAC4 soap_in_PointerTo_genmesh__lodgenerated(struct soap *soap, const char *tag, _genmesh__lodgenerated **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__lodgenerated **)soap_malloc(soap, sizeof(_genmesh__lodgenerated *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__lodgenerated *)soap_instantiate__genmesh__lodgenerated(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__lodgenerated ** p = (_genmesh__lodgenerated **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__lodgenerated, sizeof(_genmesh__lodgenerated), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__lodmanual(struct soap *soap, _genmesh__lodmanual *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__lodmanual))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__lodmanual(struct soap *soap, _genmesh__lodmanual *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__lodmanual);
	if (soap_out_PointerTo_genmesh__lodmanual(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__lodmanual(struct soap *soap, const char *tag, int id, _genmesh__lodmanual *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__lodmanual);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__lodmanual ** SOAP_FMAC4 soap_get_PointerTo_genmesh__lodmanual(struct soap *soap, _genmesh__lodmanual **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__lodmanual(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__lodmanual ** SOAP_FMAC4 soap_in_PointerTo_genmesh__lodmanual(struct soap *soap, const char *tag, _genmesh__lodmanual **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__lodmanual **)soap_malloc(soap, sizeof(_genmesh__lodmanual *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__lodmanual *)soap_instantiate__genmesh__lodmanual(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__lodmanual ** p = (_genmesh__lodmanual **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__lodmanual, sizeof(_genmesh__lodmanual), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__vertexboneassignment(struct soap *soap, _genmesh__vertexboneassignment *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__vertexboneassignment))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__vertexboneassignment(struct soap *soap, _genmesh__vertexboneassignment *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__vertexboneassignment);
	if (soap_out_PointerTo_genmesh__vertexboneassignment(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__vertexboneassignment(struct soap *soap, const char *tag, int id, _genmesh__vertexboneassignment *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__vertexboneassignment);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__vertexboneassignment ** SOAP_FMAC4 soap_get_PointerTo_genmesh__vertexboneassignment(struct soap *soap, _genmesh__vertexboneassignment **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__vertexboneassignment(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__vertexboneassignment ** SOAP_FMAC4 soap_in_PointerTo_genmesh__vertexboneassignment(struct soap *soap, const char *tag, _genmesh__vertexboneassignment **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__vertexboneassignment **)soap_malloc(soap, sizeof(_genmesh__vertexboneassignment *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__vertexboneassignment *)soap_instantiate__genmesh__vertexboneassignment(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__vertexboneassignment ** p = (_genmesh__vertexboneassignment **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__vertexboneassignment, sizeof(_genmesh__vertexboneassignment), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__face(struct soap *soap, _genmesh__face *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__face))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__face(struct soap *soap, _genmesh__face *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__face);
	if (soap_out_PointerTo_genmesh__face(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__face(struct soap *soap, const char *tag, int id, _genmesh__face *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__face);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__face ** SOAP_FMAC4 soap_get_PointerTo_genmesh__face(struct soap *soap, _genmesh__face **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__face(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__face ** SOAP_FMAC4 soap_in_PointerTo_genmesh__face(struct soap *soap, const char *tag, _genmesh__face **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__face **)soap_malloc(soap, sizeof(_genmesh__face *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__face *)soap_instantiate__genmesh__face(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__face ** p = (_genmesh__face **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__face, sizeof(_genmesh__face), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__texture(struct soap *soap, _genmesh__texture *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__texture))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__texture(struct soap *soap, _genmesh__texture *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__texture);
	if (soap_out_PointerTo_genmesh__texture(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__texture(struct soap *soap, const char *tag, int id, _genmesh__texture *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__texture);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__texture ** SOAP_FMAC4 soap_get_PointerTo_genmesh__texture(struct soap *soap, _genmesh__texture **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__texture(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__texture ** SOAP_FMAC4 soap_in_PointerTo_genmesh__texture(struct soap *soap, const char *tag, _genmesh__texture **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__texture **)soap_malloc(soap, sizeof(_genmesh__texture *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__texture *)soap_instantiate__genmesh__texture(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__texture ** p = (_genmesh__texture **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__texture, sizeof(_genmesh__texture), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__geometry(struct soap *soap, _genmesh__geometry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__geometry))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__geometry(struct soap *soap, _genmesh__geometry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__geometry);
	if (soap_out_PointerTo_genmesh__geometry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__geometry(struct soap *soap, const char *tag, int id, _genmesh__geometry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__geometry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__geometry ** SOAP_FMAC4 soap_get_PointerTo_genmesh__geometry(struct soap *soap, _genmesh__geometry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__geometry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__geometry ** SOAP_FMAC4 soap_in_PointerTo_genmesh__geometry(struct soap *soap, const char *tag, _genmesh__geometry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__geometry **)soap_malloc(soap, sizeof(_genmesh__geometry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__geometry *)soap_instantiate__genmesh__geometry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__geometry ** p = (_genmesh__geometry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__geometry, sizeof(_genmesh__geometry), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__faces(struct soap *soap, _genmesh__faces *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__faces))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__faces(struct soap *soap, _genmesh__faces *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__faces);
	if (soap_out_PointerTo_genmesh__faces(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__faces(struct soap *soap, const char *tag, int id, _genmesh__faces *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__faces);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__faces ** SOAP_FMAC4 soap_get_PointerTo_genmesh__faces(struct soap *soap, _genmesh__faces **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__faces(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__faces ** SOAP_FMAC4 soap_in_PointerTo_genmesh__faces(struct soap *soap, const char *tag, _genmesh__faces **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__faces **)soap_malloc(soap, sizeof(_genmesh__faces *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__faces *)soap_instantiate__genmesh__faces(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__faces ** p = (_genmesh__faces **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__faces, sizeof(_genmesh__faces), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__textures(struct soap *soap, _genmesh__textures *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__textures))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__textures(struct soap *soap, _genmesh__textures *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__textures);
	if (soap_out_PointerTo_genmesh__textures(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__textures(struct soap *soap, const char *tag, int id, _genmesh__textures *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__textures);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__textures ** SOAP_FMAC4 soap_get_PointerTo_genmesh__textures(struct soap *soap, _genmesh__textures **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__textures(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__textures ** SOAP_FMAC4 soap_in_PointerTo_genmesh__textures(struct soap *soap, const char *tag, _genmesh__textures **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__textures **)soap_malloc(soap, sizeof(_genmesh__textures *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__textures *)soap_instantiate__genmesh__textures(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__textures ** p = (_genmesh__textures **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__textures, sizeof(_genmesh__textures), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__submesh(struct soap *soap, _genmesh__submesh *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__submesh))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__submesh(struct soap *soap, _genmesh__submesh *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__submesh);
	if (soap_out_PointerTo_genmesh__submesh(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__submesh(struct soap *soap, const char *tag, int id, _genmesh__submesh *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__submesh);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__submesh ** SOAP_FMAC4 soap_get_PointerTo_genmesh__submesh(struct soap *soap, _genmesh__submesh **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__submesh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__submesh ** SOAP_FMAC4 soap_in_PointerTo_genmesh__submesh(struct soap *soap, const char *tag, _genmesh__submesh **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__submesh **)soap_malloc(soap, sizeof(_genmesh__submesh *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__submesh *)soap_instantiate__genmesh__submesh(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__submesh ** p = (_genmesh__submesh **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__submesh, sizeof(_genmesh__submesh), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__vertexbuffer(struct soap *soap, _genmesh__vertexbuffer *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__vertexbuffer))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__vertexbuffer(struct soap *soap, _genmesh__vertexbuffer *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__vertexbuffer);
	if (soap_out_PointerTo_genmesh__vertexbuffer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__vertexbuffer(struct soap *soap, const char *tag, int id, _genmesh__vertexbuffer *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__vertexbuffer);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__vertexbuffer ** SOAP_FMAC4 soap_get_PointerTo_genmesh__vertexbuffer(struct soap *soap, _genmesh__vertexbuffer **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__vertexbuffer(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__vertexbuffer ** SOAP_FMAC4 soap_in_PointerTo_genmesh__vertexbuffer(struct soap *soap, const char *tag, _genmesh__vertexbuffer **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__vertexbuffer **)soap_malloc(soap, sizeof(_genmesh__vertexbuffer *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__vertexbuffer *)soap_instantiate__genmesh__vertexbuffer(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__vertexbuffer ** p = (_genmesh__vertexbuffer **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__vertexbuffer, sizeof(_genmesh__vertexbuffer), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__extremes(struct soap *soap, _genmesh__extremes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__extremes))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__extremes(struct soap *soap, _genmesh__extremes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__extremes);
	if (soap_out_PointerTo_genmesh__extremes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__extremes(struct soap *soap, const char *tag, int id, _genmesh__extremes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__extremes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__extremes ** SOAP_FMAC4 soap_get_PointerTo_genmesh__extremes(struct soap *soap, _genmesh__extremes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__extremes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__extremes ** SOAP_FMAC4 soap_in_PointerTo_genmesh__extremes(struct soap *soap, const char *tag, _genmesh__extremes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__extremes **)soap_malloc(soap, sizeof(_genmesh__extremes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__extremes *)soap_instantiate__genmesh__extremes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__extremes ** p = (_genmesh__extremes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__extremes, sizeof(_genmesh__extremes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__animations(struct soap *soap, _genmesh__animations *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__animations))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__animations(struct soap *soap, _genmesh__animations *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__animations);
	if (soap_out_PointerTo_genmesh__animations(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__animations(struct soap *soap, const char *tag, int id, _genmesh__animations *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__animations);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__animations ** SOAP_FMAC4 soap_get_PointerTo_genmesh__animations(struct soap *soap, _genmesh__animations **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__animations(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__animations ** SOAP_FMAC4 soap_in_PointerTo_genmesh__animations(struct soap *soap, const char *tag, _genmesh__animations **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__animations **)soap_malloc(soap, sizeof(_genmesh__animations *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__animations *)soap_instantiate__genmesh__animations(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__animations ** p = (_genmesh__animations **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__animations, sizeof(_genmesh__animations), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__poses(struct soap *soap, _genmesh__poses *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__poses))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__poses(struct soap *soap, _genmesh__poses *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__poses);
	if (soap_out_PointerTo_genmesh__poses(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__poses(struct soap *soap, const char *tag, int id, _genmesh__poses *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__poses);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__poses ** SOAP_FMAC4 soap_get_PointerTo_genmesh__poses(struct soap *soap, _genmesh__poses **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__poses(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__poses ** SOAP_FMAC4 soap_in_PointerTo_genmesh__poses(struct soap *soap, const char *tag, _genmesh__poses **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__poses **)soap_malloc(soap, sizeof(_genmesh__poses *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__poses *)soap_instantiate__genmesh__poses(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__poses ** p = (_genmesh__poses **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__poses, sizeof(_genmesh__poses), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__submeshnames(struct soap *soap, _genmesh__submeshnames *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__submeshnames))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__submeshnames(struct soap *soap, _genmesh__submeshnames *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__submeshnames);
	if (soap_out_PointerTo_genmesh__submeshnames(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__submeshnames(struct soap *soap, const char *tag, int id, _genmesh__submeshnames *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__submeshnames);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__submeshnames ** SOAP_FMAC4 soap_get_PointerTo_genmesh__submeshnames(struct soap *soap, _genmesh__submeshnames **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__submeshnames(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__submeshnames ** SOAP_FMAC4 soap_in_PointerTo_genmesh__submeshnames(struct soap *soap, const char *tag, _genmesh__submeshnames **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__submeshnames **)soap_malloc(soap, sizeof(_genmesh__submeshnames *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__submeshnames *)soap_instantiate__genmesh__submeshnames(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__submeshnames ** p = (_genmesh__submeshnames **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__submeshnames, sizeof(_genmesh__submeshnames), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__levelofdetail(struct soap *soap, _genmesh__levelofdetail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__levelofdetail))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__levelofdetail(struct soap *soap, _genmesh__levelofdetail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__levelofdetail);
	if (soap_out_PointerTo_genmesh__levelofdetail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__levelofdetail(struct soap *soap, const char *tag, int id, _genmesh__levelofdetail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__levelofdetail);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__levelofdetail ** SOAP_FMAC4 soap_get_PointerTo_genmesh__levelofdetail(struct soap *soap, _genmesh__levelofdetail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__levelofdetail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__levelofdetail ** SOAP_FMAC4 soap_in_PointerTo_genmesh__levelofdetail(struct soap *soap, const char *tag, _genmesh__levelofdetail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__levelofdetail **)soap_malloc(soap, sizeof(_genmesh__levelofdetail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__levelofdetail *)soap_instantiate__genmesh__levelofdetail(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__levelofdetail ** p = (_genmesh__levelofdetail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__levelofdetail, sizeof(_genmesh__levelofdetail), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__boneassignments(struct soap *soap, _genmesh__boneassignments *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__boneassignments))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__boneassignments(struct soap *soap, _genmesh__boneassignments *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__boneassignments);
	if (soap_out_PointerTo_genmesh__boneassignments(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__boneassignments(struct soap *soap, const char *tag, int id, _genmesh__boneassignments *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__boneassignments);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__boneassignments ** SOAP_FMAC4 soap_get_PointerTo_genmesh__boneassignments(struct soap *soap, _genmesh__boneassignments **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__boneassignments(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__boneassignments ** SOAP_FMAC4 soap_in_PointerTo_genmesh__boneassignments(struct soap *soap, const char *tag, _genmesh__boneassignments **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__boneassignments **)soap_malloc(soap, sizeof(_genmesh__boneassignments *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__boneassignments *)soap_instantiate__genmesh__boneassignments(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__boneassignments ** p = (_genmesh__boneassignments **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__boneassignments, sizeof(_genmesh__boneassignments), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__skeletonlink(struct soap *soap, _genmesh__skeletonlink *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__skeletonlink))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__skeletonlink(struct soap *soap, _genmesh__skeletonlink *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__skeletonlink);
	if (soap_out_PointerTo_genmesh__skeletonlink(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__skeletonlink(struct soap *soap, const char *tag, int id, _genmesh__skeletonlink *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__skeletonlink);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__skeletonlink ** SOAP_FMAC4 soap_get_PointerTo_genmesh__skeletonlink(struct soap *soap, _genmesh__skeletonlink **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__skeletonlink(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__skeletonlink ** SOAP_FMAC4 soap_in_PointerTo_genmesh__skeletonlink(struct soap *soap, const char *tag, _genmesh__skeletonlink **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__skeletonlink **)soap_malloc(soap, sizeof(_genmesh__skeletonlink *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__skeletonlink *)soap_instantiate__genmesh__skeletonlink(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__skeletonlink ** p = (_genmesh__skeletonlink **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__skeletonlink, sizeof(_genmesh__skeletonlink), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__submeshes(struct soap *soap, _genmesh__submeshes *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__submeshes))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__submeshes(struct soap *soap, _genmesh__submeshes *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__submeshes);
	if (soap_out_PointerTo_genmesh__submeshes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__submeshes(struct soap *soap, const char *tag, int id, _genmesh__submeshes *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__submeshes);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__submeshes ** SOAP_FMAC4 soap_get_PointerTo_genmesh__submeshes(struct soap *soap, _genmesh__submeshes **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__submeshes(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__submeshes ** SOAP_FMAC4 soap_in_PointerTo_genmesh__submeshes(struct soap *soap, const char *tag, _genmesh__submeshes **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__submeshes **)soap_malloc(soap, sizeof(_genmesh__submeshes *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__submeshes *)soap_instantiate__genmesh__submeshes(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__submeshes ** p = (_genmesh__submeshes **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__submeshes, sizeof(_genmesh__submeshes), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTo_genmesh__sharedgeometry(struct soap *soap, _genmesh__sharedgeometry *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE__genmesh__sharedgeometry))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTo_genmesh__sharedgeometry(struct soap *soap, _genmesh__sharedgeometry *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTo_genmesh__sharedgeometry);
	if (soap_out_PointerTo_genmesh__sharedgeometry(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTo_genmesh__sharedgeometry(struct soap *soap, const char *tag, int id, _genmesh__sharedgeometry *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE__genmesh__sharedgeometry);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 _genmesh__sharedgeometry ** SOAP_FMAC4 soap_get_PointerTo_genmesh__sharedgeometry(struct soap *soap, _genmesh__sharedgeometry **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTo_genmesh__sharedgeometry(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 _genmesh__sharedgeometry ** SOAP_FMAC4 soap_in_PointerTo_genmesh__sharedgeometry(struct soap *soap, const char *tag, _genmesh__sharedgeometry **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (_genmesh__sharedgeometry **)soap_malloc(soap, sizeof(_genmesh__sharedgeometry *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (_genmesh__sharedgeometry *)soap_instantiate__genmesh__sharedgeometry(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	_genmesh__sharedgeometry ** p = (_genmesh__sharedgeometry **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE__genmesh__sharedgeometry, sizeof(_genmesh__sharedgeometry), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogenmech__mesh(struct soap *soap, genmech__mesh *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_genmech__mesh))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogenmech__mesh(struct soap *soap, genmech__mesh *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogenmech__mesh);
	if (soap_out_PointerTogenmech__mesh(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogenmech__mesh(struct soap *soap, const char *tag, int id, genmech__mesh *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_genmech__mesh);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 genmech__mesh ** SOAP_FMAC4 soap_get_PointerTogenmech__mesh(struct soap *soap, genmech__mesh **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogenmech__mesh(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 genmech__mesh ** SOAP_FMAC4 soap_in_PointerTogenmech__mesh(struct soap *soap, const char *tag, genmech__mesh **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (genmech__mesh **)soap_malloc(soap, sizeof(genmech__mesh *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (genmech__mesh *)soap_instantiate_genmech__mesh(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	genmech__mesh ** p = (genmech__mesh **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_genmech__mesh, sizeof(genmech__mesh), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogenmech__design(struct soap *soap, genmech__design *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_genmech__design))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogenmech__design(struct soap *soap, genmech__design *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogenmech__design);
	if (soap_out_PointerTogenmech__design(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogenmech__design(struct soap *soap, const char *tag, int id, genmech__design *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_genmech__design);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 genmech__design ** SOAP_FMAC4 soap_get_PointerTogenmech__design(struct soap *soap, genmech__design **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogenmech__design(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 genmech__design ** SOAP_FMAC4 soap_in_PointerTogenmech__design(struct soap *soap, const char *tag, genmech__design **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (genmech__design **)soap_malloc(soap, sizeof(genmech__design *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (genmech__design *)soap_instantiate_genmech__design(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	genmech__design ** p = (genmech__design **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_genmech__design, sizeof(genmech__design), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogenmech__stats(struct soap *soap, genmech__stats *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_genmech__stats))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogenmech__stats(struct soap *soap, genmech__stats *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogenmech__stats);
	if (soap_out_PointerTogenmech__stats(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogenmech__stats(struct soap *soap, const char *tag, int id, genmech__stats *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_genmech__stats);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 genmech__stats ** SOAP_FMAC4 soap_get_PointerTogenmech__stats(struct soap *soap, genmech__stats **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogenmech__stats(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 genmech__stats ** SOAP_FMAC4 soap_in_PointerTogenmech__stats(struct soap *soap, const char *tag, genmech__stats **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (genmech__stats **)soap_malloc(soap, sizeof(genmech__stats *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (genmech__stats *)soap_instantiate_genmech__stats(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	genmech__stats ** p = (genmech__stats **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_genmech__stats, sizeof(genmech__stats), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogenmech__equSlot(struct soap *soap, genmech__equSlot *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_genmech__equSlot))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogenmech__equSlot(struct soap *soap, genmech__equSlot *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogenmech__equSlot);
	if (soap_out_PointerTogenmech__equSlot(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogenmech__equSlot(struct soap *soap, const char *tag, int id, genmech__equSlot *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_genmech__equSlot);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 genmech__equSlot ** SOAP_FMAC4 soap_get_PointerTogenmech__equSlot(struct soap *soap, genmech__equSlot **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogenmech__equSlot(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 genmech__equSlot ** SOAP_FMAC4 soap_in_PointerTogenmech__equSlot(struct soap *soap, const char *tag, genmech__equSlot **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (genmech__equSlot **)soap_malloc(soap, sizeof(genmech__equSlot *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (genmech__equSlot *)soap_instantiate_genmech__equSlot(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	genmech__equSlot ** p = (genmech__equSlot **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_genmech__equSlot, sizeof(genmech__equSlot), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogenmech__equSlots(struct soap *soap, genmech__equSlots *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_genmech__equSlots))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogenmech__equSlots(struct soap *soap, genmech__equSlots *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogenmech__equSlots);
	if (soap_out_PointerTogenmech__equSlots(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogenmech__equSlots(struct soap *soap, const char *tag, int id, genmech__equSlots *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_genmech__equSlots);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 genmech__equSlots ** SOAP_FMAC4 soap_get_PointerTogenmech__equSlots(struct soap *soap, genmech__equSlots **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogenmech__equSlots(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 genmech__equSlots ** SOAP_FMAC4 soap_in_PointerTogenmech__equSlots(struct soap *soap, const char *tag, genmech__equSlots **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (genmech__equSlots **)soap_malloc(soap, sizeof(genmech__equSlots *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (genmech__equSlots *)soap_instantiate_genmech__equSlots(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	genmech__equSlots ** p = (genmech__equSlots **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_genmech__equSlots, sizeof(genmech__equSlots), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTogenmech__torso(struct soap *soap, genmech__torso *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_genmech__torso))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTogenmech__torso(struct soap *soap, genmech__torso *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTogenmech__torso);
	if (soap_out_PointerTogenmech__torso(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTogenmech__torso(struct soap *soap, const char *tag, int id, genmech__torso *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_genmech__torso);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 genmech__torso ** SOAP_FMAC4 soap_get_PointerTogenmech__torso(struct soap *soap, genmech__torso **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTogenmech__torso(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 genmech__torso ** SOAP_FMAC4 soap_in_PointerTogenmech__torso(struct soap *soap, const char *tag, genmech__torso **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (genmech__torso **)soap_malloc(soap, sizeof(genmech__torso *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (genmech__torso *)soap_instantiate_genmech__torso(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	genmech__torso ** p = (genmech__torso **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_genmech__torso, sizeof(genmech__torso), 0);
		a = p;
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genskel__animationlink(struct soap *soap, std::vector<_genskel__animationlink * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genskel__animationlink(struct soap *soap, const std::vector<_genskel__animationlink * >*a)
{
	for (std::vector<_genskel__animationlink * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genskel__animationlink(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genskel__animationlink(struct soap *soap, const char *tag, int id, const std::vector<_genskel__animationlink * >*a, const char *type)
{
	for (std::vector<_genskel__animationlink * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genskel__animationlink(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genskel__animationlink * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genskel__animationlink(struct soap *soap, const char *tag, std::vector<_genskel__animationlink * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genskel__animationlink(soap, -1)))
		return NULL;
	_genskel__animationlink *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genskel__animationlink, SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__animationlink, sizeof(_genskel__animationlink), 1))
				break;
			if (!soap_in_PointerTo_genskel__animationlink(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genskel__animationlink(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genskel__animationlink * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genskel__animationlink(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genskel__animationlink(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genskel__animationlink(struct soap *soap, std::vector<_genskel__animationlink * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genskel__animationlink * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genskel__animationlink(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genskel__animationlink(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__animationlink, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genskel__animationlink * >;
		if (size)
			*size = sizeof(std::vector<_genskel__animationlink * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genskel__animationlink * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genskel__animationlink * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genskel__animationlink * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genskel__animationlink(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genskel__animationlink * > %p -> %p\n", q, p));
	*(std::vector<_genskel__animationlink * >*)p = *(std::vector<_genskel__animationlink * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genskel__keyframe(struct soap *soap, std::vector<_genskel__keyframe * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genskel__keyframe(struct soap *soap, const std::vector<_genskel__keyframe * >*a)
{
	for (std::vector<_genskel__keyframe * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genskel__keyframe(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genskel__keyframe(struct soap *soap, const char *tag, int id, const std::vector<_genskel__keyframe * >*a, const char *type)
{
	for (std::vector<_genskel__keyframe * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genskel__keyframe(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genskel__keyframe * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genskel__keyframe(struct soap *soap, const char *tag, std::vector<_genskel__keyframe * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genskel__keyframe(soap, -1)))
		return NULL;
	_genskel__keyframe *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genskel__keyframe, SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__keyframe, sizeof(_genskel__keyframe), 1))
				break;
			if (!soap_in_PointerTo_genskel__keyframe(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genskel__keyframe(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genskel__keyframe * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genskel__keyframe(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genskel__keyframe(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genskel__keyframe(struct soap *soap, std::vector<_genskel__keyframe * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genskel__keyframe * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genskel__keyframe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genskel__keyframe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__keyframe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genskel__keyframe * >;
		if (size)
			*size = sizeof(std::vector<_genskel__keyframe * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genskel__keyframe * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genskel__keyframe * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genskel__keyframe * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genskel__keyframe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genskel__keyframe * > %p -> %p\n", q, p));
	*(std::vector<_genskel__keyframe * >*)p = *(std::vector<_genskel__keyframe * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genskel__track(struct soap *soap, std::vector<_genskel__track * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genskel__track(struct soap *soap, const std::vector<_genskel__track * >*a)
{
	for (std::vector<_genskel__track * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genskel__track(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genskel__track(struct soap *soap, const char *tag, int id, const std::vector<_genskel__track * >*a, const char *type)
{
	for (std::vector<_genskel__track * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genskel__track(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genskel__track * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genskel__track(struct soap *soap, const char *tag, std::vector<_genskel__track * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genskel__track(soap, -1)))
		return NULL;
	_genskel__track *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genskel__track, SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__track, sizeof(_genskel__track), 1))
				break;
			if (!soap_in_PointerTo_genskel__track(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genskel__track(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genskel__track * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genskel__track(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genskel__track(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genskel__track(struct soap *soap, std::vector<_genskel__track * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genskel__track * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genskel__track(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genskel__track(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__track, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genskel__track * >;
		if (size)
			*size = sizeof(std::vector<_genskel__track * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genskel__track * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genskel__track * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genskel__track * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genskel__track(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genskel__track * > %p -> %p\n", q, p));
	*(std::vector<_genskel__track * >*)p = *(std::vector<_genskel__track * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genskel__animation(struct soap *soap, std::vector<_genskel__animation * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genskel__animation(struct soap *soap, const std::vector<_genskel__animation * >*a)
{
	for (std::vector<_genskel__animation * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genskel__animation(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genskel__animation(struct soap *soap, const char *tag, int id, const std::vector<_genskel__animation * >*a, const char *type)
{
	for (std::vector<_genskel__animation * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genskel__animation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genskel__animation * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genskel__animation(struct soap *soap, const char *tag, std::vector<_genskel__animation * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genskel__animation(soap, -1)))
		return NULL;
	_genskel__animation *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genskel__animation, SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__animation, sizeof(_genskel__animation), 1))
				break;
			if (!soap_in_PointerTo_genskel__animation(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genskel__animation(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genskel__animation * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genskel__animation(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genskel__animation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genskel__animation(struct soap *soap, std::vector<_genskel__animation * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genskel__animation * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genskel__animation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genskel__animation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__animation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genskel__animation * >;
		if (size)
			*size = sizeof(std::vector<_genskel__animation * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genskel__animation * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genskel__animation * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genskel__animation * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genskel__animation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genskel__animation * > %p -> %p\n", q, p));
	*(std::vector<_genskel__animation * >*)p = *(std::vector<_genskel__animation * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genskel__boneparent(struct soap *soap, std::vector<_genskel__boneparent * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genskel__boneparent(struct soap *soap, const std::vector<_genskel__boneparent * >*a)
{
	for (std::vector<_genskel__boneparent * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genskel__boneparent(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genskel__boneparent(struct soap *soap, const char *tag, int id, const std::vector<_genskel__boneparent * >*a, const char *type)
{
	for (std::vector<_genskel__boneparent * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genskel__boneparent(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genskel__boneparent * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genskel__boneparent(struct soap *soap, const char *tag, std::vector<_genskel__boneparent * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genskel__boneparent(soap, -1)))
		return NULL;
	_genskel__boneparent *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genskel__boneparent, SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__boneparent, sizeof(_genskel__boneparent), 1))
				break;
			if (!soap_in_PointerTo_genskel__boneparent(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genskel__boneparent(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genskel__boneparent * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genskel__boneparent(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genskel__boneparent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genskel__boneparent(struct soap *soap, std::vector<_genskel__boneparent * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genskel__boneparent * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genskel__boneparent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genskel__boneparent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genskel__boneparent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genskel__boneparent * >;
		if (size)
			*size = sizeof(std::vector<_genskel__boneparent * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genskel__boneparent * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genskel__boneparent * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genskel__boneparent * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genskel__boneparent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genskel__boneparent * > %p -> %p\n", q, p));
	*(std::vector<_genskel__boneparent * >*)p = *(std::vector<_genskel__boneparent * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTogenskel__bone(struct soap *soap, std::vector<genskel__bone * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTogenskel__bone(struct soap *soap, const std::vector<genskel__bone * >*a)
{
	for (std::vector<genskel__bone * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTogenskel__bone(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTogenskel__bone(struct soap *soap, const char *tag, int id, const std::vector<genskel__bone * >*a, const char *type)
{
	for (std::vector<genskel__bone * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTogenskel__bone(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<genskel__bone * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTogenskel__bone(struct soap *soap, const char *tag, std::vector<genskel__bone * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTogenskel__bone(soap, -1)))
		return NULL;
	genskel__bone *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_genskel__bone, SOAP_TYPE_std__vectorTemplateOfPointerTogenskel__bone, sizeof(genskel__bone), 1))
				break;
			if (!soap_in_PointerTogenskel__bone(soap, tag, NULL, "genskel:bone"))
				break;
		}
		else
		{
			if (!soap_in_PointerTogenskel__bone(soap, tag, &n, "genskel:bone"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<genskel__bone * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTogenskel__bone(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTogenskel__bone(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTogenskel__bone(struct soap *soap, std::vector<genskel__bone * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<genskel__bone * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTogenskel__bone(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTogenskel__bone(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTogenskel__bone, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<genskel__bone * >;
		if (size)
			*size = sizeof(std::vector<genskel__bone * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<genskel__bone * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<genskel__bone * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<genskel__bone * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTogenskel__bone(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<genskel__bone * > %p -> %p\n", q, p));
	*(std::vector<genskel__bone * >*)p = *(std::vector<genskel__bone * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genmesh__poseref(struct soap *soap, std::vector<_genmesh__poseref * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genmesh__poseref(struct soap *soap, const std::vector<_genmesh__poseref * >*a)
{
	for (std::vector<_genmesh__poseref * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genmesh__poseref(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genmesh__poseref(struct soap *soap, const char *tag, int id, const std::vector<_genmesh__poseref * >*a, const char *type)
{
	for (std::vector<_genmesh__poseref * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genmesh__poseref(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genmesh__poseref * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genmesh__poseref(struct soap *soap, const char *tag, std::vector<_genmesh__poseref * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genmesh__poseref(soap, -1)))
		return NULL;
	_genmesh__poseref *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genmesh__poseref, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__poseref, sizeof(_genmesh__poseref), 1))
				break;
			if (!soap_in_PointerTo_genmesh__poseref(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genmesh__poseref(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genmesh__poseref * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genmesh__poseref(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__poseref(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genmesh__poseref(struct soap *soap, std::vector<_genmesh__poseref * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genmesh__poseref * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__poseref(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__poseref(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__poseref, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genmesh__poseref * >;
		if (size)
			*size = sizeof(std::vector<_genmesh__poseref * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genmesh__poseref * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genmesh__poseref * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genmesh__poseref * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genmesh__poseref(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genmesh__poseref * > %p -> %p\n", q, p));
	*(std::vector<_genmesh__poseref * >*)p = *(std::vector<_genmesh__poseref * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genmesh__position(struct soap *soap, std::vector<_genmesh__position * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genmesh__position(struct soap *soap, const std::vector<_genmesh__position * >*a)
{
	for (std::vector<_genmesh__position * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genmesh__position(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genmesh__position(struct soap *soap, const char *tag, int id, const std::vector<_genmesh__position * >*a, const char *type)
{
	for (std::vector<_genmesh__position * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genmesh__position(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genmesh__position * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genmesh__position(struct soap *soap, const char *tag, std::vector<_genmesh__position * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genmesh__position(soap, -1)))
		return NULL;
	_genmesh__position *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genmesh__position, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__position, sizeof(_genmesh__position), 1))
				break;
			if (!soap_in_PointerTo_genmesh__position(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genmesh__position(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genmesh__position * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genmesh__position(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__position(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genmesh__position(struct soap *soap, std::vector<_genmesh__position * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genmesh__position * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__position(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__position(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__position, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genmesh__position * >;
		if (size)
			*size = sizeof(std::vector<_genmesh__position * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genmesh__position * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genmesh__position * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genmesh__position * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genmesh__position(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genmesh__position * > %p -> %p\n", q, p));
	*(std::vector<_genmesh__position * >*)p = *(std::vector<_genmesh__position * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genmesh__keyframe(struct soap *soap, std::vector<_genmesh__keyframe * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genmesh__keyframe(struct soap *soap, const std::vector<_genmesh__keyframe * >*a)
{
	for (std::vector<_genmesh__keyframe * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genmesh__keyframe(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genmesh__keyframe(struct soap *soap, const char *tag, int id, const std::vector<_genmesh__keyframe * >*a, const char *type)
{
	for (std::vector<_genmesh__keyframe * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genmesh__keyframe(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genmesh__keyframe * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genmesh__keyframe(struct soap *soap, const char *tag, std::vector<_genmesh__keyframe * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genmesh__keyframe(soap, -1)))
		return NULL;
	_genmesh__keyframe *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genmesh__keyframe, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__keyframe, sizeof(_genmesh__keyframe), 1))
				break;
			if (!soap_in_PointerTo_genmesh__keyframe(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genmesh__keyframe(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genmesh__keyframe * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genmesh__keyframe(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__keyframe(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genmesh__keyframe(struct soap *soap, std::vector<_genmesh__keyframe * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genmesh__keyframe * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__keyframe(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__keyframe(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__keyframe, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genmesh__keyframe * >;
		if (size)
			*size = sizeof(std::vector<_genmesh__keyframe * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genmesh__keyframe * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genmesh__keyframe * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genmesh__keyframe * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genmesh__keyframe(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genmesh__keyframe * > %p -> %p\n", q, p));
	*(std::vector<_genmesh__keyframe * >*)p = *(std::vector<_genmesh__keyframe * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genmesh__track(struct soap *soap, std::vector<_genmesh__track * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genmesh__track(struct soap *soap, const std::vector<_genmesh__track * >*a)
{
	for (std::vector<_genmesh__track * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genmesh__track(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genmesh__track(struct soap *soap, const char *tag, int id, const std::vector<_genmesh__track * >*a, const char *type)
{
	for (std::vector<_genmesh__track * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genmesh__track(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genmesh__track * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genmesh__track(struct soap *soap, const char *tag, std::vector<_genmesh__track * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genmesh__track(soap, -1)))
		return NULL;
	_genmesh__track *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genmesh__track, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__track, sizeof(_genmesh__track), 1))
				break;
			if (!soap_in_PointerTo_genmesh__track(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genmesh__track(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genmesh__track * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genmesh__track(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__track(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genmesh__track(struct soap *soap, std::vector<_genmesh__track * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genmesh__track * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__track(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__track(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__track, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genmesh__track * >;
		if (size)
			*size = sizeof(std::vector<_genmesh__track * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genmesh__track * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genmesh__track * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genmesh__track * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genmesh__track(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genmesh__track * > %p -> %p\n", q, p));
	*(std::vector<_genmesh__track * >*)p = *(std::vector<_genmesh__track * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genmesh__animation(struct soap *soap, std::vector<_genmesh__animation * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genmesh__animation(struct soap *soap, const std::vector<_genmesh__animation * >*a)
{
	for (std::vector<_genmesh__animation * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genmesh__animation(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genmesh__animation(struct soap *soap, const char *tag, int id, const std::vector<_genmesh__animation * >*a, const char *type)
{
	for (std::vector<_genmesh__animation * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genmesh__animation(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genmesh__animation * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genmesh__animation(struct soap *soap, const char *tag, std::vector<_genmesh__animation * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genmesh__animation(soap, -1)))
		return NULL;
	_genmesh__animation *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genmesh__animation, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__animation, sizeof(_genmesh__animation), 1))
				break;
			if (!soap_in_PointerTo_genmesh__animation(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genmesh__animation(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genmesh__animation * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genmesh__animation(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__animation(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genmesh__animation(struct soap *soap, std::vector<_genmesh__animation * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genmesh__animation * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__animation(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__animation(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__animation, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genmesh__animation * >;
		if (size)
			*size = sizeof(std::vector<_genmesh__animation * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genmesh__animation * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genmesh__animation * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genmesh__animation * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genmesh__animation(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genmesh__animation * > %p -> %p\n", q, p));
	*(std::vector<_genmesh__animation * >*)p = *(std::vector<_genmesh__animation * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genmesh__poseoffset(struct soap *soap, std::vector<_genmesh__poseoffset * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genmesh__poseoffset(struct soap *soap, const std::vector<_genmesh__poseoffset * >*a)
{
	for (std::vector<_genmesh__poseoffset * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genmesh__poseoffset(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genmesh__poseoffset(struct soap *soap, const char *tag, int id, const std::vector<_genmesh__poseoffset * >*a, const char *type)
{
	for (std::vector<_genmesh__poseoffset * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genmesh__poseoffset(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genmesh__poseoffset * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genmesh__poseoffset(struct soap *soap, const char *tag, std::vector<_genmesh__poseoffset * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genmesh__poseoffset(soap, -1)))
		return NULL;
	_genmesh__poseoffset *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genmesh__poseoffset, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__poseoffset, sizeof(_genmesh__poseoffset), 1))
				break;
			if (!soap_in_PointerTo_genmesh__poseoffset(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genmesh__poseoffset(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genmesh__poseoffset * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genmesh__poseoffset(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__poseoffset(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genmesh__poseoffset(struct soap *soap, std::vector<_genmesh__poseoffset * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genmesh__poseoffset * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__poseoffset(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__poseoffset(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__poseoffset, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genmesh__poseoffset * >;
		if (size)
			*size = sizeof(std::vector<_genmesh__poseoffset * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genmesh__poseoffset * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genmesh__poseoffset * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genmesh__poseoffset * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genmesh__poseoffset(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genmesh__poseoffset * > %p -> %p\n", q, p));
	*(std::vector<_genmesh__poseoffset * >*)p = *(std::vector<_genmesh__poseoffset * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genmesh__pose(struct soap *soap, std::vector<_genmesh__pose * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genmesh__pose(struct soap *soap, const std::vector<_genmesh__pose * >*a)
{
	for (std::vector<_genmesh__pose * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genmesh__pose(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genmesh__pose(struct soap *soap, const char *tag, int id, const std::vector<_genmesh__pose * >*a, const char *type)
{
	for (std::vector<_genmesh__pose * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genmesh__pose(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genmesh__pose * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genmesh__pose(struct soap *soap, const char *tag, std::vector<_genmesh__pose * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genmesh__pose(soap, -1)))
		return NULL;
	_genmesh__pose *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genmesh__pose, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__pose, sizeof(_genmesh__pose), 1))
				break;
			if (!soap_in_PointerTo_genmesh__pose(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genmesh__pose(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genmesh__pose * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genmesh__pose(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__pose(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genmesh__pose(struct soap *soap, std::vector<_genmesh__pose * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genmesh__pose * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__pose(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__pose(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__pose, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genmesh__pose * >;
		if (size)
			*size = sizeof(std::vector<_genmesh__pose * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genmesh__pose * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genmesh__pose * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genmesh__pose * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genmesh__pose(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genmesh__pose * > %p -> %p\n", q, p));
	*(std::vector<_genmesh__pose * >*)p = *(std::vector<_genmesh__pose * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genmesh__submeshname(struct soap *soap, std::vector<_genmesh__submeshname * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genmesh__submeshname(struct soap *soap, const std::vector<_genmesh__submeshname * >*a)
{
	for (std::vector<_genmesh__submeshname * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genmesh__submeshname(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genmesh__submeshname(struct soap *soap, const char *tag, int id, const std::vector<_genmesh__submeshname * >*a, const char *type)
{
	for (std::vector<_genmesh__submeshname * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genmesh__submeshname(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genmesh__submeshname * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genmesh__submeshname(struct soap *soap, const char *tag, std::vector<_genmesh__submeshname * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genmesh__submeshname(soap, -1)))
		return NULL;
	_genmesh__submeshname *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genmesh__submeshname, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__submeshname, sizeof(_genmesh__submeshname), 1))
				break;
			if (!soap_in_PointerTo_genmesh__submeshname(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genmesh__submeshname(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genmesh__submeshname * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genmesh__submeshname(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__submeshname(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genmesh__submeshname(struct soap *soap, std::vector<_genmesh__submeshname * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genmesh__submeshname * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__submeshname(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__submeshname(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__submeshname, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genmesh__submeshname * >;
		if (size)
			*size = sizeof(std::vector<_genmesh__submeshname * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genmesh__submeshname * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genmesh__submeshname * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genmesh__submeshname * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genmesh__submeshname(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genmesh__submeshname * > %p -> %p\n", q, p));
	*(std::vector<_genmesh__submeshname * >*)p = *(std::vector<_genmesh__submeshname * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genmesh__texcoord(struct soap *soap, std::vector<_genmesh__texcoord * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genmesh__texcoord(struct soap *soap, const std::vector<_genmesh__texcoord * >*a)
{
	for (std::vector<_genmesh__texcoord * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genmesh__texcoord(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genmesh__texcoord(struct soap *soap, const char *tag, int id, const std::vector<_genmesh__texcoord * >*a, const char *type)
{
	for (std::vector<_genmesh__texcoord * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genmesh__texcoord(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genmesh__texcoord * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genmesh__texcoord(struct soap *soap, const char *tag, std::vector<_genmesh__texcoord * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genmesh__texcoord(soap, -1)))
		return NULL;
	_genmesh__texcoord *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genmesh__texcoord, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__texcoord, sizeof(_genmesh__texcoord), 1))
				break;
			if (!soap_in_PointerTo_genmesh__texcoord(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genmesh__texcoord(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genmesh__texcoord * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genmesh__texcoord(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__texcoord(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genmesh__texcoord(struct soap *soap, std::vector<_genmesh__texcoord * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genmesh__texcoord * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__texcoord(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__texcoord(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__texcoord, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genmesh__texcoord * >;
		if (size)
			*size = sizeof(std::vector<_genmesh__texcoord * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genmesh__texcoord * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genmesh__texcoord * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genmesh__texcoord * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genmesh__texcoord(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genmesh__texcoord * > %p -> %p\n", q, p));
	*(std::vector<_genmesh__texcoord * >*)p = *(std::vector<_genmesh__texcoord * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genmesh__vertex(struct soap *soap, std::vector<_genmesh__vertex * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genmesh__vertex(struct soap *soap, const std::vector<_genmesh__vertex * >*a)
{
	for (std::vector<_genmesh__vertex * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genmesh__vertex(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genmesh__vertex(struct soap *soap, const char *tag, int id, const std::vector<_genmesh__vertex * >*a, const char *type)
{
	for (std::vector<_genmesh__vertex * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genmesh__vertex(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genmesh__vertex * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genmesh__vertex(struct soap *soap, const char *tag, std::vector<_genmesh__vertex * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genmesh__vertex(soap, -1)))
		return NULL;
	_genmesh__vertex *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genmesh__vertex, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__vertex, sizeof(_genmesh__vertex), 1))
				break;
			if (!soap_in_PointerTo_genmesh__vertex(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genmesh__vertex(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genmesh__vertex * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genmesh__vertex(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__vertex(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genmesh__vertex(struct soap *soap, std::vector<_genmesh__vertex * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genmesh__vertex * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__vertex(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__vertex(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__vertex, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genmesh__vertex * >;
		if (size)
			*size = sizeof(std::vector<_genmesh__vertex * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genmesh__vertex * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genmesh__vertex * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genmesh__vertex * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genmesh__vertex(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genmesh__vertex * > %p -> %p\n", q, p));
	*(std::vector<_genmesh__vertex * >*)p = *(std::vector<_genmesh__vertex * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment(struct soap *soap, std::vector<_genmesh__vertexboneassignment * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment(struct soap *soap, const std::vector<_genmesh__vertexboneassignment * >*a)
{
	for (std::vector<_genmesh__vertexboneassignment * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genmesh__vertexboneassignment(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment(struct soap *soap, const char *tag, int id, const std::vector<_genmesh__vertexboneassignment * >*a, const char *type)
{
	for (std::vector<_genmesh__vertexboneassignment * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genmesh__vertexboneassignment(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genmesh__vertexboneassignment * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment(struct soap *soap, const char *tag, std::vector<_genmesh__vertexboneassignment * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment(soap, -1)))
		return NULL;
	_genmesh__vertexboneassignment *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genmesh__vertexboneassignment, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment, sizeof(_genmesh__vertexboneassignment), 1))
				break;
			if (!soap_in_PointerTo_genmesh__vertexboneassignment(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genmesh__vertexboneassignment(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genmesh__vertexboneassignment * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment(struct soap *soap, std::vector<_genmesh__vertexboneassignment * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genmesh__vertexboneassignment * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genmesh__vertexboneassignment * >;
		if (size)
			*size = sizeof(std::vector<_genmesh__vertexboneassignment * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genmesh__vertexboneassignment * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genmesh__vertexboneassignment * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genmesh__vertexboneassignment * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genmesh__vertexboneassignment(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genmesh__vertexboneassignment * > %p -> %p\n", q, p));
	*(std::vector<_genmesh__vertexboneassignment * >*)p = *(std::vector<_genmesh__vertexboneassignment * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genmesh__face(struct soap *soap, std::vector<_genmesh__face * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genmesh__face(struct soap *soap, const std::vector<_genmesh__face * >*a)
{
	for (std::vector<_genmesh__face * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genmesh__face(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genmesh__face(struct soap *soap, const char *tag, int id, const std::vector<_genmesh__face * >*a, const char *type)
{
	for (std::vector<_genmesh__face * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genmesh__face(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genmesh__face * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genmesh__face(struct soap *soap, const char *tag, std::vector<_genmesh__face * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genmesh__face(soap, -1)))
		return NULL;
	_genmesh__face *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genmesh__face, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__face, sizeof(_genmesh__face), 1))
				break;
			if (!soap_in_PointerTo_genmesh__face(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genmesh__face(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genmesh__face * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genmesh__face(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__face(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genmesh__face(struct soap *soap, std::vector<_genmesh__face * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genmesh__face * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__face(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__face(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__face, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genmesh__face * >;
		if (size)
			*size = sizeof(std::vector<_genmesh__face * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genmesh__face * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genmesh__face * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genmesh__face * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genmesh__face(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genmesh__face * > %p -> %p\n", q, p));
	*(std::vector<_genmesh__face * >*)p = *(std::vector<_genmesh__face * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genmesh__texture(struct soap *soap, std::vector<_genmesh__texture * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genmesh__texture(struct soap *soap, const std::vector<_genmesh__texture * >*a)
{
	for (std::vector<_genmesh__texture * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genmesh__texture(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genmesh__texture(struct soap *soap, const char *tag, int id, const std::vector<_genmesh__texture * >*a, const char *type)
{
	for (std::vector<_genmesh__texture * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genmesh__texture(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genmesh__texture * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genmesh__texture(struct soap *soap, const char *tag, std::vector<_genmesh__texture * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genmesh__texture(soap, -1)))
		return NULL;
	_genmesh__texture *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genmesh__texture, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__texture, sizeof(_genmesh__texture), 1))
				break;
			if (!soap_in_PointerTo_genmesh__texture(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genmesh__texture(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genmesh__texture * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genmesh__texture(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__texture(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genmesh__texture(struct soap *soap, std::vector<_genmesh__texture * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genmesh__texture * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__texture(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__texture(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__texture, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genmesh__texture * >;
		if (size)
			*size = sizeof(std::vector<_genmesh__texture * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genmesh__texture * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genmesh__texture * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genmesh__texture * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genmesh__texture(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genmesh__texture * > %p -> %p\n", q, p));
	*(std::vector<_genmesh__texture * >*)p = *(std::vector<_genmesh__texture * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genmesh__submesh(struct soap *soap, std::vector<_genmesh__submesh * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genmesh__submesh(struct soap *soap, const std::vector<_genmesh__submesh * >*a)
{
	for (std::vector<_genmesh__submesh * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genmesh__submesh(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genmesh__submesh(struct soap *soap, const char *tag, int id, const std::vector<_genmesh__submesh * >*a, const char *type)
{
	for (std::vector<_genmesh__submesh * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genmesh__submesh(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genmesh__submesh * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genmesh__submesh(struct soap *soap, const char *tag, std::vector<_genmesh__submesh * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genmesh__submesh(soap, -1)))
		return NULL;
	_genmesh__submesh *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genmesh__submesh, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__submesh, sizeof(_genmesh__submesh), 1))
				break;
			if (!soap_in_PointerTo_genmesh__submesh(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genmesh__submesh(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genmesh__submesh * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genmesh__submesh(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__submesh(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genmesh__submesh(struct soap *soap, std::vector<_genmesh__submesh * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genmesh__submesh * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__submesh(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__submesh(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__submesh, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genmesh__submesh * >;
		if (size)
			*size = sizeof(std::vector<_genmesh__submesh * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genmesh__submesh * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genmesh__submesh * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genmesh__submesh * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genmesh__submesh(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genmesh__submesh * > %p -> %p\n", q, p));
	*(std::vector<_genmesh__submesh * >*)p = *(std::vector<_genmesh__submesh * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(struct soap *soap, std::vector<_genmesh__vertexbuffer * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(struct soap *soap, const std::vector<_genmesh__vertexbuffer * >*a)
{
	for (std::vector<_genmesh__vertexbuffer * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTo_genmesh__vertexbuffer(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(struct soap *soap, const char *tag, int id, const std::vector<_genmesh__vertexbuffer * >*a, const char *type)
{
	for (std::vector<_genmesh__vertexbuffer * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTo_genmesh__vertexbuffer(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<_genmesh__vertexbuffer * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(struct soap *soap, const char *tag, std::vector<_genmesh__vertexbuffer * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(soap, -1)))
		return NULL;
	_genmesh__vertexbuffer *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE__genmesh__vertexbuffer, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer, sizeof(_genmesh__vertexbuffer), 1))
				break;
			if (!soap_in_PointerTo_genmesh__vertexbuffer(soap, tag, NULL, ""))
				break;
		}
		else
		{
			if (!soap_in_PointerTo_genmesh__vertexbuffer(soap, tag, &n, ""))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<_genmesh__vertexbuffer * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(struct soap *soap, std::vector<_genmesh__vertexbuffer * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<_genmesh__vertexbuffer * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<_genmesh__vertexbuffer * >;
		if (size)
			*size = sizeof(std::vector<_genmesh__vertexbuffer * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<_genmesh__vertexbuffer * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<_genmesh__vertexbuffer * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<_genmesh__vertexbuffer * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTo_genmesh__vertexbuffer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<_genmesh__vertexbuffer * > %p -> %p\n", q, p));
	*(std::vector<_genmesh__vertexbuffer * >*)p = *(std::vector<_genmesh__vertexbuffer * >*)q;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__vectorTemplateOfPointerTogenmech__equSlot(struct soap *soap, std::vector<genmech__equSlot * >*p)
{
	p->clear();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__vectorTemplateOfPointerTogenmech__equSlot(struct soap *soap, const std::vector<genmech__equSlot * >*a)
{
	for (std::vector<genmech__equSlot * >::const_iterator i = a->begin(); i != a->end(); ++i)
		soap_serialize_PointerTogenmech__equSlot(soap, &(*i));
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__vectorTemplateOfPointerTogenmech__equSlot(struct soap *soap, const char *tag, int id, const std::vector<genmech__equSlot * >*a, const char *type)
{
	for (std::vector<genmech__equSlot * >::const_iterator i = a->begin(); i != a->end(); ++i)
	{
		if (soap_out_PointerTogenmech__equSlot(soap, tag, id, &(*i), ""))
			return soap->error;
	}
	return SOAP_OK;
}

SOAP_FMAC3 std::vector<genmech__equSlot * >* SOAP_FMAC4 soap_in_std__vectorTemplateOfPointerTogenmech__equSlot(struct soap *soap, const char *tag, std::vector<genmech__equSlot * >*a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a && !(a = soap_new_std__vectorTemplateOfPointerTogenmech__equSlot(soap, -1)))
		return NULL;
	genmech__equSlot *n;
	short soap_flag = 0;
	do
	{	soap_revert(soap);
		n = NULL;
		if (*soap->id || *soap->href)
		{	if (!soap_container_id_forward(soap, *soap->id?soap->id:soap->href, a, (size_t)a->size(), SOAP_TYPE_genmech__equSlot, SOAP_TYPE_std__vectorTemplateOfPointerTogenmech__equSlot, sizeof(genmech__equSlot), 1))
				break;
			if (!soap_in_PointerTogenmech__equSlot(soap, tag, NULL, "genmech:equSlot"))
				break;
		}
		else
		{
			if (!soap_in_PointerTogenmech__equSlot(soap, tag, &n, "genmech:equSlot"))
				break;
		}
		a->push_back(n);
		soap_flag = 1;
	}
	while (!soap_element_begin_in(soap, tag, 1, NULL));
	if (soap_flag && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
	{	soap->error = SOAP_OK;
		return a;
	}
	return NULL;
}

SOAP_FMAC5 std::vector<genmech__equSlot * > * SOAP_FMAC6 soap_new_std__vectorTemplateOfPointerTogenmech__equSlot(struct soap *soap, int n)
{	return soap_instantiate_std__vectorTemplateOfPointerTogenmech__equSlot(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__vectorTemplateOfPointerTogenmech__equSlot(struct soap *soap, std::vector<genmech__equSlot * >*p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::vector<genmech__equSlot * > * SOAP_FMAC4 soap_instantiate_std__vectorTemplateOfPointerTogenmech__equSlot(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__vectorTemplateOfPointerTogenmech__equSlot(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__vectorTemplateOfPointerTogenmech__equSlot, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::vector<genmech__equSlot * >;
		if (size)
			*size = sizeof(std::vector<genmech__equSlot * >);
	}
	else
	{	cp->ptr = (void*)new std::vector<genmech__equSlot * >[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::vector<genmech__equSlot * >);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::vector<genmech__equSlot * >*)cp->ptr;
}
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__vectorTemplateOfPointerTogenmech__equSlot(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::vector<genmech__equSlot * > %p -> %p\n", q, p));
	*(std::vector<genmech__equSlot * >*)p = *(std::vector<genmech__equSlot * >*)q;
}

/* End of generatedC.cpp */
